import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import React, { useEffect, useCallback, useRef } from 'react';
import PropTypes from 'prop-types';
import { createUseStyles } from 'react-jss';
import cn from 'classnames';
import VirtualizedTable from 'react-virtualized/dist/commonjs/Table/Table';
import Column from 'react-virtualized/dist/commonjs/Table/Column';
import InfiniteLoader from 'react-virtualized/dist/commonjs/InfiniteLoader';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import SortDirection from 'react-virtualized/dist/commonjs/Table/SortDirection';
import getCellRenderer from "./getCellRenderer";
import { grayLight } from "../../theme/colors";
var UNIT_SIZE = 5;

var units = function units(size) {
  return UNIT_SIZE * size;
};

var useStyles = createUseStyles({
  table: {
    '& .ReactVirtualized__Table__row': {
      borderBottom: "1px solid ".concat(grayLight),
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'center'
    },
    '& .ReactVirtualized__Table__headerRow': {
      borderBottom: "1px solid ".concat(grayLight),
      fontWeight: 'normal',
      textTransform: 'uppercase',
      display: 'flex',
      alignItems: 'center'
    },
    '& .ReactVirtualized__Table__headerColumn:first-of-type, & .ReactVirtualized__Table__rowColumn:first-of-type ': {
      paddingLeft: units(2)
    },
    '& .ReactVirtualized__Table__headerColumn, & .ReactVirtualized__Table__rowColumn': {
      minWidth: 0,
      paddingRight: units(4),
      paddingLeft: units(4)
    },
    '& .ReactVirtualized__Table__headerTruncatedText': {
      display: 'inline-block',
      maxWidth: '100%',
      whiteSpace: 'nowrap',
      textOverflow: 'ellipsis',
      overflow: 'hidden'
    },
    '& .ReactVirtualized__Table__sortableHeaderColumn': {
      cursor: 'pointer'
    },
    '& .ReactVirtualized__Table__rowColumn': {
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    },
    '& .ReactVirtualized__Table__rowColumn:last-child, ReactVirtualized__Table__headerColumn:last-child': {
      paddingRight: units(2)
    },
    '& .ReactVirtualized__Table__rowColumn.borderLeft': {
      borderLeft: "1px solid ".concat(grayLight)
    },
    '& .ReactVirtualized__Table__rowColumn.borderRight': {
      borderRight: "1px solid ".concat(grayLight)
    },
    '& .ReactVirtualized__Table__rowColumn.borderLeft, & .ReactVirtualized__Table__rowColumn.borderRight': {
      display: 'flex',
      alignItems: 'center',
      height: units(8)
    }
  }
});

var Table = function Table(_ref) {
  var className = _ref.className,
      rowClassName = _ref.rowClassName,
      style = _ref.style,
      onSort = _ref.onSort,
      sortBy = _ref.sortBy,
      sortDirection = _ref.sortDirection,
      hasNextPage = _ref.hasNextPage,
      isLoading = _ref.isLoading,
      onLoadNextPage = _ref.onLoadNextPage,
      items = _ref.items,
      children = _ref.children,
      onRowOver = _ref.onRowOver,
      onRowOut = _ref.onRowOut,
      placeholderRowCount = _ref.placeholderRowCount,
      pageSize = _ref.pageSize,
      restOfProps = _objectWithoutProperties(_ref, ["className", "rowClassName", "style", "onSort", "sortBy", "sortDirection", "hasNextPage", "isLoading", "onLoadNextPage", "items", "children", "onRowOver", "onRowOut", "placeholderRowCount", "pageSize"]);

  var classes = useStyles();
  var ref = useRef(null);
  var promiseRef = useRef(null);
  var loadMoreRows = useCallback(function () {
    return isLoading ? null : new Promise(function (resolve) {
      promiseRef.current = resolve;
      onLoadNextPage();
    });
  }, [isLoading, onLoadNextPage]);
  var rowCount = hasNextPage ? Math.max(pageSize, items.length + placeholderRowCount) : items.length;
  var rowGetter = useCallback(function (_ref2) {
    var index = _ref2.index;
    return items[index] || {};
  }, [items]);
  var isRowLoaded = useCallback(function (_ref3) {
    var index = _ref3.index;
    return !hasNextPage || index < items.length;
  }, [hasNextPage, items]);
  useEffect(function () {
    if (items.length === 0) {
      // Workaround to fix table not being re-rendered if data changed and scroll position is on top
      var forceRender = ref.current._lastRenderedStartIndex === 0;
      ref.current.resetLoadMoreRowsCache(forceRender);

      ref.current._registeredChild.scrollToRow(0);
    }
  }, [items]);
  useEffect(function () {
    if (!isLoading && promiseRef) {
      if (promiseRef.current) {
        promiseRef.current();
        promiseRef.current = null;
      }
    }
  }, [isLoading]);
  return /*#__PURE__*/React.createElement(InfiniteLoader, {
    ref: ref,
    rowCount: rowCount,
    loadMoreRows: loadMoreRows,
    isRowLoaded: isRowLoaded,
    "data-qa": "table"
  }, function (_ref4) {
    var onRowsRendered = _ref4.onRowsRendered,
        registerChild = _ref4.registerChild;
    return /*#__PURE__*/React.createElement(AutoSizer, null, function (_ref5) {
      var width = _ref5.width,
          height = _ref5.height;
      return /*#__PURE__*/React.createElement(VirtualizedTable, _extends({
        className: cn(className, classes.table),
        style: style,
        ref: registerChild,
        onRowsRendered: onRowsRendered,
        headerClassName: "font-size-sm text-gray-dark",
        rowClassName: rowClassName,
        headerHeight: 50,
        rowHeight: 40,
        width: width,
        height: height,
        sort: onSort,
        sortBy: sortBy,
        sortDirection: sortDirection,
        rowCount: rowCount,
        onRowMouseOver: onRowOver,
        onRowMouseOut: onRowOut,
        rowGetter: rowGetter
      }, restOfProps), React.Children.map(children, function (child) {
        var _child$props = child.props,
            borderLeft = _child$props.borderLeft,
            borderRight = _child$props.borderRight,
            placeholder = _child$props.placeholder,
            cellRenderer = _child$props.cellRenderer,
            headerRenderer = _child$props.headerRenderer,
            columnClassName = _child$props.className,
            rest = _objectWithoutProperties(_child$props, ["borderLeft", "borderRight", "placeholder", "cellRenderer", "headerRenderer", "className"]);

        return /*#__PURE__*/React.createElement(Column, _extends({}, rest, {
          className: cn('font-size-md', columnClassName, {
            borderLeft: borderLeft,
            borderRight: borderRight
          }),
          headerRenderer: headerRenderer,
          cellRenderer: getCellRenderer({
            isLoading: isLoading,
            placeholder: placeholder,
            cellRenderer: cellRenderer
          })
        }));
      }));
    });
  });
};

Table.defaultProps = {
  className: '',
  style: {},
  sortBy: '',
  placeholderRowCount: 3,
  pageSize: 40
};
Table.propTypes = {
  /** Additional class name */
  className: PropTypes.string,

  /**	Additional style for table element  */
  style: PropTypes.shape(),

  /** Sort function called when you click on the headers */
  onSort: PropTypes.func,

  /** Sort key, should be the same as current sort column dataKey */
  sortBy: PropTypes.string,

  /** Sort direction: ASC, DESC */
  sortDirection: PropTypes.oneOf([SortDirection.ASC, SortDirection.DESC]),

  /** boolean indicating if there is a next page */
  hasNextPage: PropTypes.bool,

  /** function invoked automatically to fetch more data */
  onLoadNextPage: PropTypes.func.isRequired,

  /** Items array repesenting the data */
  items: PropTypes.arrayOf(PropTypes.object).isRequired,

  /** How many extra rows to render as placeholders at the end of the table */
  placeholderRowCount: PropTypes.number,

  /** How many placeholders to show on initial load */
  pageSize: PropTypes.number,

  /** Event for row over */
  onRowOver: PropTypes.func
};
export default Table;