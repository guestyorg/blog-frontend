import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import React, { useCallback, useEffect, useRef, useState } from 'react';
import PropTypes from 'prop-types';
import debounce from 'lodash/debounce';
import { AnchorDirectionType, OriginDirectionType } from "../../enums";
import Portal from "../Portal";
import createStyles from "../../createStyles";
import CSSTransition from "../../CSSTransition";
const anchorTransformOriginMapper = {
  start: 'left',
  end: 'right',
  center: 'center'
};
const originTransformOriginMapper = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const useStyles = createStyles(theme => ({
  backdrop: {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: theme.zIndex.dropdown - 1,
    position: 'fixed',
    touchAction: 'none',
    backgroundColor: 'transparent'
  },
  innerContent: {
    position: 'absolute',
    zIndex: theme.zIndex.dropdown
  }
}), {
  name: 'PortalAutoPosition'
});
export const getPortalWidth = (isFit, contentOffsetWidth, parentWidth) => {
  if (!isFit) {
    return;
  }

  return contentOffsetWidth >= parentWidth ? contentOffsetWidth : parentWidth;
};

const isInYViewPort = offsetHeight => offsetHeight < window.scrollY + (window.innerHeight || document.documentElement.clientHeight);

const getWindowWidth = () => window.innerWidth || document.documentElement.clientWidth;

export const getTransformDirection = (direction, anchor) => {
  const isVertical = direction === OriginDirectionType.Left || direction === OriginDirectionType.Right;
  const transformX = anchorTransformOriginMapper[anchor];
  const originDirection = originTransformOriginMapper[direction];
  let anchorDirection = transformX;

  if (isVertical) {
    switch (anchor) {
      case AnchorDirectionType.End:
        anchorDirection = OriginDirectionType.Bottom;
        break;

      case AnchorDirectionType.Start:
        anchorDirection = OriginDirectionType.Top;
        break;

      default:
        break;
    }
  }

  return `${originDirection} ${anchorDirection}`;
};
export const getAnchorDirection = (anchorDirection, originDirection, anchorPosition, contentPosition) => {
  const {
    left: anchorLeft,
    top: anchorTop,
    width: anchorWidth,
    offsetWidth: anchorOffsetWidth,
    offsetHeight: anchorOffsetHeight
  } = anchorPosition;
  const {
    offsetHeight: contentOffsetHeight,
    offsetWidth: contentOffsetWidth
  } = contentPosition;
  let direction = anchorDirection;
  const isVertical = originDirection === OriginDirectionType.Left || originDirection === OriginDirectionType.Right;
  let position = {};
  const inRightViewPort = anchorLeft + contentOffsetWidth <= getWindowWidth();
  const inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) >= 0;

  if (!inLeftViewPort && inRightViewPort) {
    direction = AnchorDirectionType.Start;
  }

  if (inLeftViewPort && !inRightViewPort) {
    direction = AnchorDirectionType.End;
  }

  if (!inLeftViewPort && !inRightViewPort) {
    direction = AnchorDirectionType.Center;
  }

  switch (direction) {
    case AnchorDirectionType.Center:
      position = {
        left: anchorLeft + anchorOffsetWidth / 2 - contentOffsetWidth / 2
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight / 2 + window.scrollY - contentOffsetHeight / 2
        };
      }

      break;

    case AnchorDirectionType.End:
      position = {
        left: anchorLeft - (contentOffsetWidth - anchorWidth)
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight - contentOffsetHeight + window.scrollY
        };
      }

      break;

    case AnchorDirectionType.Start:
      position = {
        left: anchorLeft
      };

      if (isVertical) {
        position = {
          top: anchorTop + window.scrollY
        };
      }

      break;

    default:
      break;
  }

  return {
    anchorDirection: direction,
    position
  };
};
export const getOriginDirection = (originDirection, anchorPosition, contentPosition, offset = 0) => {
  const {
    top: anchorTop,
    left: anchorLeft,
    offsetHeight: anchorOffsetHeight,
    offsetWidth: anchorOffsetWidth
  } = anchorPosition;
  const {
    offsetHeight: contentOffsetHeight,
    offsetWidth: contentOffsetWidth
  } = contentPosition;
  let direction = originDirection;
  let position = {};
  const inRightViewPort = offset + anchorLeft + anchorOffsetWidth + contentOffsetWidth < getWindowWidth();
  const inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) > offset;
  const inTopViewPort = anchorTop - contentOffsetHeight > offset;
  const inBottomViewPort = isInYViewPort(offset + anchorTop + window.scrollY + contentOffsetHeight);

  if (direction === OriginDirectionType.Top && !inTopViewPort) {
    direction = OriginDirectionType.Bottom;
  } else if (direction === OriginDirectionType.Bottom && !inBottomViewPort) {
    direction = OriginDirectionType.Top;
  }

  if (direction === OriginDirectionType.Left && !inLeftViewPort) {
    direction = OriginDirectionType.Right;
  } else if (direction === OriginDirectionType.Right && !inRightViewPort) {
    direction = OriginDirectionType.Left;
  }

  switch (direction) {
    case OriginDirectionType.Left:
      position = {
        left: anchorLeft - contentOffsetWidth - offset
      };
      break;

    case OriginDirectionType.Right:
      position = {
        left: anchorLeft + anchorOffsetWidth + offset
      };
      break;

    case OriginDirectionType.Top:
      position = {
        top: anchorTop - contentOffsetHeight + window.scrollY - offset
      };
      break;

    case OriginDirectionType.Bottom:
      position = {
        top: anchorTop + anchorOffsetHeight + window.scrollY + offset
      };
      break;

    default:
      break;
  }

  return {
    position,
    originDirection: direction
  };
};
const Popper = React.forwardRef(function PortalAutoPosition(_ref, ref) {
  let {
    anchor,
    anchorDirection = AnchorDirectionType.Start,
    backdrop,
    children,
    transition = 'no-transition',
    trigger,
    offset = 0,
    originDirection = OriginDirectionType.Top,
    width = undefined,
    fitAnchor = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["anchor", "anchorDirection", "backdrop", "children", "transition", "trigger", "offset", "originDirection", "width", "fitAnchor"]);

  const classes = useStyles();
  const contentRef = useRef(null);
  const controlRef = useRef();
  const [position, setPosition] = useState({});
  const getContentPositionStyles = useCallback(() => {
    const contentEl = contentRef.current;
    const anchorEl = anchor.current;
    const {
      offsetHeight,
      offsetWidth
    } = anchorEl || {};
    const {
      left,
      width: anchorWidth,
      top
    } = anchorEl.getBoundingClientRect();
    const {
      width: contentWidth,
      offsetWidth: contentOffsetWidth,
      offsetHeight: contentOffsetHeight
    } = contentEl;
    const {
      position: originPosition,
      originDirection: calculatedOriginDirection
    } = getOriginDirection(originDirection, {
      top,
      left,
      offsetWidth,
      offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    }, offset);
    const {
      position: anchorLeftPosition,
      anchorDirection: calculatedAnchorDirection
    } = getAnchorDirection(anchorDirection, calculatedOriginDirection, {
      left,
      width: anchorWidth,
      offsetWidth,
      top,
      offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    });
    const transformOrigin = getTransformDirection(calculatedOriginDirection, calculatedAnchorDirection);
    controlRef.current = {
      contentOffsetHeight,
      anchorOffsetHeight: offsetHeight
    };
    return _extends({}, anchorLeftPosition, {}, originPosition, {
      transformOrigin,
      width: width || getPortalWidth(fitAnchor, contentOffsetWidth, anchorWidth)
    });
  }, [contentRef, anchor, anchorDirection, originDirection, offset, fitAnchor]);
  useEffect(() => {
    if (!trigger) {
      return undefined;
    }

    if (anchor?.current && contentRef?.current) {
      setPosition(getContentPositionStyles());
    }
  }, [trigger]);
  useEffect(() => {
    if (!trigger || !contentRef?.current) {
      return undefined;
    }

    const {
      offsetHeight: currentContentOffsetHeight
    } = contentRef.current;
    const {
      offsetHeight: currentAnchorOffsetHeight
    } = anchor.current;
    const {
      contentOffsetHeight,
      anchorOffsetHeight
    } = controlRef.current;

    if (currentContentOffsetHeight !== contentOffsetHeight || currentAnchorOffsetHeight !== anchorOffsetHeight) {
      setPosition(getContentPositionStyles());
    }
  }, [children, anchor]);
  React.useEffect(() => {
    const handleResize = debounce(() => {
      if (anchor?.current && contentRef?.current) {
        setPosition(getContentPositionStyles());
      }
    }, 250);
    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  return /*#__PURE__*/React.createElement(Portal, {
    ref: ref
  }, trigger && backdrop && /*#__PURE__*/React.createElement("div", {
    className: classes.backdrop
  }), /*#__PURE__*/React.createElement(CSSTransition, _extends({}, props, {
    unmountOnExit: true,
    animation: transition,
    show: trigger,
    style: _extends({}, position)
  }), /*#__PURE__*/React.createElement("span", {
    className: classes.innerContent,
    ref: contentRef
  }, children)));
});
Popper.propTypes = {
  /** Anchor element to append to */
  anchor: PropTypes.oneOfType([PropTypes.node, PropTypes.func, PropTypes.shape()]),

  /** Animation for css transition  - defaults to none */
  transition: PropTypes.oneOfType([PropTypes.shape({
    appear: PropTypes.string,
    appearActive: PropTypes.string,
    enter: PropTypes.string.isRequired,
    enterActive: PropTypes.string.isRequired,
    enterDone: PropTypes.string,
    exitActive: PropTypes.string.isRequired,
    exit: PropTypes.string.isRequired,
    exitDone: PropTypes.string
  }), PropTypes.string]),

  /** Child node for the auto position to reference and wrap */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.arrayOf(PropTypes.node)]).isRequired,

  /** Indicator when to re calculate the position */
  trigger: PropTypes.bool,

  /** Additional class to root level */
  className: PropTypes.string,

  /** Additional style to root level */
  style: PropTypes.shape(),

  /** Direction to open the content relative to anchor (center, end ,start) */
  anchorDirection: PropTypes.oneOf([AnchorDirectionType.Center, AnchorDirectionType.Start, AnchorDirectionType.End]),

  /** Direction to open the content relative to origin (Top bottom left right) */
  originDirection: PropTypes.oneOf([OriginDirectionType.Top, OriginDirectionType.Bottom, OriginDirectionType.Left, OriginDirectionType.Right]),

  /** Allow backdrop when showing portal */
  backdrop: PropTypes.bool,

  /** offset to locate the content from anchor */
  offset: PropTypes.number,

  /** Boolean flag to fix content width with anchor width - by default fits content width */
  fitAnchor: PropTypes.bool,

  /** Set content width manually - by default it will resolve to the larger of the input width or the content width */
  width: PropTypes.number
};
Popper.displayName = 'Popper';
export default Popper;