import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
import queryParser from 'querystring';
import isEmpty from 'lodash/isEmpty';
import isString from 'lodash/isString';
import { getHistory } from "../createHistory/createHistory";
import { postRouteChangeOutOfApp } from "../routerListener/routeListener";
const absWindow = window.parent;
/**
 * Parse string path into location object
 * @param path {String } path to parse
 * @return {{search: string, hash: string, pathname: (*|string)}}
 */

function parsePath(path) {
  let pathname = path || '/';
  let search = '';
  let hash = '';
  const hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  const searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
/**
 * Build the query params to be set on the url
 * @param params    {Object}  The payload object
 * @returns {string}    the formatted query params
 */


function _buildURLQueryParams(params) {
  return queryParser.stringify(params);
}
/**
 * Get the url query params
 * @returns {*}
 */


function getQueryParams() {
  const search = getHistory().location.search.replace('?', '');
  return queryParser.parse(search);
}
/**
 * Build search query params from params and preserve query
 * @param params
 * @param preserveQueryParams
 * @returns {string}
 */


function _buildSearchQueryParam(params = {}, preserveQueryParams = false) {
  let newSearch = '';
  const isParamsEmpty = isEmpty(params);
  const search = getHistory().location.search.replace('?', '');

  if (preserveQueryParams && isParamsEmpty) {
    newSearch = search;
  } else if (preserveQueryParams && !isParamsEmpty) {
    const newQuery = _extends({}, params, getQueryParams());

    newSearch = _buildURLQueryParams(newQuery);
  } else if (!preserveQueryParams && !isParamsEmpty) {
    newSearch = _buildURLQueryParams(params);
  }

  return !isEmpty(newSearch) ? `?${newSearch}` : newSearch;
}
/**
 * Return the url pathname
 * @param relative  { Boolean } Return the url without the baseUrl, defaults to true
 * @return {String}
 */


function getPathName(relative = true) {
  try {
    return relative ? absWindow.location.pathname.replace(getHistory().baseUrl, '') : absWindow.location.pathname;
  } catch (e) {
    return e;
  }
}
/**
 * Check if url has a specific parameter in it
 * @param param {String || Number}  The url parameter to check if exists
 * @return {Boolean}
 */


function hasInPath(param) {
  try {
    const path = getPathName(false) || '';
    const set = new Set(path.split('/'));
    return set.has(param);
  } catch (e) {
    return e;
  }
}
/**
 * Link to url
 * @param path  {String}  The full path for the link
 * @param isNewTab  {Boolean} Indicator whether or not to show in new tab ( auto - true)
 */


function link(path, isNewTab = true) {
  if (isNewTab) {
    absWindow.open(path, '_blank');
  } else if (getHistory().isFragment) {
    postRouteChangeOutOfApp(path);
  }
}
/**
 * Set query params into the url
 * @param params  {Object} the query param object to set
 * @param preservePrevious  {Boolean}  indicator whether or not to preserve the previous query params
 */


function setQueryParams(params, preservePrevious = false) {
  const search = _buildSearchQueryParam(params, preservePrevious);

  getHistory().push({
    search
  });
}
/**
 * Navigate to new container
 * @param pathname {String} The route to nav to
 * @param params {Object} The query params to pass as object
 * @param preserveQueryParams
 */


function go(pathname, params = {}, preserveQueryParams = false) {
  if (!isEmpty(pathname)) {
    let search;

    if (isString(params)) {
      search = params;
    } else {
      search = _buildSearchQueryParam(params, preserveQueryParams);
    }

    getHistory().push({
      pathname,
      search
    });
  }
}
/**
 * Replace the current history
 * @param pathname
 * @param search
 * @param rest
 */


function replace(_ref) {
  let {
    pathname,
    search
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["pathname", "search"]);

  const formattedSearch = isString(search) ? search : _buildSearchQueryParam(search);
  getHistory().replace(_extends({
    pathname,
    search: formattedSearch
  }, rest));
}
/**
 * Navigation function allowing user to push to history
 * @param payload   {String | Object}   String or object with the route
 * if object possible attributes are : { pathname - string : route to navigate to, search - object: query params to set to url  }
 * @param preserveQueryParams  { Boolean } Indicator whether or not to keep query params
 */


function push(payload, preserveQueryParams) {
  if (isString(payload)) {
    go(payload);
  } else {
    const {
      pathname,
      search
    } = payload;
    go(pathname, search, preserveQueryParams);
  }
}
/**
 * Return a string of the query params
 * @param params  {Object}  Query params object
 * @return {string}
 */


function stringifyQueryParams(params) {
  return _buildURLQueryParams(params);
}

function location() {
  return getHistory().location;
}

function createHref(href) {
  return getHistory().createHref(href);
}

function length() {
  return getHistory().length;
}

export default {
  listen: getHistory().listen,
  goBack: getHistory().goBack,
  goForward: getHistory().goForward,
  location,
  go,
  setQueryParams,
  getPathName,
  getQueryParams,
  link,
  hasInPath,
  replace,
  length,
  push,
  createHref,
  stringifyQueryParams,
  parsePath
};