const SplitFactory = require('@splitsoftware/splitio').SplitFactory;
const merge = require('lodash.merge');

class FeatureToggle {

  constructor() {
    this.defaultConfig = {
      startup: {
        requestTimeoutBeforeReady: 1.5, // 1500 ms
        retriesOnFailureBeforeReady: 3, // 3 times
        readyTimeout: 1.5,              // 1500 ms
      },
    };
  }

  async init(config = {}, accountId = 'annonymus') {
    const clientConfig = accountId !== 'annonymus' ? merge({ core: { key: accountId } }, this.defaultConfig, config) : merge(this.defaultConfig, config);  // {...config,...{core:{key:accountId}}}

    // Singleton pattern
    if (!FeatureToggle.instance) {
      const factory = SplitFactory(clientConfig);

      this._client = factory.client();

      FeatureToggle.instance = this;
    }

    FeatureToggle.instance._client.on('SDK_READY_TIMED_OUT', FeatureToggle._generateThrowSetupExeption('SDK_READY_TIMED_OUT'));
    await FeatureToggle._waitForEvent(FeatureToggle.instance._client, FeatureToggle.instance._client.Event.SDK_READY, clientConfig.startup.readyTimeout * 1000);

    return FeatureToggle.instance;
  }

  isEnabled(featureToggleName, accountId = 'annonymus', attributes = {}, defaultValue = false) {

    if (!('_client' in this)) FeatureToggle._generateThrowSetupExeption('Client did not init before first \'isEnabled\' usage', 'REQUIRE_FT_INIT')();

    try {
      const result = this._client.isBrowserClient ? this._client.getTreatment(featureToggleName, attributes) :
        this._client.getTreatment(accountId, featureToggleName, attributes);
      console.debug(`[featureToggle] ${featureToggleName} -> ${result}`);
      return FeatureToggle._boolifyOffOn(result, defaultValue);
    } catch (err) {
      const { stack } = err;
      console.error(`[featureToggle] Faile to get treatment value, err:${stack}`, { stack });
    }
    return defaultValue;
  }

  static _boolifyOffOn(treatment, defaultValue = false) {
    switch (treatment) {
      case 'on':
        return true;
      case 'off':
        return false;
      case 'control':
        return defaultValue;
      default:
        return treatment;
    }
  }

  static _waitForEvent(eventEmitter, eventType, setTimeOut = 0) {
    return Promise.race([
      new Promise((resolve) => eventEmitter.on(eventType, resolve)),
      new Promise((resolve, reject) => setTimeout(() => reject(new Error('eventTimeOut')), setTimeOut)),
    ]).catch(FeatureToggle._generateThrowSetupExeption(`Timeout while waiting to event:${eventType}, setTimeout:${setTimeOut}`),`${eventType}_TIME_OUT`);
  }

  static _generateThrowSetupExeption(reason, errCode) {
    return () => {
      const err = new Error(`[featureToggle] Fail to start feaetureToggle instance, reason:${reason}`);
      err.code = errCode || reason;
      throw err;
    };
  }
}

module.exports = new FeatureToggle();

