import _extends from "@babel/runtime/helpers/esm/extends";
import React, { useCallback, useMemo, Suspense, useRef } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import noop from 'lodash/noop';
import useTranslations from '@guestyci/localize/useTranslations';
import { isEmpty } from "../../utils";
import EmptyState from "../EmptyState";

var Rug = function Rug(props) {
  return /*#__PURE__*/React.createElement("svg", props, /*#__PURE__*/React.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/React.createElement("path", {
    d: "M.062 89.255h6M0 81.87h6m-6-7.386h6m-6-7.387h6m-6-7.386h6m-6-7.386h6M0 44.94h6m-6-7.386h6m-6-7.386h6m-6-7.386h6m-6-7.385h6M0 8.01h6M0 .625h6M128 44.94h6m-6-7.386h6m-6-7.386h6m-6-7.386h6m-6-7.385h6m-6-7.387h6m-6-7.385h6",
    stroke: "#AEB6BA"
  }), /*#__PURE__*/React.createElement("path", {
    fill: "#FF5F5F",
    d: "M5.197.063v89.775h67.272l.57-1.209 54.11-41.435h1.489V.064z"
  }), /*#__PURE__*/React.createElement("path", {
    fill: "#30ABE5",
    d: "M117.192 9.265v44.888L84.705 78.84H16.194V9.265z"
  }), /*#__PURE__*/React.createElement("g", {
    fill: "#48BDF3"
  }, /*#__PURE__*/React.createElement("path", {
    d: "M40.391 65.912l7.07 7.07 7.072-7.07-7.072-7.07zm14.106-.142l7.071 7.071 7.072-7.07-7.072-7.07zM27.462 78.841h11.54l-5.77-5.77zm13.965 0H53.25l-5.91-5.91zM68.764 37.54l7.07 7.07 7.073-7.07-7.072-7.072zm14.106-.141l7.072 7.07 7.07-7.07-7.07-7.071z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M54.533 51.77l7.071 7.07 7.072-7.07-7.072-7.071zm14.107-.14l7.07 7.07 7.072-7.07-7.071-7.072zM55.393 78.841h12.07l-6.035-6.035zm13.966 0h12.35l-6.174-6.176zM82.73 51.505l7.07 7.07 7.072-7.07-7.072-7.07z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M68.5 65.735l7.07 7.07 7.071-7.07-7.072-7.07zm28.735-56.47l6.973 6.973 6.973-6.973zM82.906 23.396l7.07 7.072 7.073-7.072-7.073-7.07zm14.106-.14l7.071 7.071 7.072-7.07-7.072-7.072zm14.09-.124l6.09 6.09v-12.18zm-14.23 14.231l7.07 7.07 7.073-7.07-7.072-7.071zm14.106-.141l6.214 6.214V31.007zM16.194 20.109v7.358l3.392 3.393 7.071-7.072-7.071-7.071z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M16.194 9.265v4.166l3.428 3.428 7.071-7.071-.522-.523zm10.845 0l-.382.382 7.072 7.07 7.07-7.07-.381-.382zm-10.845 24.81v7.64l3.251 3.25 7.071-7.07-7.071-7.072zm10.286 3.679l7.071 7.07 7.072-7.07-7.072-7.07zM16.194 48.04v7.888l3.128 3.127 7.07-7.071-7.07-7.07zm24.81-38.775l-.257.257 7.07 7.07 7.071-7.07-.257-.257zm13.965 0l-.116.116 7.07 7.07 7.073-7.07-.117-.116z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M26.516 23.752l7.071 7.071 7.072-7.071-7.072-7.07zm14.107-.14l7.07 7.07 7.073-7.07-7.072-7.071zM26.428 51.948l7.07 7.071 7.073-7.07-7.072-7.072zm14.106-.14l7.07 7.07 7.073-7.07-7.072-7.071zm-24.34 10.374v7.993l3.074 3.075 7.072-7.07-7.072-7.073zm10.11 3.856l7.07 7.072 7.072-7.072-7.071-7.07zm-10.11 10.11v2.693h8.305L19 73.342zM54.8 23.576l7.071 7.07 7.072-7.07-7.072-7.07zm14.106-.142l7.071 7.071 7.072-7.07-7.072-7.07z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M40.57 37.805l7.07 7.071 7.072-7.07-7.072-7.07zm14.106-.14l7.071 7.071 7.072-7.07-7.072-7.072zm14.436-28.4l-.169.169 7.071 7.07 7.071-7.07-.169-.17zm13.966 0l-.03.029 7.072 7.07 7.07-7.07-.028-.03z"
  })), /*#__PURE__*/React.createElement("path", {
    fill: "#0073AD",
    fillOpacity: ".5",
    d: "M73.324 87.421L127.5 47.793 85 32.633z"
  }), /*#__PURE__*/React.createElement("path", {
    fill: "#E3E8EB",
    d: "M72.584 89.838l56.11-42.644-40.797-11.24z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M90.079 30.328l-1.604 5.782m8.737-3.869l-1.603 5.782m8.721-3.808l-1.604 5.782m8.722-3.807l-1.604 5.78m8.721-3.807l-1.604 5.782m8.721-3.808l-1.604 5.781",
    stroke: "#E3E8EB"
  })));
};

Rug.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "134",
  height: "90",
  viewBox: "0 0 134 90"
};
import useHorizontalScrollState from "./useHorizontalScrollState";
import { getOrderedColumnsById, getTableCells } from "./tableUtility";
import HeaderRow from "./HeaderRow";
import CellRow from "./CellRow";
import useInfiniteScroll from "../../useInfiniteScroll";
import LoadingIndicator from "./LoadingIndicator";
import createStyles from "../../createStyles";
export const useStyles = createStyles(theme => ({
  root: {
    position: 'relative',
    overflowY: 'hidden'
  },
  table: {
    display: 'table',
    tableLayout: 'fixed',
    width: '100%',
    borderCollapse: 'separate',
    '& .cell-group-left': {
      '&.cell-group-item-last': {
        boxShadow: `2px 0 3px 0 ${theme.palette.border}`
      },
      '&.cell-group-item-no-padding': {
        '& .cell-content, .header-cell-content': {
          paddingLeft: '0px !important'
        }
      }
    },
    '& .cell-group-right.cell-group-item-first': {
      boxShadow: `-2px 0 3px 0 ${theme.palette.border}`
    },
    '& .fixed-cell-group': {
      position: 'sticky'
    }
  },
  wrapper: {
    overflow: 'auto',
    height: ({
      height
    }) => height || '100%',
    '&.start-shadow:before': {
      content: '""',
      position: 'absolute',
      top: 50,
      bottom: 0,
      left: 0,
      transform: 'scale(1)',
      width: '10px',
      zIndex: 1,
      background: 'radial-gradient(ellipse at left, rgba(0, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0) 75%) 0 center'
    },
    '&.end-shadow:after': {
      content: '""',
      position: 'absolute',
      top: 50,
      transform: 'scale(1)',
      bottom: 0,
      right: 0,
      width: '10px',
      zIndex: 1,
      background: 'radial-gradient(ellipse at right, rgba(0, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0) 75%) 100% center'
    }
  },
  emptyState: {
    margin: 'auto',
    height: 'calc(100% - 60px)'
  },
  errorBanner: {
    bottom: 0,
    width: '100%',
    zIndex: 5,
    position: 'absolute'
  }
}), {
  name: 'Table'
});

const areCellsEqual = (columns = [], cells = []) => {
  const headerCellsMeta = cells[1];

  if (columns.length !== headerCellsMeta.length) {
    return false;
  }

  for (let i = 0; i < columns.length; i += 1) {
    const columnDataKey = columns[i]?.props?.dataKey;
    const cellDataKey = headerCellsMeta[i]?.props?.dataKey;

    if (columnDataKey !== cellDataKey) {
      return false;
    }
  }

  return true;
};

const Table = React.forwardRef(function Table({
  height,
  data,
  children,
  className,
  style,
  onRowClick,
  rowClassName,
  rowIdDataKey,
  onColumnOrderChange,
  draggableColumns,
  sortBy,
  onSort,
  multiselect,
  rowSelection,
  onCheckedRowsChange,
  onColumnResize,
  rowComponent,
  infiniteScrollOptions,
  isLoading,
  errorBanner,
  pageSize,
  jss,
  hasScrollShadow
}, ref) {
  const classes = useStyles({
    height,
    jss
  });
  const cachedCells = useRef(null);
  const [emptyStateTitle] = useTranslations(['smartviews_v3:table.table.empty_state_title', 'We searched everywhere']);
  const [emptyStateDescription] = useTranslations(['smartviews_v3:table.table.empty_state_description', 'And couldnâ€™t find anything. Try again?']);
  const scrollableRef = useInfiniteScroll(_extends({}, infiniteScrollOptions, {
    isLoading,
    pageSize
  }));
  const {
    allSelected: isMasterChecked,
    items: selectedRows,
    exceptItems: unselectedRows
  } = rowSelection;
  const handleSelectRowChange = useCallback(rowId => {
    onCheckedRowsChange({
      rowId
    });
  }, [onCheckedRowsChange]);
  const handleMasterCheckboxChange = useCallback(() => {
    onCheckedRowsChange({
      selectAll: true
    });
  }, [onCheckedRowsChange]);
  const handleColumnResize = useCallback((...args) => {
    cachedCells.current = null;
    onColumnResize(...args);
  }, [onColumnResize]);
  const handleColumnReorderChange = useCallback(({
    sourceData,
    targetData
  }) => {
    cachedCells.current = null;
    const columns = [...children];

    if (sourceData !== targetData) {
      const orderedColumns = getOrderedColumnsById(columns, sourceData, targetData);
      onColumnOrderChange(orderedColumns);
    }
  }, [onColumnOrderChange, children]);
  const handleHeaderSort = useCallback(args => {
    if (scrollableRef.current) {
      scrollableRef.current.scrollTop = 0;
    }

    onSort(args);
  }, [onSort]);
  const [headerCells, bodyCells] = useMemo(() => {
    const {
      current
    } = cachedCells;

    if (current && areCellsEqual(children, current)) {
      return current;
    }

    cachedCells.current = getTableCells(children, multiselect);
    return cachedCells.current;
  }, [children, multiselect]);
  const CellRowComponent = rowComponent || CellRow;
  const showEmptyState = data?.length === 0 && !isLoading;
  const totalCount = infiniteScrollOptions?.totalCount || data?.length || 0;
  const isMasterIndeterminate = Boolean(isMasterChecked ? unselectedRows.size && unselectedRows.size !== totalCount : selectedRows.size && selectedRows.size !== totalCount);
  const hasStickyColumns = headerCells?.some(headerCell => headerCell.props.fixed) || false;
  const canRenderScrollShadows = !hasStickyColumns && hasScrollShadow;
  const [showStart, showEnd, onScrollUpdateShadow] = useHorizontalScrollState([canRenderScrollShadows, scrollableRef]);
  return /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement("div", {
    className: cn(classes.wrapper, {
      'start-shadow': showStart,
      'end-shadow': showEnd
    }),
    ref: scrollableRef,
    onScroll: onScrollUpdateShadow
  }, /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: cn(classes.table, className),
    style: style
  }, /*#__PURE__*/React.createElement(HeaderRow, {
    sortBy: sortBy,
    onSort: handleHeaderSort,
    draggable: draggableColumns,
    onDragDrop: handleColumnReorderChange,
    multiSelect: multiselect,
    masterCheckbox: {
      checked: isMasterChecked,
      indeterminate: isMasterIndeterminate,
      onChange: handleMasterCheckboxChange
    },
    onResize: handleColumnResize
  }, headerCells), /*#__PURE__*/React.createElement(Suspense, {
    fallback: null
  }, data?.map(row => {
    const id = row[rowIdDataKey];
    return /*#__PURE__*/React.createElement(CellRowComponent, {
      multiSelect: multiselect,
      onCheckboxChange: handleSelectRowChange,
      checked: selectedRows.has(id),
      onClick: onRowClick,
      className: rowClassName,
      data: row,
      rowId: id.toString(),
      key: id
    }, bodyCells);
  }), /*#__PURE__*/React.createElement(LoadingIndicator, {
    show: isLoading,
    isTableEmpty: isEmpty(data),
    pageSize: pageSize,
    multiSelect: multiselect,
    checked: isMasterChecked,
    className: rowClassName,
    cellComponents: bodyCells
  }))), showEmptyState && /*#__PURE__*/React.createElement(EmptyState, {
    className: classes.emptyState,
    svg: Rug,
    iconHeight: 90,
    iconWidth: 134,
    title: emptyStateTitle,
    description: emptyStateDescription
  })), errorBanner && /*#__PURE__*/React.createElement("div", {
    className: classes.errorBanner
  }, errorBanner));
});
Table.defaultProps = {
  className: '',
  style: {},
  data: undefined,
  onRowClick: noop,
  rowClassName: '',
  height: undefined,
  multiselect: false,
  onCheckedRowsChange: noop,
  rowSelection: {
    allSelected: false,
    items: new Set()
  },
  rowIdDataKey: '_id',
  draggableColumns: false,
  onColumnOrderChange: noop,
  onColumnResize: noop,
  sortBy: undefined,
  onSort: undefined,
  rowComponent: null,
  isLoading: false,
  pageSize: 25,
  errorBanner: null,
  infiniteScrollOptions: {
    skip: 0,
    onLoadMore: noop,
    scrollOffset: 200
  },
  hasScrollShadow: true
};
Table.propTypes = {
  /** Data array to pass to the table - expects an array of object. Notice, undefined data is not considered in an empty state */
  data: PropTypes.arrayOf(PropTypes.object),

  /** Column data to pass to the table - expects an array of Columns */
  children: PropTypes.arrayOf(PropTypes.node).isRequired,

  /** Optional class name to the table level */
  className: PropTypes.string,

  /** Optional styles to table level */
  style: PropTypes.shape(),

  /** Row click Callback  => ({data: {Object} row data + rowId}) */
  onRowClick: PropTypes.func,

  /** Optional className to pass to cell rows */
  rowClassName: PropTypes.string,

  /** Height for the entire table */
  height: PropTypes.number,

  /** Row id data source to set from data object as unique identifier for each row */
  rowIdDataKey: PropTypes.string,

  /** Boolean indicator for allowing bulk actions */
  multiselect: PropTypes.bool,

  /** Returns selection "action" with either { rowId } or { selectAll } */
  onCheckedRowsChange: PropTypes.func,

  /** Config that describes selection in the table */
  rowSelection: PropTypes.shape({
    /** Marks table as everything should be selected, even not yet loaded data */
    allSelected: PropTypes.bool,

    /** List of selected items  */
    items: PropTypes.oneOfType([PropTypes.shape(), PropTypes.array])
  }),

  /** Boolean indicator for reordering columns */
  draggableColumns: PropTypes.bool,

  /** CB function for draggable drop event => ({ columns: {Array} Array of columns id by order }) */
  onColumnOrderChange: PropTypes.func,

  /** String indicator for the sorted column. '-' prefix defines descending order */
  sortBy: PropTypes.string,

  /** Callback function to handle sorting by a column */
  onSort: PropTypes.func,

  /** Custom Cell row component to be rendered */
  rowComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /** callback function for resize column width => ({ payload: {object} returns {[columnId: resizedWidth]} }) */
  onColumnResize: PropTypes.func,

  /** indicator for data fetching state */
  isLoading: PropTypes.bool,

  /** number of rows per page */
  pageSize: PropTypes.number,

  /** Object to define infinite scrolling behaviour */
  infiniteScrollOptions: PropTypes.shape({
    /** starting index of the chunk */
    skip: PropTypes.number,

    /** cb to notify about required loads */
    onLoadMore: PropTypes.func,

    /** total number of entries */
    totalCount: PropTypes.number,

    /** offset from the bottom, from which loading the next chunk should be triggered */
    scrollOffset: PropTypes.number
  }),

  /** Node error component */
  errorBanner: PropTypes.node,

  /** jss override object to customize the jss classes */
  jss: PropTypes.oneOfType([PropTypes.shape(), PropTypes.func]),

  /** Adds shadow indicators at the sides of the table when it is overflowed horizontally, disabled by default with fixed columns */
  hasScrollShadow: PropTypes.bool
};
Table.displayName = 'Table';
export default Table;