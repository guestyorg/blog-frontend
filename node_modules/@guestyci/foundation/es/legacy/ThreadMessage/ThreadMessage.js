import React, { Component } from 'react';
import cn from 'classnames';
import PropTypes from 'prop-types';
import get from 'lodash/get';
import size from 'lodash/size';
import ThreadMessageIcon from "./ThreadMessageIcon";
import MessageBody from "./ThreadMessageBody";
import ThreadMessageErrInfo from "./ThreadMessageError";
import ThreadMessageInfo from "./ThreadMessageInfo";
const fileTypes = ['Png', 'Pdf', 'Xls', 'Gif', 'Doc', 'Jpg', 'Mp4'];

class ThreadMessage extends Component {
  constructor(props) {
    super(props);

    this.getThumbnail = sentBy => {
      const {
        isAutomatic,
        from,
        module,
        guest
      } = this.props;
      if (isAutomatic) return 'BtnAutomsg';
      if (sentBy === 'guest') return get(guest, 'picture.thumbnail');
      if (sentBy === 'host' || get(module, 'type') === 'note') return get(from, 'picture.thumbnail');
      if (sentBy === 'guesty') return 'gseIcon';
      if (get(module, 'action')) return 'airBnbIcon';
      return null;
    };

    this.getBgColor = (sentBy, module) => {
      if (module.type === 'note') return 'yellow-light';
      return 'gray-lightest';
    };

    this.getModuleType = module => {
      const moduleDisplayType = get(module, 'displayType');
      return moduleDisplayType || get(module, 'type');
    };

    this.getFullName = sentBy => {
      const {
        from,
        isAutomatic,
        module,
        guest
      } = this.props;
      if (sentBy === 'guest') return get(guest, 'fullName');
      if (sentBy === 'guesty') return 'Guestyâ€™s communication service';
      if (sentBy === 'channel') return 'Airbnb';
      if (sentBy === 'host' && !isAutomatic) return get(from, 'fullName');
      if (!sentBy && get(module, 'action')) return 'airbnb';
      if (isAutomatic) return 'Automated message';
      return get(from, 'fullName') || 'Not Available';
    };

    this.getIconType = item => {
      if (!item) return 'Jpg';
      const itemType = item.split('.')[1];
      return fileTypes.indexOf(itemType) > -1 ? itemType : 'Jpg';
    };

    this.prepareAttachments = attachments => {
      if (!size(attachments)) return [];
      return attachments.map(item => ({
        url: item.attachmentUrl,
        name: item.origFileName || item.contentName || 'unnamed file',
        icon: this.getIconType(item.origFileName),
        contentName: item.contentName,
        isLoading: item.isLoading
      }));
    };

    this.isByUs = () => {
      const {
        sentBy,
        module
      } = this.props;
      return sentBy !== 'guest' && sentBy !== 'third party' && !get(module, 'action');
    };

    this.retrySendMessage = () => {
      const {
        id,
        onRetry
      } = this.props;
      onRetry(id);
    };

    this.deleteMessage = () => {
      const {
        id,
        onDelete
      } = this.props;
      onDelete(id);
    };

    this.state = {
      bgColor: this.getBgColor(props.sentBy, props.module),
      byGuest: props.sentBy === 'guest',
      byGSE: props.sentBy === 'guesty',
      byChannel: (!props.sentBy || props.sentBy === 'channel') && !!get(props.module, 'action'),
      thumbnail: this.getThumbnail(props.sentBy),
      byUs: this.isByUs(),
      fullName: this.getFullName(props.sentBy),
      moduleType: this.getModuleType(props.module)
    };
  }

  componentDidUpdate(prevProps) {
    const {
      id,
      guest
    } = this.props;
    const dataUpdated = prevProps.guest._id !== guest._id || prevProps.id !== id;

    if (dataUpdated) {
      this.init();
    }
  }

  init() {
    const {
      sentBy,
      module
    } = this.props;
    this.setState({
      bgColor: this.getBgColor(sentBy, module),
      byGuest: sentBy === 'guest',
      byGSE: sentBy === 'guesty',
      byChannel: (!sentBy || sentBy === 'channel') && !!get(module, 'action'),
      thumbnail: this.getThumbnail(sentBy),
      byUs: this.isByUs(),
      fullName: this.getFullName(sentBy),
      moduleType: this.getModuleType(module)
    });
  }

  render() {
    const {
      bgColor,
      byGuest,
      byGSE,
      byChannel,
      thumbnail,
      byUs,
      fullName,
      moduleType
    } = this.state;
    const {
      attachments,
      isAutomatic,
      className,
      body,
      error,
      deleteTxt,
      retryTxt,
      reasonTxt,
      sentAt,
      createdAt,
      onAttachmentClick
    } = this.props;
    return /*#__PURE__*/React.createElement("div", {
      className: cn('threadMessageBubble d-flex', {
        'flex-row-reverse by-us': byUs
      }, className),
      "data-qa": "thread-message"
    }, /*#__PURE__*/React.createElement(ThreadMessageIcon, {
      avatarName: fullName,
      isAutoMessage: isAutomatic,
      thumbnail: thumbnail,
      byChannel: byChannel,
      byUs: byUs,
      byGSE: byGSE,
      byGuest: byGuest
    }), /*#__PURE__*/React.createElement("div", {
      className: "d-flex flex-column flex-1"
    }, /*#__PURE__*/React.createElement(MessageBody, {
      errorMessage: error,
      body: body,
      attachments: this.prepareAttachments(attachments),
      isAutoMessage: isAutomatic,
      byUs: byUs,
      bgColor: bgColor,
      onAttachmentClick: onAttachmentClick
    }), error ? /*#__PURE__*/React.createElement(ThreadMessageErrInfo, {
      messageReason: reasonTxt,
      tooltip: /*#__PURE__*/React.createElement(ThreadMessageInfo, {
        fullName: fullName,
        sentAt: sentAt,
        createdAt: createdAt,
        byUs: byUs,
        moduleType: moduleType,
        fromErrorInfo: true
      }),
      retrySendMessage: this.retrySendMessage,
      onDelete: this.deleteMessage,
      retryTxt: retryTxt,
      deleteTxt: deleteTxt
    }) : /*#__PURE__*/React.createElement(ThreadMessageInfo, {
      fullName: fullName,
      sentAt: sentAt,
      createdAt: createdAt,
      byUs: byUs,
      moduleType: moduleType
    })));
  }

}

ThreadMessage.defaultProps = {
  attachments: null,
  isAutomatic: false,
  guest: {}
};
ThreadMessage.propTypes = {
  /** The message body, can be a string or an html node. */
  body: PropTypes.node.isRequired,

  /** Array of objects that contain the imgs */
  attachments: PropTypes.arrayOf(PropTypes.shape()),

  /** Bool, flag for automatic messages */
  isAutomatic: PropTypes.bool,

  /** String, name if the module which the message sent  */
  module: PropTypes.shape().isRequired,

  /** Object, metadata about the message sender. */
  from: PropTypes.shape().isRequired,

  /** String, by who message was sent */
  sentBy: PropTypes.string.isRequired,

  /** String, time that message was sent */
  sentAt: PropTypes.string.isRequired,

  /** String, item id */
  id: PropTypes.string.isRequired,

  /** object, item id */
  guest: PropTypes.shape(),

  /** Bool, if the message is with error */
  error: PropTypes.bool.isRequired,

  /** function, retry send the specific message */
  onRetry: PropTypes.func.isRequired,

  /** function, delete the unsent message */
  onDelete: PropTypes.func.isRequired,

  /** string, txt for delete btn */
  deleteTxt: PropTypes.string.isRequired,

  /** string, txt for retry btn */
  retryTxt: PropTypes.string.isRequired,

  /** String, err reason */
  reasonTxt: PropTypes.string.isRequired,

  /** Open attachment event */
  onAttachmentClick: PropTypes.func
};
export default ThreadMessage;