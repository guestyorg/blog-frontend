import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import React from 'react';
import { isEmpty } from "../../utils";
import cn from 'classnames';
const MULTI_SELECT_OFFSET = 36;
export const getColumnCells = (cells = [], props = {}) => {
  const {
    dataKey,
    resizable
  } = props,
        commonProps = _objectWithoutPropertiesLoose(props, ["dataKey", "resizable"]);

  if (!Array.isArray(cells) || cells.length < 2) {
    throw new Error(`Components <HeaderCell> and <Cell> are required, column: ${dataKey}`);
  }

  return {
    header: React.cloneElement(cells[0], _extends({
      id: dataKey,
      resizable
    }, commonProps)),
    cell: React.cloneElement(cells[1], _extends({
      dataKey
    }, commonProps))
  };
};
export const getFixedColClassName = (fixedDirection, index, length, isMultiSelect) => {
  let className = `fixed-cell-group cell-group cell-group-${fixedDirection}`;

  if (index === 0) {
    className = `${className} cell-group-item-first ${isMultiSelect ? 'cell-group-item-no-padding' : ''}`;
  }

  if (index === length) {
    className = `${className} cell-group-item-last`;
  }

  return className;
};
export const buildCellGroups = columns => columns.reduce(([left, center, right], col) => {
  const {
    fixed
  } = col?.props;

  if (fixed === 'left') {
    left.push(col);
  } else if (fixed === 'right') {
    right.push(col);
  } else {
    center.push(col);
  }

  return [left, center, right];
}, [[], [], []]);
export const serializeColumns = (cols, isMultiSelect) => {
  const [leftColumns, centerColumns, rightColumns] = buildCellGroups(cols);

  if (!isEmpty(leftColumns)) {
    const columns = [...leftColumns];
    let offset = isMultiSelect ? MULTI_SELECT_OFFSET : 0;
    columns.forEach((col, index) => {
      const {
        width,
        fixed,
        className
      } = col.props;
      const column = React.cloneElement(col, {
        className: cn(className, getFixedColClassName(fixed, index, leftColumns.length - 1, isMultiSelect)),
        positionLeft: offset
      });
      offset += width;
      leftColumns[index] = column;
    });
  }

  if (!isEmpty(rightColumns)) {
    let offset = 0;
    const columns = [...rightColumns].reverse();
    const length = rightColumns.length - 1;
    columns.forEach((col, index) => {
      const {
        width,
        fixed
      } = col.props;
      const column = React.cloneElement(col, {
        className: getFixedColClassName(fixed, length - index, leftColumns.length),
        positionRight: offset
      });
      offset += width;
      rightColumns[length - index] = column;
    });
  }

  return [...leftColumns, ...centerColumns, ...rightColumns];
};
/**
 *  Get the teable cells to render to the table
 * @param columns { Array } Array of nodes
 * @param multiselect { Boolean }  boolean indicator for multi select
 * @return {Array}
 */

export const getTableCells = (columns, multiselect) => {
  const serializedColumns = serializeColumns(columns, multiselect);
  return serializedColumns.reduce(([headerCells, bodyCells], column) => {
    const _column$props = column?.props,
          {
      children: columnChildren
    } = _column$props,
          rest = _objectWithoutPropertiesLoose(_column$props, ["children"]);

    const {
      header,
      cell
    } = getColumnCells(columnChildren, rest);
    headerCells.push(header);
    bodyCells.push(cell);
    return [headerCells, bodyCells];
  }, [[], []]);
};
/**
 * Build an ordered array of columns
 * @param columns {Array} Array of nodes
 * @param source {String} drag source id
 * @param target {String} drag target id
 * @return {Array} - string array of columns id
 */

export const getOrderedColumnsById = (columns, source, target) => {
  const sourceColumn = columns.find(child => child?.props?.dataKey === source);
  let sourceIndex = -1;
  const orderedColumns = columns.reduce((cols, column, index) => {
    const {
      dataKey
    } = column.props;

    if (dataKey === source) {
      sourceIndex = index;
      return cols;
    }

    if (dataKey === target) {
      if (sourceIndex === -1) {
        cols.push(sourceColumn);
        cols.push(column);
      } else {
        cols.push(column);
        cols.push(sourceColumn);
      }
    } else {
      cols.push(column);
    }

    return cols;
  }, []);
  return orderedColumns.map(col => col?.props?.dataKey);
};
export const getEmptySelection = () => ({
  allSelected: false,
  items: new Set(),
  exceptItems: new Set()
});
/**
 * Produces rows selection state based on the current state and next user action
 * @param rowSelection {Object} - { allSelected, items, exceptItems }
 * @param action {Object} - { rowId, selectAll }
 * @param data {Array} - table data
 * @param rowIdDataKey {String} - key from row data to be used as identifier
 */

export function getSelectionOnAction({
  rowSelection,
  action,
  data,
  rowIdDataKey = '_id',
  itemsTotalCount
}) {
  const {
    rowId,
    selectAll
  } = action;
  const {
    allSelected: prevAllSelected,
    items: prevItems,
    exceptItems: prevExceptItems
  } = rowSelection;
  let allSelected = prevAllSelected;
  const items = new Set(prevItems);
  const exceptItems = new Set(prevExceptItems);
  const totalCount = itemsTotalCount || data?.length || 0;
  const rowSelect = !items.has(rowId);
  const rowUnSelect = !rowSelect;

  if (selectAll) {
    const someSelected = items.size;
    const ids = someSelected ? [] : data.map(item => item[rowIdDataKey]);
    return {
      allSelected: !someSelected,
      items: new Set(ids),
      exceptItems: new Set()
    };
  }

  if (!allSelected && rowSelect) {
    items.add(rowId);
    exceptItems.clear();

    if (items.size === totalCount) {
      allSelected = true;
    }
  }

  if (!allSelected && rowUnSelect) {
    items.delete(rowId);
    exceptItems.clear();
  }

  if (allSelected && rowSelect) {
    items.add(rowId);
    exceptItems.delete(rowId);
  }

  if (allSelected && rowUnSelect) {
    items.delete(rowId);
    exceptItems.add(rowId);

    if (exceptItems.size === totalCount) {
      allSelected = false;
    }
  }

  return {
    allSelected,
    items,
    exceptItems
  };
}
/**
 * Produces rows selection state based on the current state and data
 * @param rowSelection {Object} - { allSelected, items, exceptItems }
 * @param data {Array} - table data
 * @param rowIdDataKey {String} - key from row data to be used as identifier
 * @returns {Object} - { allSelected, items, exceptItems }
 */

export function getSelectionOnData({
  rowSelection,
  data,
  rowIdDataKey = '_id'
}) {
  const {
    allSelected,
    items,
    exceptItems
  } = rowSelection;
  let newItems = new Set();

  if (allSelected) {
    const ids = data.map(item => item[rowIdDataKey]);
    newItems = new Set(ids);
    exceptItems.forEach(id => newItems.delete(id));
    return {
      allSelected,
      items: new Set([...items, ...newItems]),
      exceptItems
    };
  }

  return {
    allSelected,
    items,
    exceptItems
  };
}