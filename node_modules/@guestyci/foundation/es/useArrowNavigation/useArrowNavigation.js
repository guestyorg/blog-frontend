import { useCallback, useEffect, useRef } from 'react';
const allowedScrollKeys = new Set(['ArrowUp', 'ArrowDown', 'Home', 'End']);
const allowedKeys = new Set(['ArrowUp', 'ArrowDown', 'Home', 'End', 'Enter']);

const isVisible = (menu, el) => {
  const menuHeight = menu.offsetHeight;
  const menuScrollOffset = menu.scrollTop;
  const elemTop = el.offsetTop - menu.offsetTop;
  const elemBottom = elemTop + el.offsetHeight;
  return elemTop >= menuScrollOffset && elemBottom <= menuScrollOffset + menuHeight;
};
/**
 * React hook to support key navigation
 * @param menuRef -{ React Ref }- ref for the menu / list which holds the menu items
 * @param anchorRef -{ React Ref }-  the focusable trigger for the menu to be shown
 * @param options -{ Object }-  {
 * activeClassName = 'active',
 * onKeyDown = null,
 * preventDefault = false,
 * clearActive {boolean} - boolean indicator to clear active item when true. (toggle for change)
 * }
 * @return {Array}
 */


const useArrowNavigation = (menuRef, anchorRef, options = {}) => {
  const activeRef = useRef(null);
  const {
    activeClassName = 'active',
    onKeyDown,
    preventDefault,
    clearActive = false
  } = options;

  const scrollTo = activeEl => {
    const {
      current: menuCurrent
    } = menuRef;

    if (!isVisible(menuCurrent, activeEl)) {
      menuCurrent.scroll({
        top: activeEl.offsetTop
      });
    }
  };

  const clearActiveItem = () => {
    activeRef.current = null;
  };

  const getActiveCurrent = () => activeRef.current;

  useEffect(() => {
    if (clearActive) {
      clearActiveItem();
    }
  }, [clearActive]);
  const handleKeyDown = useCallback(e => {
    if (preventDefault) {
      e.preventDefault();
    }

    const {
      key
    } = e;
    const {
      current: menuCurrent
    } = menuRef;
    const activeCurrent = getActiveCurrent();
    const {
      current: anchorCurrent
    } = anchorRef;

    if (onKeyDown) {
      onKeyDown(e);
    }

    if (!menuCurrent || !anchorCurrent || !allowedKeys.has(key)) {
      return;
    }

    if (allowedScrollKeys.has(key) && (anchorCurrent === activeCurrent || !activeCurrent)) {
      activeRef.current = menuCurrent.firstChild;
      activeRef.current.classList.toggle(activeClassName);
      return;
    }

    if (activeCurrent) {
      activeCurrent.classList.toggle(activeClassName);
    }

    switch (key) {
      case 'Home':
        activeRef.current = menuCurrent.firstChild;
        break;

      case 'End':
        activeRef.current = menuCurrent.lastChild;
        break;

      case 'ArrowDown':
        if (activeCurrent.nextElementSibling) {
          activeRef.current = activeCurrent.nextElementSibling;
        } else {
          activeRef.current = menuCurrent.firstChild;
        }

        break;

      case 'ArrowUp':
        if (activeCurrent.previousElementSibling) {
          activeRef.current = activeCurrent.previousElementSibling;
        } else {
          activeRef.current = menuCurrent.lastChild;
        }

        break;

      case 'Enter':
        if (activeCurrent) {
          activeCurrent.click();
        }

        break;

      default:
        break;
    }

    if (allowedScrollKeys.has(key) && activeRef?.current) {
      activeRef.current.classList.toggle(activeClassName);
      scrollTo(activeRef.current);
    }
  }, [activeRef.current]);
  return [handleKeyDown, activeRef];
};

export default useArrowNavigation;