import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import 'react-dates/initialize';
import moment from 'moment';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isObject from 'lodash/isObject';
import has from 'lodash/has';
import withStyles from 'react-jss';
import { END_DATE, START_DATE } from 'react-dates/lib/constants';
import memoize from '@guestyci/memoize';
import { uuid } from "../../utils/commonUtility";
import { DatePickerType } from "../../enums/enums";
import RangePicker from "./RangePicker";
import SinglePicker from "./SinglePicker";
import ActionButton from "../ActionButton";
import { grayLight } from "../../theme/colors";
import NavButton from "./DatePickerNavButton";
import IconButton from "../IconButton/IconButton";
import FlatButton from "../FlatButton/FlatButton";
import Fade from "../Fade";

var BtnDelete = function BtnDelete(props) {
  return /*#__PURE__*/React.createElement("svg", props, /*#__PURE__*/React.createElement("path", {
    d: "M8.485.707L7.778 0 4.243 3.536.707 0 0 .707l3.536 3.536L0 7.778l.707.707L4.243 4.95l3.535 3.535.707-.707L4.95 4.243z"
  }));
};

BtnDelete.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 8.4854 8.4854"
};
import Row from "../Row";
var DATE_FORMAT = 'YYYY-MM-DD';
var containerSize = 46;
var styles = {
  container: {
    background: 'white',
    width: '100%',
    height: containerSize,
    display: 'flex',
    justifyContent: 'space-between',
    border: "1px solid ".concat(grayLight),
    borderRadius: 2
  },
  iconContainer: {
    height: 44,
    borderLeft: "1px solid ".concat(grayLight),
    borderTop: '0px',
    borderBottom: '0px',
    borderRight: '0px'
  },
  dateInputWrapper: {
    flex: 1,
    width: 'calc(100% - 85px)',
    display: 'flex',
    alignItems: 'center'
  }
};

var falseFunc = function falseFunc() {
  return false;
};

var renderMonthElement = function renderMonthElement(_ref) {
  var month = _ref.month;
  return /*#__PURE__*/React.createElement("span", {
    "data-qa": "render-month-element"
  }, month.format('MMMM YYYY'));
};

var isEqualValue = function isEqualValue(type, newValue, currentValue) {
  if (type === DatePickerType.Single) {
    return moment(newValue).isSame(currentValue);
  }

  var sameStart = newValue.start === currentValue.startDate || moment(newValue.start).isSame(currentValue.startDate);
  var sameEnd = newValue.end === currentValue.endDate || moment(newValue.end).isSame(currentValue.endDate);
  return sameStart && sameEnd;
};

var isEqualDefaultValue = function isEqualDefaultValue(type, newValue, currentValue) {
  if (type === DatePickerType.Single) {
    return moment(newValue).isSame(currentValue);
  }

  return moment(newValue.start).isSame(currentValue.start) && moment(newValue.end).isSame(currentValue.end);
};

var openDirections = {
  Down: 'down',
  Up: 'up'
};

var DatePicker = /*#__PURE__*/function (_Component) {
  _inherits(DatePicker, _Component);

  var _super = _createSuper(DatePicker);

  function DatePicker(props) {
    var _this;

    _classCallCheck(this, DatePicker);

    _this = _super.call(this, props);

    _this.setValues = function () {
      var _this$props = _this.props,
          value = _this$props.value,
          defaultValue = _this$props.defaultValue,
          type = _this$props.type;

      _this.setState(_this.setInitialValues(type, value || defaultValue));
    };

    _this.onFocus = function (focus) {
      var _this$props2 = _this.props,
          type = _this$props2.type,
          onFocusChange = _this$props2.onFocusChange;
      var focusItem = focus;

      if (focusItem && focusItem.currentTarget) {
        focusItem = type === DatePickerType.Range ? START_DATE : true;
      } else if (isObject(focus)) {
        focusItem = focus.focused;
      }

      _this.setState({
        isFocused: !!focusItem,
        focused: focusItem,
        clicked: true
      });

      if (onFocusChange) {
        onFocusChange(focusItem);
      }
    };

    _this.onDatesChange = function (_ref2) {
      var startDate = _ref2.startDate,
          endDate = _ref2.endDate;
      var _this$props3 = _this.props,
          onChange = _this$props3.onChange,
          blockedDates = _this$props3.blockedDates,
          isAvailability = _this$props3.isAvailability,
          id = _this$props3.id,
          name = _this$props3.name;
      var focused = _this.state.focused;
      var blockedArray = Object.keys(blockedDates).sort();
      var blockedEndDay = blockedArray[blockedArray.length - 1];
      var blockedStartDay = blockedArray[0];
      var _endDate = endDate;

      if (focused === START_DATE && endDate) {
        _endDate = null;
      }

      _this.setState({
        startDate: startDate,
        endDate: _endDate
      });

      onChange({
        start: startDate,
        end: _endDate
      }, id || name);

      if (isAvailability) {
        if (startDate && _endDate || !startDate && !_endDate) {
          return;
        }

        if (!_endDate && startDate.isBefore(blockedEndDay)) {
          _this.boundaries.end = blockedArray.find(function (blockedDay) {
            return moment(blockedDay).isAfter(startDate);
          });
        } else if (!startDate && _endDate.isAfter(blockedStartDay)) {
          var closestBlocked = blockedArray.reverse().find(function (blockedDay) {
            return moment(blockedDay).isBefore(_endDate);
          });
          _this.boundaries.start = moment(closestBlocked).add(1, 'days');
        }
      }
    };

    _this.onDateChange = function (date) {
      var _this$props4 = _this.props,
          onChange = _this$props4.onChange,
          id = _this$props4.id,
          name = _this$props4.name;

      _this.setState({
        date: date
      });

      onChange(date, id || name);
    };

    _this.onMonthChange = function (month) {
      var start = moment(month).startOf('month').format(DATE_FORMAT);
      var end = moment(month).endOf('month').format(DATE_FORMAT);
      var _this$state = _this.state,
          startDate = _this$state.startDate,
          endDate = _this$state.endDate;
      var _this$props5 = _this.props,
          blockedDates = _this$props5.blockedDates,
          onMonthChange = _this$props5.onMonthChange;
      var startDay = startDate && startDate.isBefore(start) ? startDate.format(DATE_FORMAT) : start;
      var endDay = endDate && endDate.isAfter(end) ? endDate.format(DATE_FORMAT) : end;

      if ((!blockedDates[startDay] || !blockedDates[endDay]) && onMonthChange) {
        onMonthChange(start, end);
      }
    };

    _this.setInitialValues = function (type, value) {
      if (type === DatePickerType.Single) {
        return {
          date: value ? moment(value) : null
        };
      }

      return {
        startDate: isObject(value) && value.start ? moment(value.start) : null,
        endDate: isObject(value) && value.end ? moment(value.end) : null,
        clicked: !!(isObject(value) && (value.start || value.end))
      };
    };

    _this.getComponentIds = memoize(function (_ref3) {
      var id = _ref3.id,
          startDateId = _ref3.startDateId,
          endDateId = _ref3.endDateId;
      return {
        id: id || "date_".concat(uuid()),
        startDateId: startDateId || "start-date-id_".concat(uuid()),
        endDateId: endDateId || "end-date-id_".concat(uuid())
      };
    });

    _this.getTooltipByType = function (type) {
      return "Select ".concat(type === DatePickerType.Single ? 'a date' : 'dates');
    };

    _this.initialVisibleMonth = function () {
      var initialVisibleMonth = _this.props.initialVisibleMonth;
      var _this$state2 = _this.state,
          startDate = _this$state2.startDate,
          endDate = _this$state2.endDate,
          focused = _this$state2.focused;

      if (focused === START_DATE) {
        if (startDate) {
          return moment(startDate);
        }

        if (endDate) {
          return moment(endDate);
        }
      } else if (focused === END_DATE) {
        if (endDate) {
          return moment(endDate);
        }

        if (startDate) {
          return moment(startDate);
        }
      }

      return initialVisibleMonth ? moment(initialVisibleMonth) : moment();
    };

    _this.isDayBlocked = function (date) {
      var _this$state3 = _this.state,
          focused = _this$state3.focused,
          endDate = _this$state3.endDate,
          startDate = _this$state3.startDate;
      var _this$props6 = _this.props,
          blockedDates = _this$props6.blockedDates,
          isFetching = _this$props6.isFetching;
      var day = date.format('YYYY-MM-DD');

      if (isFetching) {
        return true;
      }

      if (!startDate || !endDate || focused === END_DATE) {
        if (focused === END_DATE && _this.boundaries.end) {
          return moment(date.format(DATE_FORMAT)).isAfter(_this.boundaries.end) || moment(date.format(DATE_FORMAT)).isBefore(startDate);
        }

        if (focused === START_DATE && _this.boundaries.start) {
          return date.startOf('day').isBefore(_this.boundaries.start) || moment(date.format(DATE_FORMAT)).isAfter(endDate);
        }
      }

      _this.blockedDates[day] = day in blockedDates ? blockedDates[day] : _this.blockedDates[day];
      return _this.blockedDates[day];
    };

    _this.clearDates = function () {
      var type = _this.props.type;

      _this.setState({
        startDate: null,
        endDate: null,
        date: null,
        clicked: false
      });

      _this.boundaries.start = null;
      _this.boundaries.end = null;

      if (type === DatePickerType.Range) {
        _this.onDatesChange({
          startDate: null,
          endDate: null
        });
      } else {
        _this.onDateChange(null);
      }
    };

    _this.renderDayContents = function (date) {
      var isFetching = _this.props.isFetching;

      if (isFetching) {
        return /*#__PURE__*/React.createElement("span", {
          className: "flex-center text-muted letter-spacing-2"
        }, "...");
      }

      return date.date();
    };

    _this.renderCalendarIcon = function () {
      var _this$props7 = _this.props,
          classes = _this$props7.classes,
          type = _this$props7.type,
          id = _this$props7.id,
          disabled = _this$props7.disabled,
          asLabel = _this$props7.asLabel,
          datepickerIcon = _this$props7.datepickerIcon;
      var isFocused = _this.state.isFocused;
      return /*#__PURE__*/React.createElement(ActionButton, {
        className: cn('b-0 zindex-10', classes.iconContainer, {
          'asLabel-iconContainer border-0 icon-left': asLabel,
          'icon-right': !asLabel
        }),
        tooltip: _this.getTooltipByType(type),
        onClick: _this.onFocus,
        id: id,
        icon: datepickerIcon,
        disabled: disabled,
        iconColor: isFocused ? 'blue' : 'gray-dark'
      });
    };

    var _value = props.value,
        _defaultValue = props.defaultValue,
        _type = props.type,
        _isAvailability = props.isAvailability,
        _onMonthChange = props.onMonthChange,
        _blockedDates = props.blockedDates;
    _this.state = _extends({}, _this.setInitialValues(_type, _value || _defaultValue), {
      clicked: !!(_value || _defaultValue),
      openDirection: openDirections.Down
    });
    _this.fieldElement = React.createRef();
    _this.blockedDates = {};
    _this.boundaries = {
      start: null,
      end: null
    };

    if (_isAvailability) {
      if (!_onMonthChange) {
        throw new Error('onMonthChange required with isAvailability');
      }

      if (has(_value, 'start')) {
        var blockedArray = Object.keys(_blockedDates).sort();
        _this.boundaries.end = blockedArray.find(function (blockedDay) {
          return moment(blockedDay).isAfter(_value.start);
        });
      }
    }

    return _this;
  }

  _createClass(DatePicker, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props8 = this.props,
          type = _this$props8.type,
          value = _this$props8.value,
          defaultValue = _this$props8.defaultValue;
      var _this$state4 = this.state,
          date = _this$state4.date,
          startDate = _this$state4.startDate,
          endDate = _this$state4.endDate,
          isFocused = _this$state4.isFocused;

      if (isFocused) {
        this.inViewport();
      }

      if (value && !isEqualValue(type, value, date || {
        startDate: startDate,
        endDate: endDate
      })) {
        this.setValues();
      }

      if (defaultValue && !isEqualDefaultValue(type, defaultValue, prevProps.defaultValue)) {
        this.setValues();
      }
    }
  }, {
    key: "inViewport",
    value: function inViewport() {
      var openDirection = this.state.openDirection;
      if (!this.fieldElement.current) return;
      var rect = this.fieldElement.current.getBoundingClientRect();
      var openDirectionValue = rect.top > window.innerHeight - rect.bottom ? openDirections.Up : openDirections.Down;

      if (openDirection !== openDirectionValue) {
        this.setState({
          openDirection: openDirectionValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props9 = this.props,
          id = _this$props9.id,
          classes = _this$props9.classes,
          className = _this$props9.className,
          style = _this$props9.style,
          type = _this$props9.type,
          enablePastDays = _this$props9.enablePastDays,
          focus = _this$props9.focus,
          sm = _this$props9.sm,
          disabled = _this$props9.disabled,
          anchorDirection = _this$props9.anchorDirection,
          showClearDate = _this$props9.showClearDate,
          appendToBody = _this$props9.appendToBody,
          asLabel = _this$props9.asLabel,
          iconPosition = _this$props9.iconPosition,
          startDatePlaceholderText = _this$props9.startDatePlaceholderText,
          endDatePlaceholderText = _this$props9.endDatePlaceholderText,
          asLabelPlaceholderText = _this$props9.asLabelPlaceholderText,
          renderCalendarIcon = _this$props9.renderCalendarIcon,
          startDateId = _this$props9.startDateId,
          endDateId = _this$props9.endDateId;
      var propsForPicker = {
        prevMonthButton: /*#__PURE__*/React.createElement(NavButton, {
          direction: "Left",
          sm: sm,
          type: type
        }),
        nextMonthButton: /*#__PURE__*/React.createElement(NavButton, {
          direction: "Right",
          sm: sm,
          type: type
        }),
        renderMonthElement: renderMonthElement,
        verticalSpacing: type === DatePickerType.Single ? 4 : 10,
        readOnly: true,
        daySize: type === DatePickerType.Single || sm ? 40 : 50,
        numberOfMonths: type === DatePickerType.Single || sm ? 1 : 2,
        appendToBody: appendToBody
      };

      if (enablePastDays) {
        propsForPicker.isOutsideRange = falseFunc;
      }

      var _this$state5 = this.state,
          startDate = _this$state5.startDate,
          endDate = _this$state5.endDate,
          date = _this$state5.date,
          focused = _this$state5.focused,
          clicked = _this$state5.clicked,
          openDirection = _this$state5.openDirection;
      var shouldRenderClearDate = !!(date || startDate || endDate);
      var elemIds = this.getComponentIds({
        id: id,
        startDateId: startDateId,
        endDateId: endDateId
      });
      return /*#__PURE__*/React.createElement(Row, {
        className: cn('relative', {
          sm: sm
        }, 'flex-start-center', 'date-picker', className, classes.container, {
          asLabel: asLabel
        }),
        style: style,
        "data-qa": "date-picker"
      }, /*#__PURE__*/React.createElement("div", {
        className: cn(classes.dateInputWrapper, {
          'asLabel-dateInputWrapper': asLabel,
          'asLabel-dateInputWrapper_disabled': !clicked && asLabel
        }),
        ref: this.fieldElement
      }, renderCalendarIcon && iconPosition === 'left' && this.renderCalendarIcon(), asLabel && !shouldRenderClearDate && !clicked && /*#__PURE__*/React.createElement(FlatButton, {
        className: "label-placeholder",
        onClick: this.onFocus
      }, asLabelPlaceholderText), type === DatePickerType.Range && /*#__PURE__*/React.createElement(RangePicker, _extends({}, this.props, propsForPicker, {
        disabled: disabled,
        startDate: startDate,
        startDateId: elemIds.startDateId,
        endDateId: elemIds.endDateId,
        endDate: endDate,
        focusedInput: focused,
        onFocus: this.onFocus,
        renderDayContents: function renderDayContents(day) {
          return _this2.renderDayContents(day);
        },
        onDatesChange: this.onDatesChange,
        isDayBlocked: function isDayBlocked(day) {
          return _this2.isDayBlocked(day);
        },
        onMonthChange: this.onMonthChange,
        initialVisibleMonth: this.initialVisibleMonth,
        anchorDirection: anchorDirection,
        openDirection: openDirection,
        asLabel: asLabel,
        startDatePlaceholderText: startDatePlaceholderText,
        endDatePlaceholderText: endDatePlaceholderText
      })), type === DatePickerType.Single && /*#__PURE__*/React.createElement(SinglePicker, _extends({}, this.props, propsForPicker, {
        id: elemIds.id,
        disabled: disabled,
        date: date,
        onFocusChange: this.onFocus,
        isFocused: focus || !!focused,
        onDateChange: this.onDateChange,
        renderDayContents: function renderDayContents(day) {
          return _this2.renderDayContents(day);
        },
        isDayBlocked: function isDayBlocked(day) {
          return _this2.isDayBlocked(day);
        },
        initialVisibleMonth: this.initialVisibleMonth,
        anchorDirection: anchorDirection,
        openDirection: openDirection
      }))), showClearDate && shouldRenderClearDate && /*#__PURE__*/React.createElement(Fade, {
        show: shouldRenderClearDate,
        className: "datepicker-clear mb-1"
      }, /*#__PURE__*/React.createElement(IconButton, {
        onClick: this.clearDates,
        svg: BtnDelete,
        iconHeight: 10,
        iconWidth: 10
      })), renderCalendarIcon && iconPosition === 'right' && this.renderCalendarIcon());
    }
  }]);

  return DatePicker;
}(Component);

DatePicker.defaultProps = {
  type: DatePickerType.Single,
  isAvailability: false,
  minimumNights: 1,
  blockedDates: {},
  disabled: false,
  initialVisibleMonth: null,
  value: undefined,
  defaultValue: undefined,
  onMonthChange: null,
  enablePastDays: false,
  focus: false,
  onFocusChange: null,
  sm: true,
  isFetching: false,
  anchorDirection: 'left',
  id: undefined,
  showClearDate: true,
  appendToBody: false,
  iconPosition: 'right',
  renderCalendarIcon: true,
  startDatePlaceholderText: 'Start date',
  endDatePlaceholderText: 'End date',
  startDateId: undefined,
  endDateId: undefined,
  datepickerIcon: 'BtnCalendar'
};
DatePicker.propTypes = {
  /** Id for date picker */
  id: PropTypes.string,

  /** Picker type single/range */
  type: PropTypes.oneOf(Object.values(DatePickerType)),

  /** Minimium Nights, 0 to allow single day range */
  minimumNights: PropTypes.number,

  /** Boolean - if it's avalibilty picker or regular picker (without blocked days) */
  isAvailability: PropTypes.bool,

  /** unavailable object structure :
   *  {
   *   '2018-01-01': true,
   *    '2018-06-01': true,
   *    ...
   *  } */
  blockedDates: PropTypes.object,
  // eslint-disable-line react/forbid-prop-types

  /** Boolean - disable the date input */
  disabled: PropTypes.bool,

  /** Set the initial month for the date picker */
  initialVisibleMonth: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),

  /** Render position of the calendar icon */
  iconPosition: PropTypes.string,

  /** Conditional boolean for rendering range-picker input as label */
  asLabel: PropTypes.bool,

  /** initial value for date range picker - date - for single - {start, end } for range */
  value: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.shape()]),

  /** initial value for date range picker - date - for single - {start, end } for range */
  defaultValue: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.shape()]),

  /** A request to fetch the availability for star - end period (start, end) => {} */
  onMonthChange: PropTypes.func,

  /** callback when dates change : Range:  ({start, end})  Single: (date) */
  onChange: PropTypes.func.isRequired,

  /** Boolean - if should enable select past days */
  enablePastDays: PropTypes.bool,

  /** if input is focused (open picker) for single picker */
  focus: PropTypes.bool,

  /** focus change callback */
  onFocusChange: PropTypes.func,

  /** Set picker mode, sm or md  to determine the amount of months presented in the picker */
  sm: PropTypes.bool,

  /** Indicator whether or not we are fetching availability */
  isFetching: PropTypes.bool,

  /** Set which direction the drop down will open options: [left|right]  */
  anchorDirection: PropTypes.string,

  /** Indicator whether or not we are displaying clear button  */
  showClearDate: PropTypes.bool,

  /** Boolean - prevent the cut off when the picker inside dialog */
  appendToBody: PropTypes.bool,

  /** Render calendar icon bool */
  renderCalendarIcon: PropTypes.bool,

  /** Placeholder for start date */
  startDatePlaceholderText: PropTypes.string,

  /** Placeholder for end date */
  endDatePlaceholderText: PropTypes.string,

  /** Id for start date input and label */
  startDateId: PropTypes.string,

  /** Id for end date input and label */
  endDateId: PropTypes.string,

  /** Icon to display */
  datepickerIcon: PropTypes.string
};
/** Work around to fix storybook HOC propTypes bug  - DO NOT IMPORT THIS */

export var DatePickerComponent = DatePicker;
export default withStyles(styles)(DatePicker);