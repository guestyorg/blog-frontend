import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import React, { useRef, useState, useEffect, useCallback } from 'react';
import cn from 'classnames';
import PropTypes from 'prop-types';
import isEmpty from 'lodash/isEmpty';
import createStyles from "../createStyles";
import DropdownInput from "./DropdownInput";
import Menu from "../Menu/Menu";
import composeEvent from "../utils/composeEvent";
import TextField from "../TextField";
import DropdownSearch from "./DropdownSearch";
import DropdownMenuList from "./DropdownMenuList";
import InfiniteScroll from "../InfiniteScroll";
export var useStyles = createStyles(function (theme) {
  return {
    root: {
      display: 'flex',
      width: '100%',
      position: 'relative',
      flexFlow: 'column'
    },
    input: {
      marginLeft: theme.spacer(1),
      width: "calc(100% - ".concat(theme.spacer(2), "px)")
    },
    menu: {
      overflowY: 'hidden',
      maxHeight: '100%'
    },
    menuList: {
      maxHeight: 260,
      padding: 0
    },
    scrollable: {
      overflowY: 'auto'
    },
    searchableMaxHeight: {
      maxHeight: 220
    },
    initialLoading: {
      height: 180
    },
    emptyState: {
      color: theme.palette.text.secondary,
      paddingLeft: theme.spacer(1),
      paddingTop: theme.spacer(1)
    }
  };
}, {
  name: 'Dropdown'
});
var loaderOverride = {
  loader: {
    height: '100%'
  }
};
var Dropdown = React.forwardRef(function Dropdown(_ref, ref) {
  var _cn;

  var children = _ref.children,
      input = _ref.input,
      placeholder = _ref.placeholder,
      inputProps = _ref.inputProps,
      renderComponent = _ref.renderComponent,
      className = _ref.className,
      style = _ref.style,
      jss = _ref.jss,
      onChange = _ref.onChange,
      renderSelected = _ref.renderSelected,
      value = _ref.value,
      variant = _ref.variant,
      searchable = _ref.searchable,
      onSearchQueryChange = _ref.onSearchQueryChange,
      disabled = _ref.disabled,
      emptyStateComponent = _ref.emptyStateComponent,
      name = _ref.name,
      error = _ref.error,
      menuWidth = _ref.menuWidth,
      infiniteScrollOptions = _ref.infiniteScrollOptions,
      props = _objectWithoutProperties(_ref, ["children", "input", "placeholder", "inputProps", "renderComponent", "className", "style", "jss", "onChange", "renderSelected", "value", "variant", "searchable", "onSearchQueryChange", "disabled", "emptyStateComponent", "name", "error", "menuWidth", "infiniteScrollOptions"]);

  var classes = useStyles({
    jss: jss
  });
  var dropdownAnchorRef = useRef();
  var searchInputRef = useRef();

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      open = _useState2[0],
      setOpen = _useState2[1];

  var _useState3 = useState(''),
      _useState4 = _slicedToArray(_useState3, 2),
      query = _useState4[0],
      setQuery = _useState4[1];

  useEffect(function () {
    if (open && searchable && searchInputRef) {
      setTimeout(function () {
        return searchInputRef.current.focus();
      }, 0);
    }
  }, [open]);

  var handleInputClick = function handleInputClick() {
    setOpen(!open);
  };

  var handleDismissDropdown = function handleDismissDropdown() {
    setOpen(false);
  };

  var dispatchOnChange = function dispatchOnChange(e, selectedValue) {
    e.stopPropagation();
    var newEvent = composeEvent(e, {
      name: name,
      value: selectedValue
    });
    onChange(newEvent, selectedValue);

    if (variant === 'single') {
      handleDismissDropdown();
    }
  };

  var handleSelectItem = useCallback(function (e, menuItemValue) {
    setQuery('');
    dispatchOnChange(e, menuItemValue);
  }, [setQuery, dispatchOnChange]);

  var handleSearchInputChange = function handleSearchInputChange(e) {
    var searchQueryValue = e.currentTarget.value;
    setQuery(searchQueryValue);
    onSearchQueryChange(composeEvent(e, {
      name: name
    }));
  };

  var handleClearSearchInputQuery = function handleClearSearchInputQuery(e) {
    setQuery('');
    onSearchQueryChange(composeEvent(e, {
      name: name,
      value: ''
    }));
  };

  var handleClearValue = function handleClearValue(e) {
    // Due to bug in redux form, we must pass null
    // see details here: https://github.com/redux-form/redux-form/issues/3946
    dispatchOnChange(e, null);
  };

  var isLoading = infiniteScrollOptions.isLoading;
  var InputComponent = input || /*#__PURE__*/React.createElement(DropdownInput, null);
  var shouldShowEmptyState = isEmpty(children) && !isLoading;
  var isInfiniteScroll = infiniteScrollOptions.totalCount;
  var emptyStateMessage = searchable && query ? 'No results found.' : emptyStateComponent;
  return /*#__PURE__*/React.createElement("div", _extends({
    className: cn(classes.root, className),
    style: style,
    ref: ref
  }, props), React.cloneElement(InputComponent, _extends({
    ref: dropdownAnchorRef,
    open: open,
    name: name,
    variant: variant,
    disabled: disabled,
    value: value,
    placeholder: placeholder,
    renderComponent: renderComponent,
    renderSelected: renderSelected,
    onClear: handleClearValue,
    onClick: handleInputClick,
    onChange: dispatchOnChange,
    error: error
  }, inputProps)), /*#__PURE__*/React.createElement(Menu, {
    variant: "menu",
    menuWidth: menuWidth,
    open: open,
    onClose: handleDismissDropdown,
    className: classes.menu,
    anchorDirection: "start",
    originDirection: "bottom",
    fitAnchor: true,
    anchor: dropdownAnchorRef
  }, searchable && /*#__PURE__*/React.createElement(DropdownSearch, {
    ref: searchInputRef,
    value: query,
    onChange: handleSearchInputChange,
    onClear: handleClearSearchInputQuery,
    className: classes.input
  }), /*#__PURE__*/React.createElement(Menu, {
    variant: "list",
    elevation: 0,
    className: cn(classes.menuList, (_cn = {}, _defineProperty(_cn, classes.initialLoading, isLoading && isEmpty(children)), _defineProperty(_cn, classes.scrollable, !isInfiniteScroll), _defineProperty(_cn, classes.searchableMaxHeight, searchable), _cn))
  }, /*#__PURE__*/React.createElement(InfiniteScroll, _extends({}, infiniteScrollOptions, {
    jss: loaderOverride
  }), /*#__PURE__*/React.createElement(DropdownMenuList, {
    variant: variant,
    value: value,
    disabled: disabled,
    onChange: handleSelectItem
  }, children))), shouldShowEmptyState && emptyStateMessage && /*#__PURE__*/React.createElement(TextField, {
    className: cn(classes.emptyState)
  }, emptyStateMessage)));
});
Dropdown.defaultProps = {
  searchable: false,
  placeholder: 'Select an option',
  onSearchQueryChange: null,
  className: '',
  style: {},
  name: '',
  value: undefined,
  disabled: false,
  variant: 'single',
  emptyStateComponent: null,
  renderComponent: null,
  infiniteScrollOptions: {}
};
Dropdown.propTypes = {
  /** Dropdown menuItem options to provide to the dropdown
   * Use <MenuItem> component for rendering children
   */
  children: PropTypes.arrayOf(PropTypes.node).isRequired,

  /** Indicator whether or not the input field is searchable */
  searchable: PropTypes.bool,

  /** Placeholder for input field */
  placeholder: PropTypes.string,

  /** Empty state component  to display when there're no results */
  emptyStateComponent: PropTypes.node,

  /** Mandatory if searchable - callback for on input change */
  onSearchQueryChange: PropTypes.func,

  /** Callback function to be called on value changed - arguments - (event, value)
   * event will contain the html dom value converted to string, to access the full value, use the second argument
   * */
  onChange: PropTypes.func.isRequired,

  /** Additional class for dropdown root */
  className: PropTypes.string,

  /** Additional style for dropdown root */
  style: PropTypes.shape(),

  /** form element name */
  name: PropTypes.string,

  /** Selected dropdown value */
  value: PropTypes.oneOfType([PropTypes.shape(), PropTypes.array, PropTypes.string, PropTypes.number]),

  /** Set the dropdown content menu width manually - by default it will resolve to the larger of the input width or the content width */
  menuWidth: PropTypes.number,

  /** Indicator for disabled status */
  disabled: PropTypes.bool,

  /** variant for the type of dropdown we want to render - values [single, multiselect, chip] */
  variant: PropTypes.oneOf(['single', 'multiselect', 'chip']),

  /** custom props to pass to the input component */
  inputProps: PropTypes.shape(),

  /** DEPRECATED- USE renderSelected */
  renderComponent: PropTypes.func,

  /** Set the input component to show on selected item, Accepting function and String
   * If strings - will render the value[renderSelected].
   * If function - will pass the value props
   * */
  renderSelected: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),

  /** Object to define infinite scrolling behaviour */
  infiniteScrollOptions: PropTypes.shape({
    /** starting index of the chunk */
    skip: PropTypes.number,

    /** cb to notify about required loads */
    onLoadMore: PropTypes.func,

    /** total number of entries */
    totalCount: PropTypes.number,

    /** offset from the bottom, from which loading the next chunk should be triggered */
    scrollOffset: PropTypes.number,

    /** number of rows per page */
    pageSize: PropTypes.number
  }),

  /** indicator for data fetching state */
  isLoading: PropTypes.bool
};
Dropdown.displayName = 'Dropdown';
export default Dropdown;