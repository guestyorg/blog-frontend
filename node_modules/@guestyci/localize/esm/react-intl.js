import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import IntlPolyfill from 'intl';
import React from 'react';
import IntlMessageFormat from 'intl-messageformat';
import escapeHtml from 'escape-html';
import cookie from 'cookie';
import queryParser from 'querystring';
import load from 'load-script';
import invariant from 'invariant';
import 'console-polyfill';
import merge from 'lodash/merge';
import * as constants from "./react-intl-consts";

var isGetLanguages = function isGetLanguages() {
  return window && window.localStorage && window.localStorage.getItem('getLanguages');
};

String.prototype.defaultMessage = String.prototype.d = function (msg) {
  if (this.search('GUESTY_KEY=') > -1) {
    var newMsg = this.split('=');
    var body = {
      fields: {}
    };
    body.fields.message = {
      stringValue: msg
    };
    console.log('Guesty translate:', this, newMsg[1], msg);
    fetch("https://firestore.googleapis.com/v1beta1/projects/guesty-18n/databases/(default)/documents/overall/".concat(newMsg[1].trim()), {
      method: 'PATCH',
      body: JSON.stringify(body)
    });
    return msg || '';
  }

  return this || msg || '';
};

var ReactIntlUniversal =
/*#__PURE__*/
function () {
  function ReactIntlUniversal() {
    _classCallCheck(this, ReactIntlUniversal);

    this.options = {
      // Current locale such as 'en-US'
      currentLocale: null,
      // URL's query Key to determine locale. Example: if URL=http://localhost?lang=en-US, then set it 'lang'
      urlLocaleKey: null,
      // Cookie's Key to determine locale. Example: if cookie=lang:en-US, then set it 'lang'
      cookieLocaleKey: null,
      // app locale data like {"en-US":{"key1":"value1"},"zh-CN":{"key1":"值1"}}
      locales: {},
      // ability to accumulate missing messages using third party services like Sentry
      warningHandler: console.warn.bind(console),
      // Common locales js urls
      commonLocaleDataUrls: {},
      // disable escape html in variable mode
      escapeHtml: true,
      // Locale to use if a key is not found in the current locale
      fallbackLocale: null,
      debug: false
    };
  }
  /**
   * Get the formatted message by key
   * @param {string} key The string representing key in locale data file
   * @param {Object} variables Variables in message
   * @returns {string} message
   */


  _createClass(ReactIntlUniversal, [{
    key: "get",
    value: function get(key, variables) {
      var _this = this;

      var defaultMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      invariant(key, 'key is required');
      var _this$options = this.options,
          locales = _this$options.locales,
          currentLocale = _this$options.currentLocale,
          formats = _this$options.formats,
          warningHandler = _this$options.warningHandler,
          fallbackLocale = _this$options.fallbackLocale,
          debug = _this$options.debug;

      var getMessage = function getMessage(key) {
        if (!locales || !locales[currentLocale]) {
          debug && warningHandler("[react-intl] locales data \"".concat(currentLocale, "\" does not exist."));
          return '';
        }

        var msg = _this.getDescendantProp(locales[currentLocale], key);

        if (msg == null) {
          if (fallbackLocale) {
            msg = _this.getDescendantProp(locales[fallbackLocale], key);

            if (msg == null) {
              debug && warningHandler("react-intl-universal key \"".concat(key, "\" not defined in ").concat(currentLocale, " or the fallback locale, ").concat(fallbackLocale));

              if (isGetLanguages()) {
                return "GUESTY_KEY=".concat(key);
              }

              return '';
            }
          } else {
            if (isGetLanguages()) {
              return "GUESTY_KEY=".concat(key);
            }

            debug && warningHandler("react-intl-universal key \"".concat(key, "\" not defined in ").concat(currentLocale));
            return '';
          }
        }

        return msg;
      };

      var msg = getMessage(key);

      if (msg == null || msg == '') {
        if (defaultMessage != null) {
          msg = defaultMessage;
        } else {
          return ''; // keep old behavior if default not provided
        }
      }

      if (variables) {
        variables = Object.assign({}, variables); // HTML message with variables. Escape it to avoid XSS attack.

        for (var i in variables) {
          var value = variables[i];

          if (this.options.escapeHtml === true && (typeof value === 'string' || value instanceof String) && value.indexOf('<') >= 0 && value.indexOf('>') >= 0) {
            value = escapeHtml(value);
          }

          variables[i] = value;
        }
      }

      try {
        var msgFormatter = new IntlMessageFormat(msg, currentLocale, formats);
        return msgFormatter.format(variables);
      } catch (err) {
        debug && warningHandler("[react-intl] format message failed for key='".concat(key, "'."), err.message);
        return msg;
      }
    }
    /**
     * Get the formatted html message by key.
     * @param {string} key The string representing key in locale data file
     * @param {Object} variables Variables in message
     * @returns {React.Element} message
     */

  }, {
    key: "getHTML",
    value: function getHTML(key, variables) {
      var msg = this.get(key, variables);

      if (msg) {
        var el = React.createElement('span', {
          dangerouslySetInnerHTML: {
            __html: msg
          }
        }); // when key exists, it should still return element if there's defaultMessage() after getHTML()

        var defaultMessage = function defaultMessage() {
          return el;
        };

        return Object.assign({
          defaultMessage: defaultMessage,
          d: defaultMessage
        }, el);
      }

      return '';
    }
    /**
     * As same as get(...) API
     * @param {Object} options
     * @param {string} options.id
     * @param {string} options.defaultMessage
     * @param {Object} variables Variables in message
     * @returns {string} message
     */

  }, {
    key: "formatMessage",
    value: function formatMessage(messageDescriptor, variables) {
      var id = messageDescriptor.id,
          defaultMessage = messageDescriptor.defaultMessage;
      return this.get(id, variables).defaultMessage(defaultMessage);
    }
    /**
     * As same as getHTML(...) API
     * @param {Object} options
     * @param {string} options.id
     * @param {React.Element} options.defaultMessage
     * @param {Object} variables Variables in message
     * @returns {React.Element} message
     */

  }, {
    key: "formatHTMLMessage",
    value: function formatHTMLMessage(messageDescriptor, variables) {
      var id = messageDescriptor.id,
          defaultMessage = messageDescriptor.defaultMessage;
      return this.getHTML(id, variables).defaultMessage(defaultMessage);
    }
    /**
     * Helper: determine user's locale via URL, cookie, and browser's language.
     * You may not this API, if you have other rules to determine user's locale.
     * @param {string} options.urlLocaleKey URL's query Key to determine locale. Example: if URL=http://localhost?lang=en-US, then set it 'lang'
     * @param {string} options.cookieLocaleKey Cookie's Key to determine locale. Example: if cookie=lang:en-US, then set it 'lang'
     * @returns {string} determined locale such as 'en-US'
     */

  }, {
    key: "determineLocale",
    value: function determineLocale() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.getLocaleFromURL(options) || this.getLocaleFromCookie(options) || this.getLocaleFromBrowser();
    }
    /**
     * Initialize properties and load CLDR locale data according to currentLocale
     * @param {Object} options
     * @param {string} options.currentLocale Current locale such as 'en-US'
     * @param {string} options.locales App locale data like {"en-US":{"key1":"value1"},"zh-CN":{"key1":"值1"}}
     * @returns {Promise}
     */

  }, {
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      invariant(options.currentLocale, 'options.currentLocale is required');
      Object.assign(this.options, options);
      var currentLocale = this.options.currentLocale;
      this.options.formats = Object.assign({}, this.options.formats, constants.defaultFormats);
      var langURL = this.getLocaleFromURL({
        urlLocaleKey: 'lang'
      });

      if (langURL && window && window.localStorage) {
        console.warn('changing lang to ', langURL);
        window.localStorage.setItem('lang', langURL);
      }

      return this.loadRemoteScript(currentLocale);
    }
    /**
     * Get the inital options
     */

  }, {
    key: "getInitOptions",
    value: function getInitOptions() {
      return this.options;
    }
    /**
     * Load more locales after init
     */

  }, {
    key: "load",
    value: function load(locales) {
      merge(this.options.locales, locales);
    }
  }, {
    key: "loadRemoteScript",
    value: function loadRemoteScript(lang) {
      var locale = lang.split('-')[0].split('_')[0];
      var _this$options2 = this.options,
          commonLocaleDataUrls = _this$options2.commonLocaleDataUrls,
          debug = _this$options2.debug,
          warningHandler = _this$options2.warningHandler;
      return new Promise(function (resolve) {
        var localeURL = commonLocaleDataUrls[locale];

        if (!localeURL && debug) {
          warningHandler("[react-intl] Language \"".concat(lang, "\" is not fully supported."));
          resolve();
        }

        load(localeURL, function (err) {
          if (err && debug) {
            warningHandler("[react-intl] Language file \"".concat(lang, ".js\" was not loaded."));
          }

          resolve();
        });
      });
    }
  }, {
    key: "getLocaleFromCookie",
    value: function getLocaleFromCookie(options) {
      var cookieLocaleKey = options.cookieLocaleKey;

      if (cookieLocaleKey) {
        var params = cookie.parse(document.cookie);
        return params && params[cookieLocaleKey];
      }
    }
  }, {
    key: "getLocaleFromURL",
    value: function getLocaleFromURL(options) {
      var urlLocaleKey = options.urlLocaleKey;

      if (urlLocaleKey) {
        var query = location.search.split('?');

        if (query.length >= 2) {
          var params = queryParser.parse(query[1]);
          return params && params[urlLocaleKey];
        }
      }
    }
  }, {
    key: "getDescendantProp",
    value: function getDescendantProp(locale, key) {
      if (locale[key]) {
        return locale[key];
      }

      var msg = key.split('.').reduce(function (a, b) {
        return a !== undefined ? a[b] : a;
      }, locale);
      return msg;
    }
  }, {
    key: "getLocaleFromBrowser",
    value: function getLocaleFromBrowser() {
      return navigator.language || navigator.userLanguage;
    }
  }]);

  return ReactIntlUniversal;
}();

var instance = new ReactIntlUniversal();
export default instance;