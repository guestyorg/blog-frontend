import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import React, { useCallback, useEffect, useRef, useState } from 'react';
import PropTypes from 'prop-types';
import debounce from 'lodash/debounce';
import { AnchorDirectionType, OriginDirectionType } from "../../enums";
import Portal from "../Portal";
import createStyles from "../../createStyles";
import CSSTransition from "../../CSSTransition";
var anchorTransformOriginMapper = {
  start: 'left',
  end: 'right',
  center: 'center'
};
var originTransformOriginMapper = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
var useStyles = createStyles(function (theme) {
  return {
    backdrop: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      zIndex: theme.zIndex.dropdown - 1,
      position: 'fixed',
      touchAction: 'none',
      backgroundColor: 'transparent'
    },
    innerContent: {
      position: 'absolute',
      zIndex: theme.zIndex.dropdown
    }
  };
}, {
  name: 'PortalAutoPosition'
});
export var getPortalWidth = function getPortalWidth(isFit, contentOffsetWidth, parentWidth) {
  if (!isFit) {
    return;
  }

  return contentOffsetWidth >= parentWidth ? contentOffsetWidth : parentWidth;
};

var isInYViewPort = function isInYViewPort(offsetHeight) {
  return offsetHeight < window.scrollY + (window.innerHeight || document.documentElement.clientHeight);
};

var getWindowWidth = function getWindowWidth() {
  return window.innerWidth || document.documentElement.clientWidth;
};

export var getTransformDirection = function getTransformDirection(direction, anchor) {
  var isVertical = direction === OriginDirectionType.Left || direction === OriginDirectionType.Right;
  var transformX = anchorTransformOriginMapper[anchor];
  var originDirection = originTransformOriginMapper[direction];
  var anchorDirection = transformX;

  if (isVertical) {
    switch (anchor) {
      case AnchorDirectionType.End:
        anchorDirection = OriginDirectionType.Bottom;
        break;

      case AnchorDirectionType.Start:
        anchorDirection = OriginDirectionType.Top;
        break;

      default:
        break;
    }
  }

  return "".concat(originDirection, " ").concat(anchorDirection);
};
export var getAnchorDirection = function getAnchorDirection(anchorDirection, originDirection, anchorPosition, contentPosition) {
  var anchorLeft = anchorPosition.left,
      anchorTop = anchorPosition.top,
      anchorWidth = anchorPosition.width,
      anchorOffsetWidth = anchorPosition.offsetWidth,
      anchorOffsetHeight = anchorPosition.offsetHeight;
  var contentOffsetHeight = contentPosition.offsetHeight,
      contentOffsetWidth = contentPosition.offsetWidth;
  var direction = anchorDirection;
  var isVertical = originDirection === OriginDirectionType.Left || originDirection === OriginDirectionType.Right;
  var position = {};
  var inRightViewPort = anchorLeft + contentOffsetWidth <= getWindowWidth();
  var inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) >= 0;

  if (!inLeftViewPort && inRightViewPort) {
    direction = AnchorDirectionType.Start;
  }

  if (inLeftViewPort && !inRightViewPort) {
    direction = AnchorDirectionType.End;
  }

  if (!inLeftViewPort && !inRightViewPort) {
    direction = AnchorDirectionType.Center;
  }

  switch (direction) {
    case AnchorDirectionType.Center:
      position = {
        left: anchorLeft + anchorOffsetWidth / 2 - contentOffsetWidth / 2
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight / 2 + window.scrollY - contentOffsetHeight / 2
        };
      }

      break;

    case AnchorDirectionType.End:
      position = {
        left: anchorLeft - (contentOffsetWidth - anchorWidth)
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight - contentOffsetHeight + window.scrollY
        };
      }

      break;

    case AnchorDirectionType.Start:
      position = {
        left: anchorLeft
      };

      if (isVertical) {
        position = {
          top: anchorTop + window.scrollY
        };
      }

      break;

    default:
      break;
  }

  return {
    anchorDirection: direction,
    position: position
  };
};
export var getOriginDirection = function getOriginDirection(originDirection, anchorPosition, contentPosition) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var anchorTop = anchorPosition.top,
      anchorLeft = anchorPosition.left,
      anchorOffsetHeight = anchorPosition.offsetHeight,
      anchorOffsetWidth = anchorPosition.offsetWidth;
  var contentOffsetHeight = contentPosition.offsetHeight,
      contentOffsetWidth = contentPosition.offsetWidth;
  var direction = originDirection;
  var position = {};
  var inRightViewPort = offset + anchorLeft + anchorOffsetWidth + contentOffsetWidth < getWindowWidth();
  var inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) > offset;
  var inTopViewPort = anchorTop - contentOffsetHeight > offset;
  var inBottomViewPort = isInYViewPort(offset + anchorTop + window.scrollY + contentOffsetHeight);

  if (direction === OriginDirectionType.Top && !inTopViewPort) {
    direction = OriginDirectionType.Bottom;
  } else if (direction === OriginDirectionType.Bottom && !inBottomViewPort) {
    direction = OriginDirectionType.Top;
  }

  if (direction === OriginDirectionType.Left && !inLeftViewPort) {
    direction = OriginDirectionType.Right;
  } else if (direction === OriginDirectionType.Right && !inRightViewPort) {
    direction = OriginDirectionType.Left;
  }

  switch (direction) {
    case OriginDirectionType.Left:
      position = {
        left: anchorLeft - contentOffsetWidth - offset
      };
      break;

    case OriginDirectionType.Right:
      position = {
        left: anchorLeft + anchorOffsetWidth + offset
      };
      break;

    case OriginDirectionType.Top:
      position = {
        top: anchorTop - contentOffsetHeight + window.scrollY - offset
      };
      break;

    case OriginDirectionType.Bottom:
      position = {
        top: anchorTop + anchorOffsetHeight + window.scrollY + offset
      };
      break;

    default:
      break;
  }

  return {
    position: position,
    originDirection: direction
  };
};
var Popper = React.forwardRef(function PortalAutoPosition(_ref, ref) {
  var anchor = _ref.anchor,
      _ref$anchorDirection = _ref.anchorDirection,
      anchorDirection = _ref$anchorDirection === void 0 ? AnchorDirectionType.Start : _ref$anchorDirection,
      backdrop = _ref.backdrop,
      children = _ref.children,
      _ref$transition = _ref.transition,
      transition = _ref$transition === void 0 ? 'no-transition' : _ref$transition,
      trigger = _ref.trigger,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$originDirection = _ref.originDirection,
      originDirection = _ref$originDirection === void 0 ? OriginDirectionType.Top : _ref$originDirection,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? undefined : _ref$width,
      _ref$fitAnchor = _ref.fitAnchor,
      fitAnchor = _ref$fitAnchor === void 0 ? false : _ref$fitAnchor,
      props = _objectWithoutProperties(_ref, ["anchor", "anchorDirection", "backdrop", "children", "transition", "trigger", "offset", "originDirection", "width", "fitAnchor"]);

  var classes = useStyles();
  var contentRef = useRef(null);
  var controlRef = useRef();

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      position = _useState2[0],
      setPosition = _useState2[1];

  var getContentPositionStyles = useCallback(function () {
    var contentEl = contentRef.current;
    var anchorEl = anchor.current;

    var _ref2 = anchorEl || {},
        offsetHeight = _ref2.offsetHeight,
        offsetWidth = _ref2.offsetWidth;

    var _anchorEl$getBounding = anchorEl.getBoundingClientRect(),
        left = _anchorEl$getBounding.left,
        anchorWidth = _anchorEl$getBounding.width,
        top = _anchorEl$getBounding.top;

    var contentWidth = contentEl.width,
        contentOffsetWidth = contentEl.offsetWidth,
        contentOffsetHeight = contentEl.offsetHeight;

    var _getOriginDirection = getOriginDirection(originDirection, {
      top: top,
      left: left,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    }, offset),
        originPosition = _getOriginDirection.position,
        calculatedOriginDirection = _getOriginDirection.originDirection;

    var _getAnchorDirection = getAnchorDirection(anchorDirection, calculatedOriginDirection, {
      left: left,
      width: anchorWidth,
      offsetWidth: offsetWidth,
      top: top,
      offsetHeight: offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    }),
        anchorLeftPosition = _getAnchorDirection.position,
        calculatedAnchorDirection = _getAnchorDirection.anchorDirection;

    var transformOrigin = getTransformDirection(calculatedOriginDirection, calculatedAnchorDirection);
    controlRef.current = {
      contentOffsetHeight: contentOffsetHeight,
      anchorOffsetHeight: offsetHeight
    };
    return _extends({}, anchorLeftPosition, {}, originPosition, {
      transformOrigin: transformOrigin,
      width: width || getPortalWidth(fitAnchor, contentOffsetWidth, anchorWidth)
    });
  }, [contentRef, anchor, anchorDirection, originDirection, offset, fitAnchor]);
  useEffect(function () {
    if (!trigger) {
      return undefined;
    }

    if ((anchor === null || anchor === void 0 ? void 0 : anchor.current) && (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
      setPosition(getContentPositionStyles());
    }
  }, [trigger]);
  useEffect(function () {
    if (!trigger || !(contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
      return undefined;
    }

    var currentContentOffsetHeight = contentRef.current.offsetHeight;
    var currentAnchorOffsetHeight = anchor.current.offsetHeight;
    var _controlRef$current = controlRef.current,
        contentOffsetHeight = _controlRef$current.contentOffsetHeight,
        anchorOffsetHeight = _controlRef$current.anchorOffsetHeight;

    if (currentContentOffsetHeight !== contentOffsetHeight || currentAnchorOffsetHeight !== anchorOffsetHeight) {
      setPosition(getContentPositionStyles());
    }
  }, [children, anchor]);
  React.useEffect(function () {
    var handleResize = debounce(function () {
      if ((anchor === null || anchor === void 0 ? void 0 : anchor.current) && (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
        setPosition(getContentPositionStyles());
      }
    }, 250);
    window.addEventListener('resize', handleResize);
    return function () {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  return /*#__PURE__*/React.createElement(Portal, {
    ref: ref
  }, trigger && backdrop && /*#__PURE__*/React.createElement("div", {
    className: classes.backdrop
  }), /*#__PURE__*/React.createElement(CSSTransition, _extends({}, props, {
    unmountOnExit: true,
    animation: transition,
    show: trigger,
    style: _extends({}, position)
  }), /*#__PURE__*/React.createElement("span", {
    className: classes.innerContent,
    ref: contentRef
  }, children)));
});
Popper.propTypes = {
  /** Anchor element to append to */
  anchor: PropTypes.oneOfType([PropTypes.node, PropTypes.func, PropTypes.shape()]),

  /** Animation for css transition  - defaults to none */
  transition: PropTypes.oneOfType([PropTypes.shape({
    appear: PropTypes.string,
    appearActive: PropTypes.string,
    enter: PropTypes.string.isRequired,
    enterActive: PropTypes.string.isRequired,
    enterDone: PropTypes.string,
    exitActive: PropTypes.string.isRequired,
    exit: PropTypes.string.isRequired,
    exitDone: PropTypes.string
  }), PropTypes.string]),

  /** Child node for the auto position to reference and wrap */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.arrayOf(PropTypes.node)]).isRequired,

  /** Indicator when to re calculate the position */
  trigger: PropTypes.bool,

  /** Additional class to root level */
  className: PropTypes.string,

  /** Additional style to root level */
  style: PropTypes.shape(),

  /** Direction to open the content relative to anchor (center, end ,start) */
  anchorDirection: PropTypes.oneOf([AnchorDirectionType.Center, AnchorDirectionType.Start, AnchorDirectionType.End]),

  /** Direction to open the content relative to origin (Top bottom left right) */
  originDirection: PropTypes.oneOf([OriginDirectionType.Top, OriginDirectionType.Bottom, OriginDirectionType.Left, OriginDirectionType.Right]),

  /** Allow backdrop when showing portal */
  backdrop: PropTypes.bool,

  /** offset to locate the content from anchor */
  offset: PropTypes.number,

  /** Boolean flag to fix content width with anchor width - by default fits content width */
  fitAnchor: PropTypes.bool,

  /** Set content width manually - by default it will resolve to the larger of the input width or the content width */
  width: PropTypes.number
};
Popper.displayName = 'Popper';
export default Popper;