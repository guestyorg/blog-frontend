import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import React, { useEffect, useCallback, useRef } from 'react';
import PropTypes from 'prop-types';
import { createUseStyles } from 'react-jss';
import cn from 'classnames';
import VirtualizedTable from 'react-virtualized/dist/commonjs/Table/Table';
import Column from 'react-virtualized/dist/commonjs/Table/Column';
import InfiniteLoader from 'react-virtualized/dist/commonjs/InfiniteLoader';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import SortDirection from 'react-virtualized/dist/commonjs/Table/SortDirection';
import getCellRenderer from "./getCellRenderer";
import { grayLight } from "../../theme/colors";
const UNIT_SIZE = 5;

const units = size => UNIT_SIZE * size;

const useStyles = createUseStyles({
  table: {
    '& .ReactVirtualized__Table__row': {
      borderBottom: `1px solid ${grayLight}`,
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'center'
    },
    '& .ReactVirtualized__Table__headerRow': {
      borderBottom: `1px solid ${grayLight}`,
      fontWeight: 'normal',
      textTransform: 'uppercase',
      display: 'flex',
      alignItems: 'center'
    },
    '& .ReactVirtualized__Table__headerColumn:first-of-type, & .ReactVirtualized__Table__rowColumn:first-of-type ': {
      paddingLeft: units(2)
    },
    '& .ReactVirtualized__Table__headerColumn, & .ReactVirtualized__Table__rowColumn': {
      minWidth: 0,
      paddingRight: units(4),
      paddingLeft: units(4)
    },
    '& .ReactVirtualized__Table__headerTruncatedText': {
      display: 'inline-block',
      maxWidth: '100%',
      whiteSpace: 'nowrap',
      textOverflow: 'ellipsis',
      overflow: 'hidden'
    },
    '& .ReactVirtualized__Table__sortableHeaderColumn': {
      cursor: 'pointer'
    },
    '& .ReactVirtualized__Table__rowColumn': {
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap'
    },
    '& .ReactVirtualized__Table__rowColumn:last-child, ReactVirtualized__Table__headerColumn:last-child': {
      paddingRight: units(2)
    },
    '& .ReactVirtualized__Table__rowColumn.borderLeft': {
      borderLeft: `1px solid ${grayLight}`
    },
    '& .ReactVirtualized__Table__rowColumn.borderRight': {
      borderRight: `1px solid ${grayLight}`
    },
    '& .ReactVirtualized__Table__rowColumn.borderLeft, & .ReactVirtualized__Table__rowColumn.borderRight': {
      display: 'flex',
      alignItems: 'center',
      height: units(8)
    }
  }
});

const Table = (_ref) => {
  let {
    className,
    rowClassName,
    style,
    onSort,
    sortBy,
    sortDirection,
    hasNextPage,
    isLoading,
    onLoadNextPage,
    items,
    children,
    onRowOver,
    onRowOut,
    placeholderRowCount,
    pageSize
  } = _ref,
      restOfProps = _objectWithoutPropertiesLoose(_ref, ["className", "rowClassName", "style", "onSort", "sortBy", "sortDirection", "hasNextPage", "isLoading", "onLoadNextPage", "items", "children", "onRowOver", "onRowOut", "placeholderRowCount", "pageSize"]);

  const classes = useStyles();
  const ref = useRef(null);
  const promiseRef = useRef(null);
  const loadMoreRows = useCallback(() => {
    return isLoading ? null : new Promise(resolve => {
      promiseRef.current = resolve;
      onLoadNextPage();
    });
  }, [isLoading, onLoadNextPage]);
  const rowCount = hasNextPage ? Math.max(pageSize, items.length + placeholderRowCount) : items.length;
  const rowGetter = useCallback(({
    index
  }) => items[index] || {}, [items]);
  const isRowLoaded = useCallback(({
    index
  }) => !hasNextPage || index < items.length, [hasNextPage, items]);
  useEffect(() => {
    if (items.length === 0) {
      // Workaround to fix table not being re-rendered if data changed and scroll position is on top
      const forceRender = ref.current._lastRenderedStartIndex === 0;
      ref.current.resetLoadMoreRowsCache(forceRender);

      ref.current._registeredChild.scrollToRow(0);
    }
  }, [items]);
  useEffect(() => {
    if (!isLoading && promiseRef) {
      if (promiseRef.current) {
        promiseRef.current();
        promiseRef.current = null;
      }
    }
  }, [isLoading]);
  return /*#__PURE__*/React.createElement(InfiniteLoader, {
    ref: ref,
    rowCount: rowCount,
    loadMoreRows: loadMoreRows,
    isRowLoaded: isRowLoaded,
    "data-qa": "table"
  }, ({
    onRowsRendered,
    registerChild
  }) => /*#__PURE__*/React.createElement(AutoSizer, null, ({
    width,
    height
  }) => /*#__PURE__*/React.createElement(VirtualizedTable, _extends({
    className: cn(className, classes.table),
    style: style,
    ref: registerChild,
    onRowsRendered: onRowsRendered,
    headerClassName: "font-size-sm text-gray-dark",
    rowClassName: rowClassName,
    headerHeight: 50,
    rowHeight: 40,
    width: width,
    height: height,
    sort: onSort,
    sortBy: sortBy,
    sortDirection: sortDirection,
    rowCount: rowCount,
    onRowMouseOver: onRowOver,
    onRowMouseOut: onRowOut,
    rowGetter: rowGetter
  }, restOfProps), React.Children.map(children, child => {
    const _child$props = child.props,
          {
      borderLeft,
      borderRight,
      placeholder,
      cellRenderer,
      headerRenderer,
      className: columnClassName
    } = _child$props,
          rest = _objectWithoutPropertiesLoose(_child$props, ["borderLeft", "borderRight", "placeholder", "cellRenderer", "headerRenderer", "className"]);

    return /*#__PURE__*/React.createElement(Column, _extends({}, rest, {
      className: cn('font-size-md', columnClassName, {
        borderLeft,
        borderRight
      }),
      headerRenderer: headerRenderer,
      cellRenderer: getCellRenderer({
        isLoading,
        placeholder,
        cellRenderer
      })
    }));
  }))));
};

Table.defaultProps = {
  className: '',
  style: {},
  sortBy: '',
  placeholderRowCount: 3,
  pageSize: 40
};
Table.propTypes = {
  /** Additional class name */
  className: PropTypes.string,

  /**	Additional style for table element  */
  style: PropTypes.shape(),

  /** Sort function called when you click on the headers */
  onSort: PropTypes.func,

  /** Sort key, should be the same as current sort column dataKey */
  sortBy: PropTypes.string,

  /** Sort direction: ASC, DESC */
  sortDirection: PropTypes.oneOf([SortDirection.ASC, SortDirection.DESC]),

  /** boolean indicating if there is a next page */
  hasNextPage: PropTypes.bool,

  /** function invoked automatically to fetch more data */
  onLoadNextPage: PropTypes.func.isRequired,

  /** Items array repesenting the data */
  items: PropTypes.arrayOf(PropTypes.object).isRequired,

  /** How many extra rows to render as placeholders at the end of the table */
  placeholderRowCount: PropTypes.number,

  /** How many placeholders to show on initial load */
  pageSize: PropTypes.number,

  /** Event for row over */
  onRowOver: PropTypes.func
};
export default Table;