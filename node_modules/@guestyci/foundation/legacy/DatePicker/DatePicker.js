"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.DatePickerComponent = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = _interopRequireWildcard(require("react"));

require("react-dates/initialize");

var _moment = _interopRequireDefault(require("moment"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _isObject = _interopRequireDefault(require("lodash/isObject"));

var _has = _interopRequireDefault(require("lodash/has"));

var _reactJss = _interopRequireDefault(require("react-jss"));

var _constants = require("react-dates/lib/constants");

var _memoize = _interopRequireDefault(require("@guestyci/memoize"));

var _commonUtility = require("../../utils/commonUtility");

var _enums = require("../../enums/enums");

var _RangePicker = _interopRequireDefault(require("./RangePicker"));

var _SinglePicker = _interopRequireDefault(require("./SinglePicker"));

var _ActionButton = _interopRequireDefault(require("../ActionButton"));

var _colors = require("../../theme/colors");

var _DatePickerNavButton = _interopRequireDefault(require("./DatePickerNavButton"));

var _IconButton = _interopRequireDefault(require("../IconButton/IconButton"));

var _FlatButton = _interopRequireDefault(require("../FlatButton/FlatButton"));

var _Fade = _interopRequireDefault(require("../Fade"));

var _Row = _interopRequireDefault(require("../Row"));

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BtnDelete = function BtnDelete(props) {
  return /*#__PURE__*/_react["default"].createElement("svg", props, /*#__PURE__*/_react["default"].createElement("path", {
    d: "M8.485.707L7.778 0 4.243 3.536.707 0 0 .707l3.536 3.536L0 7.778l.707.707L4.243 4.95l3.535 3.535.707-.707L4.95 4.243z"
  }));
};

BtnDelete.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 8.4854 8.4854"
};
var DATE_FORMAT = 'YYYY-MM-DD';
var containerSize = 46;
var styles = {
  container: {
    background: 'white',
    width: '100%',
    height: containerSize,
    display: 'flex',
    justifyContent: 'space-between',
    border: "1px solid ".concat(_colors.grayLight),
    borderRadius: 2
  },
  iconContainer: {
    height: 44,
    borderLeft: "1px solid ".concat(_colors.grayLight),
    borderTop: '0px',
    borderBottom: '0px',
    borderRight: '0px'
  },
  dateInputWrapper: {
    flex: 1,
    width: 'calc(100% - 85px)',
    display: 'flex',
    alignItems: 'center'
  }
};

var falseFunc = function falseFunc() {
  return false;
};

var renderMonthElement = function renderMonthElement(_ref) {
  var month = _ref.month;
  return /*#__PURE__*/_react["default"].createElement("span", {
    "data-qa": "render-month-element"
  }, month.format('MMMM YYYY'));
};

var isEqualValue = function isEqualValue(type, newValue, currentValue) {
  if (type === _enums.DatePickerType.Single) {
    return (0, _moment["default"])(newValue).isSame(currentValue);
  }

  var sameStart = newValue.start === currentValue.startDate || (0, _moment["default"])(newValue.start).isSame(currentValue.startDate);
  var sameEnd = newValue.end === currentValue.endDate || (0, _moment["default"])(newValue.end).isSame(currentValue.endDate);
  return sameStart && sameEnd;
};

var isEqualDefaultValue = function isEqualDefaultValue(type, newValue, currentValue) {
  if (type === _enums.DatePickerType.Single) {
    return (0, _moment["default"])(newValue).isSame(currentValue);
  }

  return (0, _moment["default"])(newValue.start).isSame(currentValue.start) && (0, _moment["default"])(newValue.end).isSame(currentValue.end);
};

var openDirections = {
  Down: 'down',
  Up: 'up'
};

var DatePicker = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(DatePicker, _Component);

  var _super = _createSuper(DatePicker);

  function DatePicker(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, DatePicker);
    _this = _super.call(this, props);

    _this.setValues = function () {
      var _this$props = _this.props,
          value = _this$props.value,
          defaultValue = _this$props.defaultValue,
          type = _this$props.type;

      _this.setState(_this.setInitialValues(type, value || defaultValue));
    };

    _this.onFocus = function (focus) {
      var _this$props2 = _this.props,
          type = _this$props2.type,
          onFocusChange = _this$props2.onFocusChange;
      var focusItem = focus;

      if (focusItem && focusItem.currentTarget) {
        focusItem = type === _enums.DatePickerType.Range ? _constants.START_DATE : true;
      } else if ((0, _isObject["default"])(focus)) {
        focusItem = focus.focused;
      }

      _this.setState({
        isFocused: !!focusItem,
        focused: focusItem,
        clicked: true
      });

      if (onFocusChange) {
        onFocusChange(focusItem);
      }
    };

    _this.onDatesChange = function (_ref2) {
      var startDate = _ref2.startDate,
          endDate = _ref2.endDate;
      var _this$props3 = _this.props,
          onChange = _this$props3.onChange,
          blockedDates = _this$props3.blockedDates,
          isAvailability = _this$props3.isAvailability,
          id = _this$props3.id,
          name = _this$props3.name;
      var focused = _this.state.focused;
      var blockedArray = Object.keys(blockedDates).sort();
      var blockedEndDay = blockedArray[blockedArray.length - 1];
      var blockedStartDay = blockedArray[0];
      var _endDate = endDate;

      if (focused === _constants.START_DATE && endDate) {
        _endDate = null;
      }

      _this.setState({
        startDate: startDate,
        endDate: _endDate
      });

      onChange({
        start: startDate,
        end: _endDate
      }, id || name);

      if (isAvailability) {
        if (startDate && _endDate || !startDate && !_endDate) {
          return;
        }

        if (!_endDate && startDate.isBefore(blockedEndDay)) {
          _this.boundaries.end = blockedArray.find(function (blockedDay) {
            return (0, _moment["default"])(blockedDay).isAfter(startDate);
          });
        } else if (!startDate && _endDate.isAfter(blockedStartDay)) {
          var closestBlocked = blockedArray.reverse().find(function (blockedDay) {
            return (0, _moment["default"])(blockedDay).isBefore(_endDate);
          });
          _this.boundaries.start = (0, _moment["default"])(closestBlocked).add(1, 'days');
        }
      }
    };

    _this.onDateChange = function (date) {
      var _this$props4 = _this.props,
          onChange = _this$props4.onChange,
          id = _this$props4.id,
          name = _this$props4.name;

      _this.setState({
        date: date
      });

      onChange(date, id || name);
    };

    _this.onMonthChange = function (month) {
      var start = (0, _moment["default"])(month).startOf('month').format(DATE_FORMAT);
      var end = (0, _moment["default"])(month).endOf('month').format(DATE_FORMAT);
      var _this$state = _this.state,
          startDate = _this$state.startDate,
          endDate = _this$state.endDate;
      var _this$props5 = _this.props,
          blockedDates = _this$props5.blockedDates,
          onMonthChange = _this$props5.onMonthChange;
      var startDay = startDate && startDate.isBefore(start) ? startDate.format(DATE_FORMAT) : start;
      var endDay = endDate && endDate.isAfter(end) ? endDate.format(DATE_FORMAT) : end;

      if ((!blockedDates[startDay] || !blockedDates[endDay]) && onMonthChange) {
        onMonthChange(start, end);
      }
    };

    _this.setInitialValues = function (type, value) {
      if (type === _enums.DatePickerType.Single) {
        return {
          date: value ? (0, _moment["default"])(value) : null
        };
      }

      return {
        startDate: (0, _isObject["default"])(value) && value.start ? (0, _moment["default"])(value.start) : null,
        endDate: (0, _isObject["default"])(value) && value.end ? (0, _moment["default"])(value.end) : null,
        clicked: !!((0, _isObject["default"])(value) && (value.start || value.end))
      };
    };

    _this.getComponentIds = (0, _memoize["default"])(function (_ref3) {
      var id = _ref3.id,
          startDateId = _ref3.startDateId,
          endDateId = _ref3.endDateId;
      return {
        id: id || "date_".concat((0, _commonUtility.uuid)()),
        startDateId: startDateId || "start-date-id_".concat((0, _commonUtility.uuid)()),
        endDateId: endDateId || "end-date-id_".concat((0, _commonUtility.uuid)())
      };
    });

    _this.getTooltipByType = function (type) {
      return "Select ".concat(type === _enums.DatePickerType.Single ? 'a date' : 'dates');
    };

    _this.initialVisibleMonth = function () {
      var initialVisibleMonth = _this.props.initialVisibleMonth;
      var _this$state2 = _this.state,
          startDate = _this$state2.startDate,
          endDate = _this$state2.endDate,
          focused = _this$state2.focused;

      if (focused === _constants.START_DATE) {
        if (startDate) {
          return (0, _moment["default"])(startDate);
        }

        if (endDate) {
          return (0, _moment["default"])(endDate);
        }
      } else if (focused === _constants.END_DATE) {
        if (endDate) {
          return (0, _moment["default"])(endDate);
        }

        if (startDate) {
          return (0, _moment["default"])(startDate);
        }
      }

      return initialVisibleMonth ? (0, _moment["default"])(initialVisibleMonth) : (0, _moment["default"])();
    };

    _this.isDayBlocked = function (date) {
      var _this$state3 = _this.state,
          focused = _this$state3.focused,
          endDate = _this$state3.endDate,
          startDate = _this$state3.startDate;
      var _this$props6 = _this.props,
          blockedDates = _this$props6.blockedDates,
          isFetching = _this$props6.isFetching;
      var day = date.format('YYYY-MM-DD');

      if (isFetching) {
        return true;
      }

      if (!startDate || !endDate || focused === _constants.END_DATE) {
        if (focused === _constants.END_DATE && _this.boundaries.end) {
          return (0, _moment["default"])(date.format(DATE_FORMAT)).isAfter(_this.boundaries.end) || (0, _moment["default"])(date.format(DATE_FORMAT)).isBefore(startDate);
        }

        if (focused === _constants.START_DATE && _this.boundaries.start) {
          return date.startOf('day').isBefore(_this.boundaries.start) || (0, _moment["default"])(date.format(DATE_FORMAT)).isAfter(endDate);
        }
      }

      _this.blockedDates[day] = day in blockedDates ? blockedDates[day] : _this.blockedDates[day];
      return _this.blockedDates[day];
    };

    _this.clearDates = function () {
      var type = _this.props.type;

      _this.setState({
        startDate: null,
        endDate: null,
        date: null,
        clicked: false
      });

      _this.boundaries.start = null;
      _this.boundaries.end = null;

      if (type === _enums.DatePickerType.Range) {
        _this.onDatesChange({
          startDate: null,
          endDate: null
        });
      } else {
        _this.onDateChange(null);
      }
    };

    _this.renderDayContents = function (date) {
      var isFetching = _this.props.isFetching;

      if (isFetching) {
        return /*#__PURE__*/_react["default"].createElement("span", {
          className: "flex-center text-muted letter-spacing-2"
        }, "...");
      }

      return date.date();
    };

    _this.renderCalendarIcon = function () {
      var _this$props7 = _this.props,
          classes = _this$props7.classes,
          type = _this$props7.type,
          id = _this$props7.id,
          disabled = _this$props7.disabled,
          asLabel = _this$props7.asLabel,
          datepickerIcon = _this$props7.datepickerIcon;
      var isFocused = _this.state.isFocused;
      return /*#__PURE__*/_react["default"].createElement(_ActionButton["default"], {
        className: (0, _classnames["default"])('b-0 zindex-10', classes.iconContainer, {
          'asLabel-iconContainer border-0 icon-left': asLabel,
          'icon-right': !asLabel
        }),
        tooltip: _this.getTooltipByType(type),
        onClick: _this.onFocus,
        id: id,
        icon: datepickerIcon,
        disabled: disabled,
        iconColor: isFocused ? 'blue' : 'gray-dark'
      });
    };

    var _value = props.value,
        _defaultValue = props.defaultValue,
        _type = props.type,
        _isAvailability = props.isAvailability,
        _onMonthChange = props.onMonthChange,
        _blockedDates = props.blockedDates;
    _this.state = (0, _extends2["default"])({}, _this.setInitialValues(_type, _value || _defaultValue), {
      clicked: !!(_value || _defaultValue),
      openDirection: openDirections.Down
    });
    _this.fieldElement = _react["default"].createRef();
    _this.blockedDates = {};
    _this.boundaries = {
      start: null,
      end: null
    };

    if (_isAvailability) {
      if (!_onMonthChange) {
        throw new Error('onMonthChange required with isAvailability');
      }

      if ((0, _has["default"])(_value, 'start')) {
        var blockedArray = Object.keys(_blockedDates).sort();
        _this.boundaries.end = blockedArray.find(function (blockedDay) {
          return (0, _moment["default"])(blockedDay).isAfter(_value.start);
        });
      }
    }

    return _this;
  }

  (0, _createClass2["default"])(DatePicker, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props8 = this.props,
          type = _this$props8.type,
          value = _this$props8.value,
          defaultValue = _this$props8.defaultValue;
      var _this$state4 = this.state,
          date = _this$state4.date,
          startDate = _this$state4.startDate,
          endDate = _this$state4.endDate,
          isFocused = _this$state4.isFocused;

      if (isFocused) {
        this.inViewport();
      }

      if (value && !isEqualValue(type, value, date || {
        startDate: startDate,
        endDate: endDate
      })) {
        this.setValues();
      }

      if (defaultValue && !isEqualDefaultValue(type, defaultValue, prevProps.defaultValue)) {
        this.setValues();
      }
    }
  }, {
    key: "inViewport",
    value: function inViewport() {
      var openDirection = this.state.openDirection;
      if (!this.fieldElement.current) return;
      var rect = this.fieldElement.current.getBoundingClientRect();
      var openDirectionValue = rect.top > window.innerHeight - rect.bottom ? openDirections.Up : openDirections.Down;

      if (openDirection !== openDirectionValue) {
        this.setState({
          openDirection: openDirectionValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props9 = this.props,
          id = _this$props9.id,
          classes = _this$props9.classes,
          className = _this$props9.className,
          style = _this$props9.style,
          type = _this$props9.type,
          enablePastDays = _this$props9.enablePastDays,
          focus = _this$props9.focus,
          sm = _this$props9.sm,
          disabled = _this$props9.disabled,
          anchorDirection = _this$props9.anchorDirection,
          showClearDate = _this$props9.showClearDate,
          appendToBody = _this$props9.appendToBody,
          asLabel = _this$props9.asLabel,
          iconPosition = _this$props9.iconPosition,
          startDatePlaceholderText = _this$props9.startDatePlaceholderText,
          endDatePlaceholderText = _this$props9.endDatePlaceholderText,
          asLabelPlaceholderText = _this$props9.asLabelPlaceholderText,
          renderCalendarIcon = _this$props9.renderCalendarIcon,
          startDateId = _this$props9.startDateId,
          endDateId = _this$props9.endDateId;
      var propsForPicker = {
        prevMonthButton: /*#__PURE__*/_react["default"].createElement(_DatePickerNavButton["default"], {
          direction: "Left",
          sm: sm,
          type: type
        }),
        nextMonthButton: /*#__PURE__*/_react["default"].createElement(_DatePickerNavButton["default"], {
          direction: "Right",
          sm: sm,
          type: type
        }),
        renderMonthElement: renderMonthElement,
        verticalSpacing: type === _enums.DatePickerType.Single ? 4 : 10,
        readOnly: true,
        daySize: type === _enums.DatePickerType.Single || sm ? 40 : 50,
        numberOfMonths: type === _enums.DatePickerType.Single || sm ? 1 : 2,
        appendToBody: appendToBody
      };

      if (enablePastDays) {
        propsForPicker.isOutsideRange = falseFunc;
      }

      var _this$state5 = this.state,
          startDate = _this$state5.startDate,
          endDate = _this$state5.endDate,
          date = _this$state5.date,
          focused = _this$state5.focused,
          clicked = _this$state5.clicked,
          openDirection = _this$state5.openDirection;
      var shouldRenderClearDate = !!(date || startDate || endDate);
      var elemIds = this.getComponentIds({
        id: id,
        startDateId: startDateId,
        endDateId: endDateId
      });
      return /*#__PURE__*/_react["default"].createElement(_Row["default"], {
        className: (0, _classnames["default"])('relative', {
          sm: sm
        }, 'flex-start-center', 'date-picker', className, classes.container, {
          asLabel: asLabel
        }),
        style: style,
        "data-qa": "date-picker"
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: (0, _classnames["default"])(classes.dateInputWrapper, {
          'asLabel-dateInputWrapper': asLabel,
          'asLabel-dateInputWrapper_disabled': !clicked && asLabel
        }),
        ref: this.fieldElement
      }, renderCalendarIcon && iconPosition === 'left' && this.renderCalendarIcon(), asLabel && !shouldRenderClearDate && !clicked && /*#__PURE__*/_react["default"].createElement(_FlatButton["default"], {
        className: "label-placeholder",
        onClick: this.onFocus
      }, asLabelPlaceholderText), type === _enums.DatePickerType.Range && /*#__PURE__*/_react["default"].createElement(_RangePicker["default"], (0, _extends2["default"])({}, this.props, propsForPicker, {
        disabled: disabled,
        startDate: startDate,
        startDateId: elemIds.startDateId,
        endDateId: elemIds.endDateId,
        endDate: endDate,
        focusedInput: focused,
        onFocus: this.onFocus,
        renderDayContents: function renderDayContents(day) {
          return _this2.renderDayContents(day);
        },
        onDatesChange: this.onDatesChange,
        isDayBlocked: function isDayBlocked(day) {
          return _this2.isDayBlocked(day);
        },
        onMonthChange: this.onMonthChange,
        initialVisibleMonth: this.initialVisibleMonth,
        anchorDirection: anchorDirection,
        openDirection: openDirection,
        asLabel: asLabel,
        startDatePlaceholderText: startDatePlaceholderText,
        endDatePlaceholderText: endDatePlaceholderText
      })), type === _enums.DatePickerType.Single && /*#__PURE__*/_react["default"].createElement(_SinglePicker["default"], (0, _extends2["default"])({}, this.props, propsForPicker, {
        id: elemIds.id,
        disabled: disabled,
        date: date,
        onFocusChange: this.onFocus,
        isFocused: focus || !!focused,
        onDateChange: this.onDateChange,
        renderDayContents: function renderDayContents(day) {
          return _this2.renderDayContents(day);
        },
        isDayBlocked: function isDayBlocked(day) {
          return _this2.isDayBlocked(day);
        },
        initialVisibleMonth: this.initialVisibleMonth,
        anchorDirection: anchorDirection,
        openDirection: openDirection
      }))), showClearDate && shouldRenderClearDate && /*#__PURE__*/_react["default"].createElement(_Fade["default"], {
        show: shouldRenderClearDate,
        className: "datepicker-clear mb-1"
      }, /*#__PURE__*/_react["default"].createElement(_IconButton["default"], {
        onClick: this.clearDates,
        svg: BtnDelete,
        iconHeight: 10,
        iconWidth: 10
      })), renderCalendarIcon && iconPosition === 'right' && this.renderCalendarIcon());
    }
  }]);
  return DatePicker;
}(_react.Component);

DatePicker.defaultProps = {
  type: _enums.DatePickerType.Single,
  isAvailability: false,
  minimumNights: 1,
  blockedDates: {},
  disabled: false,
  initialVisibleMonth: null,
  value: undefined,
  defaultValue: undefined,
  onMonthChange: null,
  enablePastDays: false,
  focus: false,
  onFocusChange: null,
  sm: true,
  isFetching: false,
  anchorDirection: 'left',
  id: undefined,
  showClearDate: true,
  appendToBody: false,
  iconPosition: 'right',
  renderCalendarIcon: true,
  startDatePlaceholderText: 'Start date',
  endDatePlaceholderText: 'End date',
  startDateId: undefined,
  endDateId: undefined,
  datepickerIcon: 'BtnCalendar'
};
DatePicker.propTypes = {
  /** Id for date picker */
  id: _propTypes["default"].string,

  /** Picker type single/range */
  type: _propTypes["default"].oneOf(Object.values(_enums.DatePickerType)),

  /** Minimium Nights, 0 to allow single day range */
  minimumNights: _propTypes["default"].number,

  /** Boolean - if it's avalibilty picker or regular picker (without blocked days) */
  isAvailability: _propTypes["default"].bool,

  /** unavailable object structure :
   *  {
   *   '2018-01-01': true,
   *    '2018-06-01': true,
   *    ...
   *  } */
  blockedDates: _propTypes["default"].object,
  // eslint-disable-line react/forbid-prop-types

  /** Boolean - disable the date input */
  disabled: _propTypes["default"].bool,

  /** Set the initial month for the date picker */
  initialVisibleMonth: _propTypes["default"].oneOfType([_propTypes["default"].instanceOf(Date), _propTypes["default"].string]),

  /** Render position of the calendar icon */
  iconPosition: _propTypes["default"].string,

  /** Conditional boolean for rendering range-picker input as label */
  asLabel: _propTypes["default"].bool,

  /** initial value for date range picker - date - for single - {start, end } for range */
  value: _propTypes["default"].oneOfType([_propTypes["default"].instanceOf(Date), _propTypes["default"].string, _propTypes["default"].shape()]),

  /** initial value for date range picker - date - for single - {start, end } for range */
  defaultValue: _propTypes["default"].oneOfType([_propTypes["default"].instanceOf(Date), _propTypes["default"].string, _propTypes["default"].shape()]),

  /** A request to fetch the availability for star - end period (start, end) => {} */
  onMonthChange: _propTypes["default"].func,

  /** callback when dates change : Range:  ({start, end})  Single: (date) */
  onChange: _propTypes["default"].func.isRequired,

  /** Boolean - if should enable select past days */
  enablePastDays: _propTypes["default"].bool,

  /** if input is focused (open picker) for single picker */
  focus: _propTypes["default"].bool,

  /** focus change callback */
  onFocusChange: _propTypes["default"].func,

  /** Set picker mode, sm or md  to determine the amount of months presented in the picker */
  sm: _propTypes["default"].bool,

  /** Indicator whether or not we are fetching availability */
  isFetching: _propTypes["default"].bool,

  /** Set which direction the drop down will open options: [left|right]  */
  anchorDirection: _propTypes["default"].string,

  /** Indicator whether or not we are displaying clear button  */
  showClearDate: _propTypes["default"].bool,

  /** Boolean - prevent the cut off when the picker inside dialog */
  appendToBody: _propTypes["default"].bool,

  /** Render calendar icon bool */
  renderCalendarIcon: _propTypes["default"].bool,

  /** Placeholder for start date */
  startDatePlaceholderText: _propTypes["default"].string,

  /** Placeholder for end date */
  endDatePlaceholderText: _propTypes["default"].string,

  /** Id for start date input and label */
  startDateId: _propTypes["default"].string,

  /** Id for end date input and label */
  endDateId: _propTypes["default"].string,

  /** Icon to display */
  datepickerIcon: _propTypes["default"].string
};
/** Work around to fix storybook HOC propTypes bug  - DO NOT IMPORT THIS */

var DatePickerComponent = DatePicker;
exports.DatePickerComponent = DatePickerComponent;

var _default = (0, _reactJss["default"])(styles)(DatePicker);

exports["default"] = _default;