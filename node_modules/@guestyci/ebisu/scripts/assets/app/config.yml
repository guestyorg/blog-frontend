version: 2.1
orbs:
  slack: circleci/slack@2.5.1
  jq: circleci/jq@1.9.0

defaults: &defaults
  working_directory: ~/app
  docker:
    - image: 'circleci/node:12.16.3'

tags_filter: &tags_filter
  tags:
    only: /.*-rc.([0-9a-zA-Z-]+)/

master_filter: &master_filter
  branches:
    only: master

commands:
  deploy_s3:
    description: 'Deploy to s3 command'
    parameters:
      to:
        type: string
      branch:
        type: string
    steps:
      - restore_cache:
          name: Restore Yarn package cache
          keys:
            - yarn-packages-{{ checksum "yarn.lock" }}

      - run: |
          cd ~/app/build && ls -la
      - run:
          name: 'Deploying Bundle'
          command: >
            CLUSTER=<< parameters.to >>
            REPO_NAME=$CIRCLE_PROJECT_REPONAME
            AWS_ACCESS_KEY=${AWS_ACCESS_KEY}
            AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
            COMMIT=$CIRCLE_SHA1
            yarn ebisu deploy-s3

  invalidate_cf_index:
    description: 'Invalidate Cloudfront index.html cache'
    steps:
      - run:
          name: 'Invalidating Cache'
          command: >
            CALLER_REFERENCE="CircleCI-${CIRCLE_BUILD_NUM}-`date +%s%N`"
            yarn ebisu invalidate-cf-index

  invalidate_cf_manifest:
    description: 'Invalidate Cloudfront asset-manifest cache'
    steps:
      - run:
          name: 'Invalidating Cache'
          command: >
            CALLER_REFERENCE="CircleCI-${CIRCLE_BUILD_NUM}-`date +%s%N`"
            yarn ebisu invalidate-cf-manifest

  install_deps:
    description: 'Install dependancies'
    steps:
      - run:
          command: echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > ~/.npmrc

      - restore_cache:
          name: Restore Yarn package cache
          keys:
            - yarn-packages-{{ checksum "yarn.lock" }}
      - run:
          name: 'Installing Yarn Pacakges'
          command: yarn install --frozen-lockfile

      - save_cache:
          name: Save Yarn package cache
          key: yarn-packages-{{ checksum "yarn.lock" }}
          paths:
            - ./node_modules
            - ~/.cache/yarn

  deploy_firebase:
    description: 'Deploy to firebase command'
    parameters:
      app_name:
        type: string
      to:
        type: string

    steps:
      - restore_cache:
          name: Restore Yarn package cache
          keys:
            - yarn-packages-{{ checksum "yarn.lock" }}
      - run: |
          ls -la

      - run: |
          cd ~/app/build && ls -la

      - run:
          name: 'Deploying Bundle'
          command: |
            GIT_COMMIT=${CIRCLE_SHA1} REPO_NAME=$CIRCLE_PROJECT_REPONAME BRANCH=${CIRCLE_BRANCH} CLUSTER=<< parameters.to >> FIREBASE_APP=<< parameters.app_name >> yarn ebisu deploy-firebase

  save-partial-coverage-report:
    description: |
      Saves a single possibly partial coverage report by adding it to the
      workspace. This way different CircleCI jobs can run parts of the tests
      and save their results to be merged later.
    parameters:
      coverage-filename:
        type: string
        default: coverage/coverage-final.json
        description: |
          Path to the final coverage JSON file produced by "nyc" tool.
          Typically called "coverage/coverage-final.json"
      label:
        type: string
        default: default
        description: |
          Human name for the coverage file. For example, when saving both Cypress
          and Jest coverage file, use "e2e" and "unit" to have distinct filenames.
    steps:
      - run:
          name: Store partial coverage result
          command: |
            mkdir coverage-part || true
            cp <<parameters.coverage-filename>> coverage-part/coverage-<<parameters.label>>-$CIRCLE_NODE_INDEX.json || true
            ls -la coverage-part
      - persist_to_workspace:
          root: .
          paths:
            - coverage-part

  merge-coverage-reports:
    description: |
      Merges individual code coverage files using "nyc" tool
      https://github.com/istanbuljs/nyc.
      All individual files should be in the folder "coverage-part"
    steps:
      - run:
          name: Merge coverages
          command: |
            ls -la .
            ls -la coverage-part || true
            npx nyc merge coverage-part
            ls -la coverage-part
      - run:
          name: Move merged file to nyc folder
          # storing the combined report in ".nyc_output/out.json"
          # allows other NYC commands to find it right away
          command: |
            mkdir .nyc_output || true
            mv coverage.json .nyc_output/out.json
            ls -la .nyc_output
      - run:
          name: Generate coverage report
          command: |
            npx nyc report --reporter lcov --reporter text-summary --reporter json-summary --report-dir coverage
            ls -la coverage

jobs:
  align_inventory:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/app
      - run:
          name: 'Create deploy config'
          command: |
            deploy_meta="deploy.conf"
            touch $deploy_meta
            source conf.env
            echo "export CLUSTER=$ENV_CLUSTER" >> $BASH_ENV
      - run:
          name: 'Checking and Updating manifest'
          command: >
            AUTH_TOKEN=${GITHUB_AUTH_TOKEN}
            PLATFORM_FE_SLACK_WEBHOOK=${PLATFORM_FE_SLACK_WEBHOOK}
            REPO_NAME=$CIRCLE_PROJECT_REPONAME
            CLUSTER=$CLUSTER
            WORKFLOW_ID=$CIRCLE_WORKFLOW_ID
            CIRCLE_TAG=${CIRCLE_TAG}
            CIRCLE_BRANCH=${CIRCLE_BRANCH}
            yarn ebisu update-manifest

      - persist_to_workspace:
          root: .
          paths:
            - deploy.conf

  update_imdb:
    description: 'Set up vpn connection for jenkins'
    machine:
      image: ubuntu-1604:202004-01
    steps:
      - attach_workspace:
          at: ~/app
      - run:
          name: Check if update is needed or finish
          command: |
            cd ~/app
            deploy_meta="deploy.conf"
            if [[ ! -s $deploy_meta ]] ; then
              echo "No Imdb change needed. Ending job."
              circleci-agent step halt
            else
              echo "Continuing with securing VPN for jenkins update"
            fi ;

      - run:
          name: Install OpenVPN
          command: |
            sudo apt-get update
            sudo apt-get install openvpn -y
      - run:
          name: Check IP before VPN connection
          command: |
            ifconfig
            route -n
            sudo netstat -anp
            cat /etc/resolv.conf
            curl checkip.amazonaws.com
      - run:
          name: VPN Setup
          background: true
          command: |
            phone_home=$(netstat -an | grep ':22 .*ESTABLISHED' | head -n1 | awk '{ split($5, a, ":"); print a[1] }')
            echo $phone_home
            echo $VPN_CLIENT_CONFIG | base64 --decode > /tmp/config.ovpn
            printf "$VPN_USER\n$VPN_PASSWORD" > /tmp/vpn.login
            sudo openvpn --config /tmp/config.ovpn --auth-user-pass /tmp/vpn.login \
              --route $phone_home 255.255.255.255 net_gateway \
              --route 169.254.0.0 255.255.0.0 net_gateway
      - run:
          name: Wait for the connection to be established
          command: sleep 30
      - run:
          name: Check IP after VPN connection
          command: |
            ifconfig
            route -n
            sudo netstat -anp
            cat /etc/resolv.conf
            curl checkip.amazonaws.com
      - run: |
          source ~/app/deploy.conf
          curl  -X POST -u $JENKINS_API_USER:$JENKINS_API_KEY "https://jenkinsci.guesty.com/job/IMDB-deploy-XY/buildWithParameters?x=$x&y=$y&sha=$CIRCLE_SHA1&branch=$branch&username=$CIRCLE_USERNAME"
      - run:
          name: Disconnect from OpenVPN
          command: sudo killall openvpn || true
          when: always

  checkout_environment:
    <<: *defaults
    steps:
      - checkout
      - install_deps

      - persist_to_workspace:
          root: .
          paths: .

  setup:
    <<: *defaults
    steps:
      - checkout
      - jq/install
      - run:
          name: 'Create config file from branch'
          command: |
            filename="conf.env"

            if [[ ${CIRCLE_BRANCH} == "master" ]]
            then
              echo "ENV_API=//groot-mailer.production.guesty.com" >> $filename
              echo "ENV_CLUSTER=production" >> $filename

              deployDestination=$(cat .circleci/config.json | jq -r '.destinations.production')

              if [[ -z $deployDestination ]] || [[ $deployDestination == null  ]]
              then
                echo "FIREBASE_APP=$FIREBASE_APP_NAME-prod" >> $filename
              else
                echo "FIREBASE_APP=$deployDestination" >> $filename
              fi

              cat "$filename"
              exit 0
            fi

            regex="([0-9a-zA-Z/-]+)--([0-9a-zA-Z-]+)-rc\.([0-9a-zA-Z-]+)"

            if [[ ${CIRCLE_TAG} =~ $regex ]]
            then
                cluster=${BASH_REMATCH[3]}
                branch=${BASH_REMATCH[1]}

                if [[ "$cluster" == "production" ]] || [[ "$cluster" == "prod" ]]
                then
                  echo "Cluster cannot be production on feature branch"
                  exit 1
                fi

                config_path=".destinations.$cluster";
                deployDestination=$(cat .circleci/config.json | jq -r $config_path)

                if [[ -z $deployDestination ]] || [[ $deployDestination == null  ]]
                then
                  echo "FIREBASE_APP=$FIREBASE_APP_NAME-$cluster" >> "$filename"
                else
                  echo "FIREBASE_APP=$deployDestination" >> $filename
                fi

                echo "ENV_API=https://mailer.$cluster.guesty.com" >> $filename
                echo "ENV_CLUSTER=$cluster" >> "$filename"
                echo "BRANCH_NAME=$branch" >> "$filename"
                cat "$filename"

            else
              echo "Could not match version"
              exit 1
            fi

      - persist_to_workspace:
          root: .
          paths:
            - conf.env

  build:
    <<: *defaults
    steps:
      - attach_workspace:
          at: ~/app

      - run:
          name: 'Get env vars from conf'
          command: |
            source conf.env
            echo "export REACT_APP_BASE_ORIGIN=$ENV_API" >> $BASH_ENV

      - run:
          name: 'Building bundle'
          command: >
            REACT_APP_BASE_ORIGIN=$REACT_APP_BASE_ORIGIN
            CI=false
            PUBLIC_URL=__PUBLIC_URL__
            yarn build

      - store_artifacts:
          path: build

      - persist_to_workspace:
          root: .
          paths:
            - build

  deploy_staging:
    <<: *defaults
    parameters:
      s3:
        type: boolean
        default: false

    steps:
      - attach_workspace:
          at: ~/app

      - run:
          name: 'Get configurations from conf'
          command: |
            source conf.env

            if [[ "$ENV_CLUSTER" == "production" ]] || [[ "$ENV_CLUSTER" == "prod" ]]
            then
              echo "deploy_staging cannot deploy to production"
              exit 1
            fi

            echo "export FIREBASE_APP=$FIREBASE_APP" >> $BASH_ENV
            echo "export TO=$ENV_CLUSTER" >> $BASH_ENV
            echo "export BRANCH_NAME=$BRANCH_NAME" >> $BASH_ENV

      - when:
          condition: << parameters.s3 >>
          steps:
            - deploy_s3:
                to: $TO
                branch: $BRANCH_NAME

      - unless:
          condition: << parameters.s3 >>
          steps:
            - deploy_firebase:
                app_name: $FIREBASE_APP
                to: $TO

  align_sandbox_with_production:
    <<: *defaults
    parameters:
      s3:
        type: boolean
        default: false

    steps:
      - attach_workspace:
          at: ~/app

      - when:
          condition: << parameters.s3 >>
          steps:
            - run: echo "Deploying to Sandbox env"
            - deploy_s3:
                to: 'sandbox'
                branch: 'master'

      - unless:
          condition: << parameters.s3 >>
          steps:
            - run: echo "Sandbox alignment only available for s3 projects"

  deploy_production:
    <<: *defaults
    parameters:
      s3:
        type: boolean
        default: false

    steps:
      - attach_workspace:
          at: ~/app

      - when:
          condition: << parameters.s3 >>
          steps:
            - run: echo "preinstall"
            - deploy_s3:
                to: 'production'
                branch: 'master'
            - invalidate_cf_index
            - invalidate_cf_manifest

      - unless:
          condition: << parameters.s3 >>
          steps:
            - run:
                name: 'Get env vars from conf'
                command: |
                  source conf.env
                  echo "export FIREBASE_APP=$FIREBASE_APP" >> $BASH_ENV

            - deploy_firebase:
                app_name: $FIREBASE_APP
                to: 'production'

  test:
    <<: *defaults
    docker:
      - image: cypress/base:12

    steps:
      - attach_workspace:
          at: ~/app

      - run:
          name: Run Tests
          command: yarn test --coverage --maxWorkers=2
      - save-partial-coverage-report:
          label: unit
      - store_artifacts:
          path: coverage

  test_e2e:
    <<: *defaults
    docker:
      - image: cypress/base:12

    steps:
      - jq/install

      - attach_workspace:
          at: ~/app

      - run:
          name: 'Get cluster from conf'
          command: |
            source conf.env
            echo "export E2E_CLUSTER=$ENV_CLUSTER" >> $BASH_ENV

      - run: echo Starting server with cluster $E2E_CLUSTER

      - run:
          command: CONFIG_ENV=$E2E_CLUSTER GUESTY_ENV=$E2E_CLUSTER NODE_ENV=$E2E_CLUSTER PORT=3000 yarn start
          background: true

      - run: yarn cypress:install
      - run: yarn wait-on http://localhost:3000 -t 120000

      - run: yarn cypress:run --record --key $CYPRESS_RECORD_KEY --ci-build-id $CIRCLE_WORKFLOW_ID --parallel --env configFile=$E2E_CLUSTER

      - save-partial-coverage-report:
          label: e2e

      - store_test_results:
          path: junit-results
      - store_artifacts:
          path: cypress/videos
      - store_artifacts:
          path: cypress/screenshots
      - store_artifacts:
          path: cypress/snapshots
      - store_artifacts:
          path: coverage

      #::inject-test_e2e-steps-end.yml

  merge-coverage:
    <<: *defaults
    docker:
      - image: 'cypress/base:12'
    description: Merges individual code coverage files
    steps:
      - attach_workspace:
          at: ~/app
      - merge-coverage-reports
      - store_artifacts:
          path: coverage

workflows:
  build-test-and-deploy:
    jobs:
      - checkout_environment:
          context: org-global
          filters:
            <<: *tags_filter
            <<: *master_filter

      - setup:
          context: org-global
          filters:
            <<: *tags_filter
            <<: *master_filter

      - test:
          context: org-global
          requires:
            - setup
            - checkout_environment
          filters:
            <<: *tags_filter
            <<: *master_filter

      - test_e2e:
          context: org-global
          requires:
            - setup
            - checkout_environment
          filters:
            <<: *tags_filter
            <<: *master_filter

      - merge-coverage:
          context: org-global
          requires:
            - test
            - test_e2e
          filters:
            <<: *tags_filter
            <<: *master_filter

      - align_inventory:
          context:
            - org-global
          requires:
            - test
          filters:
            <<: *tags_filter
            <<: *master_filter

      - update_imdb:
          requires:
            - align_inventory
          context:
            - org-global
            - org-imdb
          filters:
            <<: *tags_filter
            <<: *master_filter

      - build:
          context: org-global
          requires:
            - test
          filters:
            <<: *tags_filter
            <<: *master_filter

      - deploy_staging:
          context: org-global
          s3: true
          requires:
            - build
          filters:
            <<: *tags_filter
            branches:
              ignore: /.*/

      - hold:
          context: org-global
          type: approval
          requires:
            - build
            - test
            - test_e2e
          filters:
            <<: *master_filter

      - deploy_production:
          context: org-global
          s3: true
          post-steps:
            - slack/notify:
                message: '*${CIRCLE_PROJECT_REPONAME}* deployed by *${CIRCLE_USERNAME}*'
                color: '#29af7b'
                webhook: ${SLACK_VERSIONS_WEBHOOK}
                include_job_number_field: false
                include_project_field: false
          requires:
            - hold
          filters:
            <<: *master_filter

      - align_sandbox_with_production:
          context: org-global
          s3: true
          requires:
            - hold
          filters:
            <<: *master_filter

  nightly:
    triggers:
      - schedule:
          cron: '0 6 * * *'
          filters:
            <<: *master_filter
    jobs:
      - test_e2e:
          context: org-global
          requires:
            - setup
            - checkout_environment
      - setup:
          context: org-global
      - checkout_environment:
          context: org-global
