import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isNumber from 'lodash/isNumber';
import { isEmpty } from '@guestyci/foundation/utils';
import createStyles from '@guestyci/foundation/createStyles';
import history from "../utils";
import ActiveTabBottomBorder from "./ActiveTabBottomBorder";
import useComponentSize from "../utils/hooks/useSizeHook";
var useStyles = createStyles(function (theme) {
  return {
    root: {
      color: theme.palette.text.running
    },
    active: {
      color: theme.palette.brand.primary
    },
    borderBottom: {
      borderBottom: "2px solid ".concat(theme.palette.border)
    }
  };
}, {
  name: 'NavTabs'
});

var getExactValueIndex = function getExactValueIndex(tabs, value) {
  return tabs.findIndex(function (tab) {
    return tab.getAttribute('href') === value;
  });
};

var getClosestMatchValueIndex = function getClosestMatchValueIndex(tabs, url) {
  var result = -1;
  var longestMatch = -1;
  tabs.forEach(function (tab, indexInArray) {
    var path = tab.getAttribute('href');
    var tabPathIndex = path.startsWith('/') && path.length > 1 ? 1 : 0;
    var matchIndex = -1;

    while (matchIndex < url.length - 1 && url.charAt(tabPathIndex) === path.charAt(tabPathIndex)) {
      matchIndex += 1;
      tabPathIndex += 1;
    }

    if (matchIndex > longestMatch) {
      longestMatch = matchIndex;
      result = indexInArray;
    }
  });
  return result;
};

var Tabs = function Tabs(_ref) {
  var children = _ref.children,
      className = _ref.className,
      style = _ref.style,
      exact = _ref.exact,
      noBorderBottom = _ref.noBorderBottom,
      fullWidth = _ref.fullWidth,
      activePathname = _ref.activePathname,
      noAnimate = _ref.noAnimate,
      onChange = _ref.onChange;
  var classes = useStyles();
  var tabsRef = useRef();

  var _useState = useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      isBootstrap = _useState2[0],
      setIsBootstrap = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      activeIndex = _useState4[0],
      setActiveIndex = _useState4[1];

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      borderWidth = _useState6[0],
      setBorderWidth = _useState6[1];

  var _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      position = _useState8[0],
      setPosition = _useState8[1];

  var tabsSize = useComponentSize(tabsRef, !isEmpty(activeIndex));
  useEffect(function () {
    var url = history.getPathName();
    setControlledPosition(url);
    setIsBootstrap(false);
  }, []);
  useEffect(function () {
    setControlledPosition(activePathname);
  }, [activePathname]);
  useEffect(function () {
    if (!isEmpty(activeIndex)) {
      setActiveIndexBorderWidth();
    }
  }, [activeIndex, tabsSize]);
  useEffect(function () {
    if (!isBootstrap) {
      var timeout = setTimeout(function () {
        var url = activePathname || history.getPathName();
        setActiveIndexBorderWidth();
        setControlledPosition(url);
      }, 155);
      return function () {
        return clearTimeout(timeout);
      };
    }
  }, [children.length]);
  var setControlledPosition = useCallback(function (value) {
    var tabs = tabsRef.current.getElementsByClassName('tab-item');
    var stringValue = String(value);
    var tabsArray = Array.from(tabs);
    var index = exact ? getExactValueIndex(tabsArray, stringValue) : getClosestMatchValueIndex(tabsArray, stringValue);

    if (index > -1) {
      setActiveIndex(index);
    }
  }, [tabsRef.current]);
  var setActiveIndexBorderWidth = useCallback(function () {
    var tabs = tabsRef.current.getElementsByClassName('tab-item');
    var activeChild = tabs[activeIndex];

    if (activeChild) {
      setBorderWidth(activeChild.offsetWidth);
      setPosition(activeChild.offsetLeft);
    }
  }, [activeIndex, tabsRef.current]);
  var changeTab = useCallback(function (_ref2) {
    var tabIndex = _ref2.tabIndex,
        to = _ref2.to,
        value = _ref2.value;
    setActiveIndex(tabIndex);
    history.push(to);

    if (onChange) {
      var tabProps = {
        to: to,
        activeTabIndex: tabIndex,
        value: value
      };
      onChange(tabProps);
    }
  });
  var validChildren = useMemo(function () {
    return React.Children.toArray(children).filter(React.isValidElement);
  }, [children]);

  var isActiveIndex = function isActiveIndex(index) {
    return index === activeIndex;
  };

  var borderClass = !noBorderBottom ? classes.borderBottom : 'bb-2 border-transparent';
  return /*#__PURE__*/React.createElement("div", {
    className: cn('d-flex-fill', 'relative', 'flex-column', {
      'w-fill': fullWidth
    }, className),
    ref: tabsRef,
    style: style
  }, /*#__PURE__*/React.createElement("div", {
    className: cn('tabs-wrapper d-flex text-uppercase min-height-50 h-fill', classes.root, borderClass)
  }, validChildren.map(function (child, index) {
    return /*#__PURE__*/React.cloneElement(child, {
      onClick: changeTab,
      className: index !== validChildren.length - 1 ? 'mr-5' : '',
      tabIndex: index,
      isActive: isActiveIndex(index)
    });
  })), isNumber(activeIndex) && isNumber(position) && /*#__PURE__*/React.createElement(ActiveTabBottomBorder, {
    width: borderWidth,
    position: position,
    noAnimate: noAnimate
  }));
};

Tabs.defaultProps = {
  onChange: null,
  className: '',
  style: {},
  noBorderBottom: false,
  noAnimate: false,
  fullWidth: false,
  exact: true,
  activePathname: null
};
Tabs.propTypes = {
  /** The tabs children array to render */
  children: PropTypes.node.isRequired,

  /** Callback for on tab change payload:{ activeTabIndex, value (as passed in tab) } */
  onChange: PropTypes.func,

  /** Additional class to tabs root */
  className: PropTypes.string,

  /** Additional style to tabs root */
  style: PropTypes.shape(),

  /** Indicator whether or not to show the bottom line for the tabs */
  noBorderBottom: PropTypes.bool,

  /** Indicator whether or not to animate change */
  noAnimate: PropTypes.bool,

  /** Boolean indicator for parent full width */
  fullWidth: PropTypes.bool,

  /** match route by exact value or closest match */
  exact: PropTypes.bool,

  /** controlled value to pass to tabs */
  activePathname: PropTypes.string
};
export default Tabs;