import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import cn from 'classnames';
import PropTypes from 'prop-types';
import get from 'lodash/get';
import size from 'lodash/size';
import ThreadMessageIcon from "./ThreadMessageIcon";
import MessageBody from "./ThreadMessageBody";
import ThreadMessageErrInfo from "./ThreadMessageError";
import ThreadMessageInfo from "./ThreadMessageInfo";
var fileTypes = ['Png', 'Pdf', 'Xls', 'Gif', 'Doc', 'Jpg', 'Mp4'];

var ThreadMessage = /*#__PURE__*/function (_Component) {
  _inherits(ThreadMessage, _Component);

  var _super = _createSuper(ThreadMessage);

  function ThreadMessage(props) {
    var _this;

    _classCallCheck(this, ThreadMessage);

    _this = _super.call(this, props);

    _this.getThumbnail = function (sentBy) {
      var _this$props = _this.props,
          isAutomatic = _this$props.isAutomatic,
          from = _this$props.from,
          module = _this$props.module,
          guest = _this$props.guest;
      if (isAutomatic) return 'BtnAutomsg';
      if (sentBy === 'guest') return get(guest, 'picture.thumbnail');
      if (sentBy === 'host' || get(module, 'type') === 'note') return get(from, 'picture.thumbnail');
      if (sentBy === 'guesty') return 'gseIcon';
      if (get(module, 'action')) return 'airBnbIcon';
      return null;
    };

    _this.getBgColor = function (sentBy, module) {
      if (module.type === 'note') return 'yellow-light';
      return 'gray-lightest';
    };

    _this.getModuleType = function (module) {
      var moduleDisplayType = get(module, 'displayType');
      return moduleDisplayType || get(module, 'type');
    };

    _this.getFullName = function (sentBy) {
      var _this$props2 = _this.props,
          from = _this$props2.from,
          isAutomatic = _this$props2.isAutomatic,
          module = _this$props2.module,
          guest = _this$props2.guest;
      if (sentBy === 'guest') return get(guest, 'fullName');
      if (sentBy === 'guesty') return 'Guestyâ€™s communication service';
      if (sentBy === 'channel') return 'Airbnb';
      if (sentBy === 'host' && !isAutomatic) return get(from, 'fullName');
      if (!sentBy && get(module, 'action')) return 'airbnb';
      if (isAutomatic) return 'Automated message';
      return get(from, 'fullName') || 'Not Available';
    };

    _this.getIconType = function (item) {
      if (!item) return 'Jpg';
      var itemType = item.split('.')[1];
      return fileTypes.indexOf(itemType) > -1 ? itemType : 'Jpg';
    };

    _this.prepareAttachments = function (attachments) {
      if (!size(attachments)) return [];
      return attachments.map(function (item) {
        return {
          url: item.attachmentUrl,
          name: item.origFileName || item.contentName || 'unnamed file',
          icon: _this.getIconType(item.origFileName),
          contentName: item.contentName,
          isLoading: item.isLoading
        };
      });
    };

    _this.isByUs = function () {
      var _this$props3 = _this.props,
          sentBy = _this$props3.sentBy,
          module = _this$props3.module;
      return sentBy !== 'guest' && sentBy !== 'third party' && !get(module, 'action');
    };

    _this.retrySendMessage = function () {
      var _this$props4 = _this.props,
          id = _this$props4.id,
          onRetry = _this$props4.onRetry;
      onRetry(id);
    };

    _this.deleteMessage = function () {
      var _this$props5 = _this.props,
          id = _this$props5.id,
          onDelete = _this$props5.onDelete;
      onDelete(id);
    };

    _this.state = {
      bgColor: _this.getBgColor(props.sentBy, props.module),
      byGuest: props.sentBy === 'guest',
      byGSE: props.sentBy === 'guesty',
      byChannel: (!props.sentBy || props.sentBy === 'channel') && !!get(props.module, 'action'),
      thumbnail: _this.getThumbnail(props.sentBy),
      byUs: _this.isByUs(),
      fullName: _this.getFullName(props.sentBy),
      moduleType: _this.getModuleType(props.module)
    };
    return _this;
  }

  _createClass(ThreadMessage, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
          id = _this$props6.id,
          guest = _this$props6.guest;
      var dataUpdated = prevProps.guest._id !== guest._id || prevProps.id !== id;

      if (dataUpdated) {
        this.init();
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this$props7 = this.props,
          sentBy = _this$props7.sentBy,
          module = _this$props7.module;
      this.setState({
        bgColor: this.getBgColor(sentBy, module),
        byGuest: sentBy === 'guest',
        byGSE: sentBy === 'guesty',
        byChannel: (!sentBy || sentBy === 'channel') && !!get(module, 'action'),
        thumbnail: this.getThumbnail(sentBy),
        byUs: this.isByUs(),
        fullName: this.getFullName(sentBy),
        moduleType: this.getModuleType(module)
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          bgColor = _this$state.bgColor,
          byGuest = _this$state.byGuest,
          byGSE = _this$state.byGSE,
          byChannel = _this$state.byChannel,
          thumbnail = _this$state.thumbnail,
          byUs = _this$state.byUs,
          fullName = _this$state.fullName,
          moduleType = _this$state.moduleType;
      var _this$props8 = this.props,
          attachments = _this$props8.attachments,
          isAutomatic = _this$props8.isAutomatic,
          className = _this$props8.className,
          body = _this$props8.body,
          error = _this$props8.error,
          deleteTxt = _this$props8.deleteTxt,
          retryTxt = _this$props8.retryTxt,
          reasonTxt = _this$props8.reasonTxt,
          sentAt = _this$props8.sentAt,
          createdAt = _this$props8.createdAt,
          onAttachmentClick = _this$props8.onAttachmentClick;
      return /*#__PURE__*/React.createElement("div", {
        className: cn('threadMessageBubble d-flex', {
          'flex-row-reverse by-us': byUs
        }, className),
        "data-qa": "thread-message"
      }, /*#__PURE__*/React.createElement(ThreadMessageIcon, {
        avatarName: fullName,
        isAutoMessage: isAutomatic,
        thumbnail: thumbnail,
        byChannel: byChannel,
        byUs: byUs,
        byGSE: byGSE,
        byGuest: byGuest
      }), /*#__PURE__*/React.createElement("div", {
        className: "d-flex flex-column flex-1"
      }, /*#__PURE__*/React.createElement(MessageBody, {
        errorMessage: error,
        body: body,
        attachments: this.prepareAttachments(attachments),
        isAutoMessage: isAutomatic,
        byUs: byUs,
        bgColor: bgColor,
        onAttachmentClick: onAttachmentClick
      }), error ? /*#__PURE__*/React.createElement(ThreadMessageErrInfo, {
        messageReason: reasonTxt,
        tooltip: /*#__PURE__*/React.createElement(ThreadMessageInfo, {
          fullName: fullName,
          sentAt: sentAt,
          createdAt: createdAt,
          byUs: byUs,
          moduleType: moduleType,
          fromErrorInfo: true
        }),
        retrySendMessage: this.retrySendMessage,
        onDelete: this.deleteMessage,
        retryTxt: retryTxt,
        deleteTxt: deleteTxt
      }) : /*#__PURE__*/React.createElement(ThreadMessageInfo, {
        fullName: fullName,
        sentAt: sentAt,
        createdAt: createdAt,
        byUs: byUs,
        moduleType: moduleType
      })));
    }
  }]);

  return ThreadMessage;
}(Component);

ThreadMessage.defaultProps = {
  attachments: null,
  isAutomatic: false,
  guest: {}
};
ThreadMessage.propTypes = {
  /** The message body, can be a string or an html node. */
  body: PropTypes.node.isRequired,

  /** Array of objects that contain the imgs */
  attachments: PropTypes.arrayOf(PropTypes.shape()),

  /** Bool, flag for automatic messages */
  isAutomatic: PropTypes.bool,

  /** String, name if the module which the message sent  */
  module: PropTypes.shape().isRequired,

  /** Object, metadata about the message sender. */
  from: PropTypes.shape().isRequired,

  /** String, by who message was sent */
  sentBy: PropTypes.string.isRequired,

  /** String, time that message was sent */
  sentAt: PropTypes.string.isRequired,

  /** String, item id */
  id: PropTypes.string.isRequired,

  /** object, item id */
  guest: PropTypes.shape(),

  /** Bool, if the message is with error */
  error: PropTypes.bool.isRequired,

  /** function, retry send the specific message */
  onRetry: PropTypes.func.isRequired,

  /** function, delete the unsent message */
  onDelete: PropTypes.func.isRequired,

  /** string, txt for delete btn */
  deleteTxt: PropTypes.string.isRequired,

  /** string, txt for retry btn */
  retryTxt: PropTypes.string.isRequired,

  /** String, err reason */
  reasonTxt: PropTypes.string.isRequired,

  /** Open attachment event */
  onAttachmentClick: PropTypes.func
};
export default ThreadMessage;