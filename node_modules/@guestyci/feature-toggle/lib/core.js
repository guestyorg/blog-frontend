'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SplitFactory = require('@splitsoftware/splitio').SplitFactory;
var merge = require('lodash.merge');

var FeatureToggle = function () {
  function FeatureToggle() {
    (0, _classCallCheck3.default)(this, FeatureToggle);

    this.defaultConfig = {
      startup: {
        requestTimeoutBeforeReady: 1.5, // 1500 ms
        retriesOnFailureBeforeReady: 3, // 3 times
        readyTimeout: 1.5 // 1500 ms
      }
    };
  }

  (0, _createClass3.default)(FeatureToggle, [{
    key: 'init',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var accountId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'annonymus';
        var clientConfig, factory;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                clientConfig = accountId !== 'annonymus' ? merge({ core: { key: accountId } }, this.defaultConfig, config) : merge(this.defaultConfig, config); // {...config,...{core:{key:accountId}}}

                // Singleton pattern

                if (!FeatureToggle.instance) {
                  factory = SplitFactory(clientConfig);


                  this._client = factory.client();

                  FeatureToggle.instance = this;
                }

                FeatureToggle.instance._client.on('SDK_READY_TIMED_OUT', FeatureToggle._generateThrowSetupExeption('SDK_READY_TIMED_OUT'));
                _context.next = 5;
                return FeatureToggle._waitForEvent(FeatureToggle.instance._client, FeatureToggle.instance._client.Event.SDK_READY, clientConfig.startup.readyTimeout * 1000);

              case 5:
                return _context.abrupt('return', FeatureToggle.instance);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _ref.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: 'isEnabled',
    value: function isEnabled(featureToggleName) {
      var accountId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'annonymus';
      var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;


      if (!('_client' in this)) FeatureToggle._generateThrowSetupExeption('Client did not init before first \'isEnabled\' usage', 'REQUIRE_FT_INIT')();

      try {
        var result = this._client.isBrowserClient ? this._client.getTreatment(featureToggleName, attributes) : this._client.getTreatment(accountId, featureToggleName, attributes);
        console.debug('[featureToggle] ' + featureToggleName + ' -> ' + result);
        return FeatureToggle._boolifyOffOn(result, defaultValue);
      } catch (err) {
        var stack = err.stack;

        console.error('[featureToggle] Faile to get treatment value, err:' + stack, { stack: stack });
      }
      return defaultValue;
    }
  }], [{
    key: '_boolifyOffOn',
    value: function _boolifyOffOn(treatment) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      switch (treatment) {
        case 'on':
          return true;
        case 'off':
          return false;
        case 'control':
          return defaultValue;
        default:
          return treatment;
      }
    }
  }, {
    key: '_waitForEvent',
    value: function _waitForEvent(eventEmitter, eventType) {
      var setTimeOut = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return _promise2.default.race([new _promise2.default(function (resolve) {
        return eventEmitter.on(eventType, resolve);
      }), new _promise2.default(function (resolve, reject) {
        return setTimeout(function () {
          return reject(new Error('eventTimeOut'));
        }, setTimeOut);
      })]).catch(FeatureToggle._generateThrowSetupExeption('Timeout while waiting to event:' + eventType + ', setTimeout:' + setTimeOut), eventType + '_TIME_OUT');
    }
  }, {
    key: '_generateThrowSetupExeption',
    value: function _generateThrowSetupExeption(reason, errCode) {
      return function () {
        var err = new Error('[featureToggle] Fail to start feaetureToggle instance, reason:' + reason);
        err.code = errCode || reason;
        throw err;
      };
    }
  }]);
  return FeatureToggle;
}();

module.exports = new FeatureToggle();