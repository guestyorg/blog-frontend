import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import getEventSource from '../../services/getEventSource';
var VERSION = '1.1';
var CONTROL_CHANNEL_REGEX = /^control_/;
/**
 * Build metadata headers for SSE connection.
 *
 * @param {Object} settings Validated settings.
 */

function buildSSEHeaders(settings) {
  var headers = {
    SplitSDKClientKey: settings.core.authorizationKey.slice(-4),
    SplitSDKVersion: settings.version
  }; // ip and hostname are false if IPAddressesEnabled is false

  var _settings$runtime = settings.runtime,
      ip = _settings$runtime.ip,
      hostname = _settings$runtime.hostname;
  if (ip) headers['SplitSDKMachineIP'] = ip;
  if (hostname) headers['SplitSDKMachineName'] = hostname;
  return headers;
}

var SSEClient = /*#__PURE__*/function () {
  // Instance properties:
  //  streamingUrl: string
  //  EventSource: EventSource constructor
  //  connection: EventSource | undefined
  //  handler: EventHandler for open, close, error and messages events
  //  authToken: Object | undefined
  function SSEClient(EventSource, settings, useHeaders) {
    _classCallCheck(this, SSEClient);

    this.EventSource = EventSource;
    this.streamingUrl = settings.url('/sse');
    this.reopen = this.reopen.bind(this);
    this.useHeaders = useHeaders;
    this.headers = buildSSEHeaders(settings);
  }

  _createClass(SSEClient, [{
    key: "setEventHandler",
    value: function setEventHandler(handler) {
      this.handler = handler;
    }
    /**
     * Open the connection with a given authToken
     *
     * @param {Object} authToken
     * @throws {TypeError} Will throw an error if `authToken` is undefined
     */

  }, {
    key: "open",
    value: function open(authToken) {
      this.close(); // it closes connection if previously opened

      this.authToken = authToken;
      var channelsQueryParam = Object.keys(authToken.channels).map(function (channel) {
        var params = CONTROL_CHANNEL_REGEX.test(channel) ? '[?occupancy=metrics.publishers]' : '';
        return encodeURIComponent(params + channel);
      }).join(',');
      var url = "".concat(this.streamingUrl, "?channels=").concat(channelsQueryParam, "&accessToken=").concat(authToken.token, "&v=").concat(VERSION, "&heartbeats=true"); // same results using `&heartbeats=false`

      this.connection = new this.EventSource( // For Browser, SplitSDKClientKey and SplitSDKClientKey headers are passed as query params,
      // because native EventSource implementations for browser doesn't support headers.
      this.useHeaders ? url : url + "&SplitSDKVersion=".concat(this.headers.SplitSDKVersion, "&SplitSDKClientKey=").concat(this.headers.SplitSDKClientKey), // For Node, metadata headers are passed because 'eventsource' package supports them.
      this.useHeaders ? {
        headers: this.headers
      } : undefined);

      if (this.handler) {
        // no need to check if SSEClient is used only by PushManager
        this.connection.onopen = this.handler.handleOpen;
        this.connection.onmessage = this.handler.handleMessage;
        this.connection.onerror = this.handler.handleError;
      }
    }
    /** Close connection  */

  }, {
    key: "close",
    value: function close() {
      if (this.connection) this.connection.close();
    }
    /**
     * Re-open the connection with the last given authToken.
     *
     * @throws {TypeError} if `open` has not been previously called with an authToken
     */

  }, {
    key: "reopen",
    value: function reopen() {
      this.open(this.authToken);
    }
  }], [{
    key: "getInstance",
    value:
    /**
     * Returns a SSEClient instance, or undefined if EventSource is not available.
     * @param {Object} settings Validated SDK settings.
     * @param {boolean} useHeaders True for Node and false for Browser, used to send metadata as headers or query params respectively.
     */
    function getInstance(settings, useHeaders) {
      var EventSource = getEventSource();
      if (EventSource) return new SSEClient(EventSource, settings, useHeaders);
    }
  }]);

  return SSEClient;
}();

export { SSEClient as default };