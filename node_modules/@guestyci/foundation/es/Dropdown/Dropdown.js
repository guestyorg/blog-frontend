import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import React, { useRef, useState, useEffect, useCallback } from 'react';
import cn from 'classnames';
import PropTypes from 'prop-types';
import isEmpty from 'lodash/isEmpty';
import createStyles from "../createStyles";
import DropdownInput from "./DropdownInput";
import Menu from "../Menu/Menu";
import composeEvent from "../utils/composeEvent";
import TextField from "../TextField";
import DropdownSearch from "./DropdownSearch";
import DropdownMenuList from "./DropdownMenuList";
import InfiniteScroll from "../InfiniteScroll";
export const useStyles = createStyles(theme => ({
  root: {
    display: 'flex',
    width: '100%',
    position: 'relative',
    flexFlow: 'column'
  },
  input: {
    marginLeft: theme.spacer(1),
    width: `calc(100% - ${theme.spacer(2)}px)`
  },
  menu: {
    overflowY: 'hidden',
    maxHeight: '100%'
  },
  menuList: {
    maxHeight: 260,
    padding: 0
  },
  scrollable: {
    overflowY: 'auto'
  },
  searchableMaxHeight: {
    maxHeight: 220
  },
  initialLoading: {
    height: 180
  },
  emptyState: {
    color: theme.palette.text.secondary,
    paddingLeft: theme.spacer(1),
    paddingTop: theme.spacer(1)
  }
}), {
  name: 'Dropdown'
});
const loaderOverride = {
  loader: {
    height: '100%'
  }
};
const Dropdown = React.forwardRef(function Dropdown(_ref, ref) {
  let {
    children,
    input,
    placeholder,
    inputProps,
    renderComponent,
    className,
    style,
    jss,
    onChange,
    renderSelected,
    value,
    variant,
    searchable,
    onSearchQueryChange,
    disabled,
    emptyStateComponent,
    name,
    error,
    menuWidth,
    infiniteScrollOptions
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "input", "placeholder", "inputProps", "renderComponent", "className", "style", "jss", "onChange", "renderSelected", "value", "variant", "searchable", "onSearchQueryChange", "disabled", "emptyStateComponent", "name", "error", "menuWidth", "infiniteScrollOptions"]);

  const classes = useStyles({
    jss
  });
  const dropdownAnchorRef = useRef();
  const searchInputRef = useRef();
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState('');
  useEffect(() => {
    if (open && searchable && searchInputRef) {
      setTimeout(() => searchInputRef.current.focus(), 0);
    }
  }, [open]);

  const handleInputClick = () => {
    setOpen(!open);
  };

  const handleDismissDropdown = () => {
    setOpen(false);
  };

  const dispatchOnChange = (e, selectedValue) => {
    e.stopPropagation();
    const newEvent = composeEvent(e, {
      name,
      value: selectedValue
    });
    onChange(newEvent, selectedValue);

    if (variant === 'single') {
      handleDismissDropdown();
    }
  };

  const handleSelectItem = useCallback((e, menuItemValue) => {
    setQuery('');
    dispatchOnChange(e, menuItemValue);
  }, [setQuery, dispatchOnChange]);

  const handleSearchInputChange = e => {
    const {
      value: searchQueryValue
    } = e.currentTarget;
    setQuery(searchQueryValue);
    onSearchQueryChange(composeEvent(e, {
      name
    }));
  };

  const handleClearSearchInputQuery = e => {
    setQuery('');
    onSearchQueryChange(composeEvent(e, {
      name,
      value: ''
    }));
  };

  const handleClearValue = e => {
    // Due to bug in redux form, we must pass null
    // see details here: https://github.com/redux-form/redux-form/issues/3946
    dispatchOnChange(e, null);
  };

  const {
    isLoading
  } = infiniteScrollOptions;
  const InputComponent = input || /*#__PURE__*/React.createElement(DropdownInput, null);
  const shouldShowEmptyState = isEmpty(children) && !isLoading;
  const {
    totalCount: isInfiniteScroll
  } = infiniteScrollOptions;
  const emptyStateMessage = searchable && query ? 'No results found.' : emptyStateComponent;
  return /*#__PURE__*/React.createElement("div", _extends({
    className: cn(classes.root, className),
    style: style,
    ref: ref
  }, props), React.cloneElement(InputComponent, _extends({
    ref: dropdownAnchorRef,
    open,
    name,
    variant,
    disabled,
    value,
    placeholder,
    renderComponent,
    renderSelected,
    onClear: handleClearValue,
    onClick: handleInputClick,
    onChange: dispatchOnChange,
    error
  }, inputProps)), /*#__PURE__*/React.createElement(Menu, {
    variant: "menu",
    menuWidth: menuWidth,
    open: open,
    onClose: handleDismissDropdown,
    className: classes.menu,
    anchorDirection: "start",
    originDirection: "bottom",
    fitAnchor: true,
    anchor: dropdownAnchorRef
  }, searchable && /*#__PURE__*/React.createElement(DropdownSearch, {
    ref: searchInputRef,
    value: query,
    onChange: handleSearchInputChange,
    onClear: handleClearSearchInputQuery,
    className: classes.input
  }), /*#__PURE__*/React.createElement(Menu, {
    variant: "list",
    elevation: 0,
    className: cn(classes.menuList, {
      [classes.initialLoading]: isLoading && isEmpty(children),
      [classes.scrollable]: !isInfiniteScroll,
      [classes.searchableMaxHeight]: searchable
    })
  }, /*#__PURE__*/React.createElement(InfiniteScroll, _extends({}, infiniteScrollOptions, {
    jss: loaderOverride
  }), /*#__PURE__*/React.createElement(DropdownMenuList, {
    variant: variant,
    value: value,
    disabled: disabled,
    onChange: handleSelectItem
  }, children))), shouldShowEmptyState && emptyStateMessage && /*#__PURE__*/React.createElement(TextField, {
    className: cn(classes.emptyState)
  }, emptyStateMessage)));
});
Dropdown.defaultProps = {
  searchable: false,
  placeholder: 'Select an option',
  onSearchQueryChange: null,
  className: '',
  style: {},
  name: '',
  value: undefined,
  disabled: false,
  variant: 'single',
  emptyStateComponent: null,
  renderComponent: null,
  infiniteScrollOptions: {}
};
Dropdown.propTypes = {
  /** Dropdown menuItem options to provide to the dropdown
   * Use <MenuItem> component for rendering children
   */
  children: PropTypes.arrayOf(PropTypes.node).isRequired,

  /** Indicator whether or not the input field is searchable */
  searchable: PropTypes.bool,

  /** Placeholder for input field */
  placeholder: PropTypes.string,

  /** Empty state component  to display when there're no results */
  emptyStateComponent: PropTypes.node,

  /** Mandatory if searchable - callback for on input change */
  onSearchQueryChange: PropTypes.func,

  /** Callback function to be called on value changed - arguments - (event, value)
   * event will contain the html dom value converted to string, to access the full value, use the second argument
   * */
  onChange: PropTypes.func.isRequired,

  /** Additional class for dropdown root */
  className: PropTypes.string,

  /** Additional style for dropdown root */
  style: PropTypes.shape(),

  /** form element name */
  name: PropTypes.string,

  /** Selected dropdown value */
  value: PropTypes.oneOfType([PropTypes.shape(), PropTypes.array, PropTypes.string, PropTypes.number]),

  /** Set the dropdown content menu width manually - by default it will resolve to the larger of the input width or the content width */
  menuWidth: PropTypes.number,

  /** Indicator for disabled status */
  disabled: PropTypes.bool,

  /** variant for the type of dropdown we want to render - values [single, multiselect, chip] */
  variant: PropTypes.oneOf(['single', 'multiselect', 'chip']),

  /** custom props to pass to the input component */
  inputProps: PropTypes.shape(),

  /** DEPRECATED- USE renderSelected */
  renderComponent: PropTypes.func,

  /** Set the input component to show on selected item, Accepting function and String
   * If strings - will render the value[renderSelected].
   * If function - will pass the value props
   * */
  renderSelected: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),

  /** Object to define infinite scrolling behaviour */
  infiniteScrollOptions: PropTypes.shape({
    /** starting index of the chunk */
    skip: PropTypes.number,

    /** cb to notify about required loads */
    onLoadMore: PropTypes.func,

    /** total number of entries */
    totalCount: PropTypes.number,

    /** offset from the bottom, from which loading the next chunk should be triggered */
    scrollOffset: PropTypes.number,

    /** number of rows per page */
    pageSize: PropTypes.number
  }),

  /** indicator for data fetching state */
  isLoading: PropTypes.bool
};
Dropdown.displayName = 'Dropdown';
export default Dropdown;