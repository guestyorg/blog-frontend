import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isNumber from 'lodash/isNumber';
import { isEmpty } from '@guestyci/foundation/utils';
import createStyles from '@guestyci/foundation/createStyles';
import history from "../utils";
import ActiveTabBottomBorder from "./ActiveTabBottomBorder";
import useComponentSize from "../utils/hooks/useSizeHook";
const useStyles = createStyles(theme => ({
  root: {
    color: theme.palette.text.running
  },
  active: {
    color: theme.palette.brand.primary
  },
  borderBottom: {
    borderBottom: `2px solid ${theme.palette.border}`
  }
}), {
  name: 'NavTabs'
});

const getExactValueIndex = (tabs, value) => tabs.findIndex(tab => tab.getAttribute('href') === value);

const getClosestMatchValueIndex = (tabs, url) => {
  let result = -1;
  let longestMatch = -1;
  tabs.forEach((tab, indexInArray) => {
    const path = tab.getAttribute('href');
    let tabPathIndex = path.startsWith('/') && path.length > 1 ? 1 : 0;
    let matchIndex = -1;

    while (matchIndex < url.length - 1 && url.charAt(tabPathIndex) === path.charAt(tabPathIndex)) {
      matchIndex += 1;
      tabPathIndex += 1;
    }

    if (matchIndex > longestMatch) {
      longestMatch = matchIndex;
      result = indexInArray;
    }
  });
  return result;
};

const Tabs = ({
  children,
  className,
  style,
  exact,
  noBorderBottom,
  fullWidth,
  activePathname,
  noAnimate,
  onChange
}) => {
  const classes = useStyles();
  const tabsRef = useRef();
  const [isBootstrap, setIsBootstrap] = useState(true);
  const [activeIndex, setActiveIndex] = useState(null);
  const [borderWidth, setBorderWidth] = useState(0);
  const [position, setPosition] = useState(null);
  const tabsSize = useComponentSize(tabsRef, !isEmpty(activeIndex));
  useEffect(() => {
    const url = history.getPathName();
    setControlledPosition(url);
    setIsBootstrap(false);
  }, []);
  useEffect(() => {
    setControlledPosition(activePathname);
  }, [activePathname]);
  useEffect(() => {
    if (!isEmpty(activeIndex)) {
      setActiveIndexBorderWidth();
    }
  }, [activeIndex, tabsSize]);
  useEffect(() => {
    if (!isBootstrap) {
      const timeout = setTimeout(() => {
        const url = activePathname || history.getPathName();
        setActiveIndexBorderWidth();
        setControlledPosition(url);
      }, 155);
      return () => clearTimeout(timeout);
    }
  }, [children.length]);
  const setControlledPosition = useCallback(value => {
    const tabs = tabsRef.current.getElementsByClassName('tab-item');
    const stringValue = String(value);
    const tabsArray = Array.from(tabs);
    const index = exact ? getExactValueIndex(tabsArray, stringValue) : getClosestMatchValueIndex(tabsArray, stringValue);

    if (index > -1) {
      setActiveIndex(index);
    }
  }, [tabsRef.current]);
  const setActiveIndexBorderWidth = useCallback(() => {
    const tabs = tabsRef.current.getElementsByClassName('tab-item');
    const activeChild = tabs[activeIndex];

    if (activeChild) {
      setBorderWidth(activeChild.offsetWidth);
      setPosition(activeChild.offsetLeft);
    }
  }, [activeIndex, tabsRef.current]);
  const changeTab = useCallback(({
    tabIndex,
    to,
    value
  }) => {
    setActiveIndex(tabIndex);
    history.push(to);

    if (onChange) {
      const tabProps = {
        to,
        activeTabIndex: tabIndex,
        value
      };
      onChange(tabProps);
    }
  });
  const validChildren = useMemo(() => React.Children.toArray(children).filter(React.isValidElement), [children]);

  const isActiveIndex = index => index === activeIndex;

  const borderClass = !noBorderBottom ? classes.borderBottom : 'bb-2 border-transparent';
  return /*#__PURE__*/React.createElement("div", {
    className: cn('d-flex-fill', 'relative', 'flex-column', {
      'w-fill': fullWidth
    }, className),
    ref: tabsRef,
    style: style
  }, /*#__PURE__*/React.createElement("div", {
    className: cn('tabs-wrapper d-flex text-uppercase min-height-50 h-fill', classes.root, borderClass)
  }, validChildren.map((child, index) => /*#__PURE__*/React.cloneElement(child, {
    onClick: changeTab,
    className: index !== validChildren.length - 1 ? 'mr-5' : '',
    tabIndex: index,
    isActive: isActiveIndex(index)
  }))), isNumber(activeIndex) && isNumber(position) && /*#__PURE__*/React.createElement(ActiveTabBottomBorder, {
    width: borderWidth,
    position: position,
    noAnimate: noAnimate
  }));
};

Tabs.defaultProps = {
  onChange: null,
  className: '',
  style: {},
  noBorderBottom: false,
  noAnimate: false,
  fullWidth: false,
  exact: true,
  activePathname: null
};
Tabs.propTypes = {
  /** The tabs children array to render */
  children: PropTypes.node.isRequired,

  /** Callback for on tab change payload:{ activeTabIndex, value (as passed in tab) } */
  onChange: PropTypes.func,

  /** Additional class to tabs root */
  className: PropTypes.string,

  /** Additional style to tabs root */
  style: PropTypes.shape(),

  /** Indicator whether or not to show the bottom line for the tabs */
  noBorderBottom: PropTypes.bool,

  /** Indicator whether or not to animate change */
  noAnimate: PropTypes.bool,

  /** Boolean indicator for parent full width */
  fullWidth: PropTypes.bool,

  /** match route by exact value or closest match */
  exact: PropTypes.bool,

  /** controlled value to pass to tabs */
  activePathname: PropTypes.string
};
export default Tabs;