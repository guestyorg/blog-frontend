import _extends from "@babel/runtime/helpers/esm/extends";
import React, { Component } from 'react';
import 'react-dates/initialize';
import moment from 'moment';
import PropTypes from 'prop-types';
import cn from 'classnames';
import isObject from 'lodash/isObject';
import has from 'lodash/has';
import withStyles from 'react-jss';
import { END_DATE, START_DATE } from 'react-dates/lib/constants';
import memoize from '@guestyci/memoize';
import { uuid } from "../../utils/commonUtility";
import { DatePickerType } from "../../enums/enums";
import RangePicker from "./RangePicker";
import SinglePicker from "./SinglePicker";
import ActionButton from "../ActionButton";
import { grayLight } from "../../theme/colors";
import NavButton from "./DatePickerNavButton";
import IconButton from "../IconButton/IconButton";
import FlatButton from "../FlatButton/FlatButton";
import Fade from "../Fade";

var BtnDelete = function BtnDelete(props) {
  return /*#__PURE__*/React.createElement("svg", props, /*#__PURE__*/React.createElement("path", {
    d: "M8.485.707L7.778 0 4.243 3.536.707 0 0 .707l3.536 3.536L0 7.778l.707.707L4.243 4.95l3.535 3.535.707-.707L4.95 4.243z"
  }));
};

BtnDelete.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 8.4854 8.4854"
};
import Row from "../Row";
const DATE_FORMAT = 'YYYY-MM-DD';
const containerSize = 46;
const styles = {
  container: {
    background: 'white',
    width: '100%',
    height: containerSize,
    display: 'flex',
    justifyContent: 'space-between',
    border: `1px solid ${grayLight}`,
    borderRadius: 2
  },
  iconContainer: {
    height: 44,
    borderLeft: `1px solid ${grayLight}`,
    borderTop: '0px',
    borderBottom: '0px',
    borderRight: '0px'
  },
  dateInputWrapper: {
    flex: 1,
    width: 'calc(100% - 85px)',
    display: 'flex',
    alignItems: 'center'
  }
};

const falseFunc = () => false;

const renderMonthElement = ({
  month
}) => /*#__PURE__*/React.createElement("span", {
  "data-qa": "render-month-element"
}, month.format('MMMM YYYY'));

const isEqualValue = (type, newValue, currentValue) => {
  if (type === DatePickerType.Single) {
    return moment(newValue).isSame(currentValue);
  }

  const sameStart = newValue.start === currentValue.startDate || moment(newValue.start).isSame(currentValue.startDate);
  const sameEnd = newValue.end === currentValue.endDate || moment(newValue.end).isSame(currentValue.endDate);
  return sameStart && sameEnd;
};

const isEqualDefaultValue = (type, newValue, currentValue) => {
  if (type === DatePickerType.Single) {
    return moment(newValue).isSame(currentValue);
  }

  return moment(newValue.start).isSame(currentValue.start) && moment(newValue.end).isSame(currentValue.end);
};

const openDirections = {
  Down: 'down',
  Up: 'up'
};

class DatePicker extends Component {
  constructor(props) {
    super(props);

    this.setValues = () => {
      const {
        value,
        defaultValue,
        type
      } = this.props;
      this.setState(this.setInitialValues(type, value || defaultValue));
    };

    this.onFocus = focus => {
      const {
        type,
        onFocusChange
      } = this.props;
      let focusItem = focus;

      if (focusItem && focusItem.currentTarget) {
        focusItem = type === DatePickerType.Range ? START_DATE : true;
      } else if (isObject(focus)) {
        focusItem = focus.focused;
      }

      this.setState({
        isFocused: !!focusItem,
        focused: focusItem,
        clicked: true
      });

      if (onFocusChange) {
        onFocusChange(focusItem);
      }
    };

    this.onDatesChange = ({
      startDate,
      endDate
    }) => {
      const {
        onChange,
        blockedDates,
        isAvailability,
        id,
        name
      } = this.props;
      const {
        focused
      } = this.state;
      const blockedArray = Object.keys(blockedDates).sort();
      const blockedEndDay = blockedArray[blockedArray.length - 1];
      const blockedStartDay = blockedArray[0];
      let _endDate = endDate;

      if (focused === START_DATE && endDate) {
        _endDate = null;
      }

      this.setState({
        startDate,
        endDate: _endDate
      });
      onChange({
        start: startDate,
        end: _endDate
      }, id || name);

      if (isAvailability) {
        if (startDate && _endDate || !startDate && !_endDate) {
          return;
        }

        if (!_endDate && startDate.isBefore(blockedEndDay)) {
          this.boundaries.end = blockedArray.find(blockedDay => moment(blockedDay).isAfter(startDate));
        } else if (!startDate && _endDate.isAfter(blockedStartDay)) {
          const closestBlocked = blockedArray.reverse().find(blockedDay => moment(blockedDay).isBefore(_endDate));
          this.boundaries.start = moment(closestBlocked).add(1, 'days');
        }
      }
    };

    this.onDateChange = date => {
      const {
        onChange,
        id,
        name
      } = this.props;
      this.setState({
        date
      });
      onChange(date, id || name);
    };

    this.onMonthChange = month => {
      const start = moment(month).startOf('month').format(DATE_FORMAT);
      const end = moment(month).endOf('month').format(DATE_FORMAT);
      const {
        startDate,
        endDate
      } = this.state;
      const {
        blockedDates,
        onMonthChange
      } = this.props;
      const startDay = startDate && startDate.isBefore(start) ? startDate.format(DATE_FORMAT) : start;
      const endDay = endDate && endDate.isAfter(end) ? endDate.format(DATE_FORMAT) : end;

      if ((!blockedDates[startDay] || !blockedDates[endDay]) && onMonthChange) {
        onMonthChange(start, end);
      }
    };

    this.setInitialValues = (type, value) => {
      if (type === DatePickerType.Single) {
        return {
          date: value ? moment(value) : null
        };
      }

      return {
        startDate: isObject(value) && value.start ? moment(value.start) : null,
        endDate: isObject(value) && value.end ? moment(value.end) : null,
        clicked: !!(isObject(value) && (value.start || value.end))
      };
    };

    this.getComponentIds = memoize(({
      id,
      startDateId,
      endDateId
    }) => ({
      id: id || `date_${uuid()}`,
      startDateId: startDateId || `start-date-id_${uuid()}`,
      endDateId: endDateId || `end-date-id_${uuid()}`
    }));

    this.getTooltipByType = type => `Select ${type === DatePickerType.Single ? 'a date' : 'dates'}`;

    this.initialVisibleMonth = () => {
      const {
        initialVisibleMonth
      } = this.props;
      const {
        startDate,
        endDate,
        focused
      } = this.state;

      if (focused === START_DATE) {
        if (startDate) {
          return moment(startDate);
        }

        if (endDate) {
          return moment(endDate);
        }
      } else if (focused === END_DATE) {
        if (endDate) {
          return moment(endDate);
        }

        if (startDate) {
          return moment(startDate);
        }
      }

      return initialVisibleMonth ? moment(initialVisibleMonth) : moment();
    };

    this.isDayBlocked = date => {
      const {
        focused,
        endDate,
        startDate
      } = this.state;
      const {
        blockedDates,
        isFetching
      } = this.props;
      const day = date.format('YYYY-MM-DD');

      if (isFetching) {
        return true;
      }

      if (!startDate || !endDate || focused === END_DATE) {
        if (focused === END_DATE && this.boundaries.end) {
          return moment(date.format(DATE_FORMAT)).isAfter(this.boundaries.end) || moment(date.format(DATE_FORMAT)).isBefore(startDate);
        }

        if (focused === START_DATE && this.boundaries.start) {
          return date.startOf('day').isBefore(this.boundaries.start) || moment(date.format(DATE_FORMAT)).isAfter(endDate);
        }
      }

      this.blockedDates[day] = day in blockedDates ? blockedDates[day] : this.blockedDates[day];
      return this.blockedDates[day];
    };

    this.clearDates = () => {
      const {
        type
      } = this.props;
      this.setState({
        startDate: null,
        endDate: null,
        date: null,
        clicked: false
      });
      this.boundaries.start = null;
      this.boundaries.end = null;

      if (type === DatePickerType.Range) {
        this.onDatesChange({
          startDate: null,
          endDate: null
        });
      } else {
        this.onDateChange(null);
      }
    };

    this.renderDayContents = date => {
      const {
        isFetching
      } = this.props;

      if (isFetching) {
        return /*#__PURE__*/React.createElement("span", {
          className: "flex-center text-muted letter-spacing-2"
        }, "...");
      }

      return date.date();
    };

    this.renderCalendarIcon = () => {
      const {
        classes,
        type,
        id,
        disabled,
        asLabel,
        datepickerIcon
      } = this.props;
      const {
        isFocused
      } = this.state;
      return /*#__PURE__*/React.createElement(ActionButton, {
        className: cn('b-0 zindex-10', classes.iconContainer, {
          'asLabel-iconContainer border-0 icon-left': asLabel,
          'icon-right': !asLabel
        }),
        tooltip: this.getTooltipByType(type),
        onClick: this.onFocus,
        id: id,
        icon: datepickerIcon,
        disabled: disabled,
        iconColor: isFocused ? 'blue' : 'gray-dark'
      });
    };

    const {
      value: _value,
      defaultValue: _defaultValue,
      type: _type,
      isAvailability: _isAvailability,
      onMonthChange: _onMonthChange,
      blockedDates: _blockedDates
    } = props;
    this.state = _extends({}, this.setInitialValues(_type, _value || _defaultValue), {
      clicked: !!(_value || _defaultValue),
      openDirection: openDirections.Down
    });
    this.fieldElement = React.createRef();
    this.blockedDates = {};
    this.boundaries = {
      start: null,
      end: null
    };

    if (_isAvailability) {
      if (!_onMonthChange) {
        throw new Error('onMonthChange required with isAvailability');
      }

      if (has(_value, 'start')) {
        const blockedArray = Object.keys(_blockedDates).sort();
        this.boundaries.end = blockedArray.find(blockedDay => moment(blockedDay).isAfter(_value.start));
      }
    }
  }

  componentDidUpdate(prevProps) {
    const {
      type,
      value,
      defaultValue
    } = this.props;
    const {
      date,
      startDate,
      endDate,
      isFocused
    } = this.state;

    if (isFocused) {
      this.inViewport();
    }

    if (value && !isEqualValue(type, value, date || {
      startDate,
      endDate
    })) {
      this.setValues();
    }

    if (defaultValue && !isEqualDefaultValue(type, defaultValue, prevProps.defaultValue)) {
      this.setValues();
    }
  }

  inViewport() {
    const {
      openDirection
    } = this.state;
    if (!this.fieldElement.current) return;
    const rect = this.fieldElement.current.getBoundingClientRect();
    const openDirectionValue = rect.top > window.innerHeight - rect.bottom ? openDirections.Up : openDirections.Down;

    if (openDirection !== openDirectionValue) {
      this.setState({
        openDirection: openDirectionValue
      });
    }
  }

  render() {
    const {
      id,
      classes,
      className,
      style,
      type,
      enablePastDays,
      focus,
      sm,
      disabled,
      anchorDirection,
      showClearDate,
      appendToBody,
      asLabel,
      iconPosition,
      startDatePlaceholderText,
      endDatePlaceholderText,
      asLabelPlaceholderText,
      renderCalendarIcon,
      startDateId,
      endDateId
    } = this.props;
    const propsForPicker = {
      prevMonthButton: /*#__PURE__*/React.createElement(NavButton, {
        direction: "Left",
        sm: sm,
        type: type
      }),
      nextMonthButton: /*#__PURE__*/React.createElement(NavButton, {
        direction: "Right",
        sm: sm,
        type: type
      }),
      renderMonthElement,
      verticalSpacing: type === DatePickerType.Single ? 4 : 10,
      readOnly: true,
      daySize: type === DatePickerType.Single || sm ? 40 : 50,
      numberOfMonths: type === DatePickerType.Single || sm ? 1 : 2,
      appendToBody
    };

    if (enablePastDays) {
      propsForPicker.isOutsideRange = falseFunc;
    }

    const {
      startDate,
      endDate,
      date,
      focused,
      clicked,
      openDirection
    } = this.state;
    const shouldRenderClearDate = !!(date || startDate || endDate);
    const elemIds = this.getComponentIds({
      id,
      startDateId,
      endDateId
    });
    return /*#__PURE__*/React.createElement(Row, {
      className: cn('relative', {
        sm
      }, 'flex-start-center', 'date-picker', className, classes.container, {
        asLabel
      }),
      style: style,
      "data-qa": "date-picker"
    }, /*#__PURE__*/React.createElement("div", {
      className: cn(classes.dateInputWrapper, {
        'asLabel-dateInputWrapper': asLabel,
        'asLabel-dateInputWrapper_disabled': !clicked && asLabel
      }),
      ref: this.fieldElement
    }, renderCalendarIcon && iconPosition === 'left' && this.renderCalendarIcon(), asLabel && !shouldRenderClearDate && !clicked && /*#__PURE__*/React.createElement(FlatButton, {
      className: "label-placeholder",
      onClick: this.onFocus
    }, asLabelPlaceholderText), type === DatePickerType.Range && /*#__PURE__*/React.createElement(RangePicker, _extends({}, this.props, propsForPicker, {
      disabled: disabled,
      startDate: startDate,
      startDateId: elemIds.startDateId,
      endDateId: elemIds.endDateId,
      endDate: endDate,
      focusedInput: focused,
      onFocus: this.onFocus,
      renderDayContents: day => this.renderDayContents(day),
      onDatesChange: this.onDatesChange,
      isDayBlocked: day => this.isDayBlocked(day),
      onMonthChange: this.onMonthChange,
      initialVisibleMonth: this.initialVisibleMonth,
      anchorDirection: anchorDirection,
      openDirection: openDirection,
      asLabel: asLabel,
      startDatePlaceholderText: startDatePlaceholderText,
      endDatePlaceholderText: endDatePlaceholderText
    })), type === DatePickerType.Single && /*#__PURE__*/React.createElement(SinglePicker, _extends({}, this.props, propsForPicker, {
      id: elemIds.id,
      disabled: disabled,
      date: date,
      onFocusChange: this.onFocus,
      isFocused: focus || !!focused,
      onDateChange: this.onDateChange,
      renderDayContents: day => this.renderDayContents(day),
      isDayBlocked: day => this.isDayBlocked(day),
      initialVisibleMonth: this.initialVisibleMonth,
      anchorDirection: anchorDirection,
      openDirection: openDirection
    }))), showClearDate && shouldRenderClearDate && /*#__PURE__*/React.createElement(Fade, {
      show: shouldRenderClearDate,
      className: "datepicker-clear mb-1"
    }, /*#__PURE__*/React.createElement(IconButton, {
      onClick: this.clearDates,
      svg: BtnDelete,
      iconHeight: 10,
      iconWidth: 10
    })), renderCalendarIcon && iconPosition === 'right' && this.renderCalendarIcon());
  }

}

DatePicker.defaultProps = {
  type: DatePickerType.Single,
  isAvailability: false,
  minimumNights: 1,
  blockedDates: {},
  disabled: false,
  initialVisibleMonth: null,
  value: undefined,
  defaultValue: undefined,
  onMonthChange: null,
  enablePastDays: false,
  focus: false,
  onFocusChange: null,
  sm: true,
  isFetching: false,
  anchorDirection: 'left',
  id: undefined,
  showClearDate: true,
  appendToBody: false,
  iconPosition: 'right',
  renderCalendarIcon: true,
  startDatePlaceholderText: 'Start date',
  endDatePlaceholderText: 'End date',
  startDateId: undefined,
  endDateId: undefined,
  datepickerIcon: 'BtnCalendar'
};
DatePicker.propTypes = {
  /** Id for date picker */
  id: PropTypes.string,

  /** Picker type single/range */
  type: PropTypes.oneOf(Object.values(DatePickerType)),

  /** Minimium Nights, 0 to allow single day range */
  minimumNights: PropTypes.number,

  /** Boolean - if it's avalibilty picker or regular picker (without blocked days) */
  isAvailability: PropTypes.bool,

  /** unavailable object structure :
   *  {
   *   '2018-01-01': true,
   *    '2018-06-01': true,
   *    ...
   *  } */
  blockedDates: PropTypes.object,
  // eslint-disable-line react/forbid-prop-types

  /** Boolean - disable the date input */
  disabled: PropTypes.bool,

  /** Set the initial month for the date picker */
  initialVisibleMonth: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),

  /** Render position of the calendar icon */
  iconPosition: PropTypes.string,

  /** Conditional boolean for rendering range-picker input as label */
  asLabel: PropTypes.bool,

  /** initial value for date range picker - date - for single - {start, end } for range */
  value: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.shape()]),

  /** initial value for date range picker - date - for single - {start, end } for range */
  defaultValue: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string, PropTypes.shape()]),

  /** A request to fetch the availability for star - end period (start, end) => {} */
  onMonthChange: PropTypes.func,

  /** callback when dates change : Range:  ({start, end})  Single: (date) */
  onChange: PropTypes.func.isRequired,

  /** Boolean - if should enable select past days */
  enablePastDays: PropTypes.bool,

  /** if input is focused (open picker) for single picker */
  focus: PropTypes.bool,

  /** focus change callback */
  onFocusChange: PropTypes.func,

  /** Set picker mode, sm or md  to determine the amount of months presented in the picker */
  sm: PropTypes.bool,

  /** Indicator whether or not we are fetching availability */
  isFetching: PropTypes.bool,

  /** Set which direction the drop down will open options: [left|right]  */
  anchorDirection: PropTypes.string,

  /** Indicator whether or not we are displaying clear button  */
  showClearDate: PropTypes.bool,

  /** Boolean - prevent the cut off when the picker inside dialog */
  appendToBody: PropTypes.bool,

  /** Render calendar icon bool */
  renderCalendarIcon: PropTypes.bool,

  /** Placeholder for start date */
  startDatePlaceholderText: PropTypes.string,

  /** Placeholder for end date */
  endDatePlaceholderText: PropTypes.string,

  /** Id for start date input and label */
  startDateId: PropTypes.string,

  /** Id for end date input and label */
  endDateId: PropTypes.string,

  /** Icon to display */
  datepickerIcon: PropTypes.string
};
/** Work around to fix storybook HOC propTypes bug  - DO NOT IMPORT THIS */

export const DatePickerComponent = DatePicker;
export default withStyles(styles)(DatePicker);