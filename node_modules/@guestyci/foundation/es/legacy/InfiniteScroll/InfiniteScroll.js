import _extends from "@babel/runtime/helpers/esm/extends";
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import memoize from '@guestyci/memoize';
import debounce from 'lodash/debounce';
import isNumber from 'lodash/isNumber';
import Spinner from "../Spinner/Spinner";
import CSSTransition from "../CSSTransiton";

class InfiniteScroll extends Component {
  constructor(props) {
    super(props);
    this.handleScrollEvent = debounce(async () => {
      const {
        pageCount,
        offset,
        scrollUp
      } = this.props;
      const {
        fetching,
        currentPage
      } = this.state;

      if (pageCount && !fetching && pageCount > currentPage) {
        const element = this.scrollableEl;

        if (scrollUp) {
          if (this.isAtTop(element)) {
            this.fetchNextPage();
          }
        } else if (this.isAtBottom(element, offset)) {
          this.fetchNextPage();
        }
      }
    }, 150);

    this.isAtBottom = element => {
      const {
        windowScroll,
        offset
      } = this.props;
      const el = !windowScroll ? element : document.documentElement;
      return el.scrollHeight - el.scrollTop - el.clientHeight <= offset;
    };

    this.isAtTop = element => {
      const {
        offset
      } = this.props;
      return element ? element.scrollTop <= offset : window.scrollY <= offset;
    };

    this.isInternalScroll = () => {
      const {
        controlNode,
        windowScroll
      } = this.props;
      return !controlNode && !windowScroll;
    };

    this.getWrapperStyle = memoize((style, height) => _extends({}, style, {
      overflowY: this.isInternalScroll() ? 'auto' : 'inherit',
      maxHeight: height
    }));
    const {
      initialPage
    } = this.props;
    this.state = {
      currentPage: initialPage || 0,
      fetching: false
    };
    this.scrollRef = React.createRef();
  }

  componentDidMount() {
    this.init();
  }

  componentDidUpdate(prevProps) {
    const {
      pageCount,
      page,
      isFetching
    } = this.props;
    const {
      currentPage,
      fetching
    } = this.state;

    if (!prevProps.pageCount && pageCount) {
      this.init();
    }

    if (isNumber(page) && prevProps.page !== page && currentPage !== page) {
      this.setCurrentPage(page);
    }

    if (prevProps.isFetching && !isFetching && fetching) {
      this.stopFetching();
    }
  }

  componentWillUnmount() {
    if (this.scrollableEl) {
      this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
    }
  }

  setCurrentPage(page) {
    this.setState({
      currentPage: page
    });
  }

  fetchNextPage() {
    this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
    this.setState(prevState => ({
      currentPage: prevState.currentPage + 1,
      fetching: true
    }), () => {
      const {
        onLoadMore
      } = this.props;
      const {
        currentPage
      } = this.state;
      onLoadMore(currentPage);
    });
  }

  stopFetching() {
    this.setState({
      fetching: false
    });
    this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
  }

  init() {
    const {
      pageCount,
      windowScroll,
      controlNode,
      initialPage
    } = this.props;

    if (pageCount) {
      this.scrollableEl = controlNode || windowScroll ? document.getElementById(controlNode) || window : this.scrollRef.current;
      this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
      this.setState({
        currentPage: initialPage || 0,
        fetching: false
      });
    } else if (this.scrollableEl) {
      this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
    }
  }

  render() {
    const {
      className,
      children,
      style,
      scrollUp,
      id,
      height,
      animation
    } = this.props;
    const {
      currentPage,
      fetching
    } = this.state;
    const wrapperStyle = this.getWrapperStyle(style, height);
    return /*#__PURE__*/React.createElement("div", {
      id: id,
      ref: this.scrollRef,
      className: cn('w-fill', 'infinite-scroll-container', 'flex-column', 'h-fill', className),
      style: wrapperStyle,
      "data-qa": "infinite-scroll"
    }, scrollUp && fetching && currentPage > 0 && /*#__PURE__*/React.createElement(Spinner, {
      className: "up w-fill height-30",
      small: true
    }), /*#__PURE__*/React.createElement(CSSTransition, {
      animation: animation,
      show: true
    }, children), !scrollUp && fetching && currentPage > 0 && /*#__PURE__*/React.createElement(Spinner, {
      className: "down w-fill height-30",
      small: true
    }));
  }

}

InfiniteScroll.defaultProps = {
  initialPage: 0,
  id: '',
  scrollUp: false,
  offset: 200,
  className: '',
  style: {},
  height: undefined,
  controlNode: undefined,
  windowScroll: false,
  isFetching: false,
  page: undefined,
  animation: 'fade'
};
InfiniteScroll.propTypes = {
  /** Infinite scroll child components */
  children: PropTypes.node.isRequired,

  /** Additional class to infinite scroll root level */
  className: PropTypes.string,

  /** Height for infinite scroll (making it internal scroll) */
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Additional style for infinite scroll */
  style: PropTypes.shape(),

  /** Controller node id to handle the scroll (making scroll on the control element level) */
  controlNode: PropTypes.string,

  /** Initial page count */
  initialPage: PropTypes.number,

  /** Callback for load more elements - IMPORTANT  -->
   CB awaits api result, you must return after api call to clear fetching mode */
  onLoadMore: PropTypes.func.isRequired,

  /** Total page count (limit * skip) */
  pageCount: PropTypes.number.isRequired,

  /** Id for the root of the infinite scroll */
  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Indicator whether or not to fetch on scroll up or down */
  scrollUp: PropTypes.bool,

  /** Offset bottom before re-fetch */
  offset: PropTypes.number,

  /** Indicator whether or not we want scroll on the window level or the component level */
  windowScroll: PropTypes.bool,

  /** Indicator showing if fetching more */
  isFetching: PropTypes.bool,

  /** Prop to make infinite scroll controlled */
  page: PropTypes.number,

  /** control infinite scroll animation */
  animation: PropTypes.string
};
export default InfiniteScroll;