import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { useState, useCallback, useMemo, useEffect } from 'react';
import cn from 'classnames';
import PropTypes from 'prop-types';
import isEmpty from 'lodash/isEmpty';
import debounce from 'lodash/debounce';
import createStyles from "../createStyles";
import { white } from "../theme/colors";
var useStyles = createStyles({
  root: {
    position: 'absolute',
    overflow: 'hidden',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    '& span': {
      transform: 'scale(0)',
      borderRadius: '100%',
      position: 'absolute',
      overflow: 'hidden',
      opacity: 0.5,
      backgroundColor: function backgroundColor(_ref) {
        var color = _ref.color;
        return color;
      },
      animation: '$rippleEffect 850ms'
    }
  },
  '@keyframes rippleEffect': {
    to: {
      opacity: 0,
      transform: 'scale(2)'
    }
  }
});
var TouchRipple = React.forwardRef(function TouchRipple(_ref2, ref) {
  var _ref2$color = _ref2.color,
      color = _ref2$color === void 0 ? white : _ref2$color,
      _ref2$className = _ref2.className,
      className = _ref2$className === void 0 ? '' : _ref2$className;

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      spanStyles = _useState2[0],
      setSpanStyles = _useState2[1];

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      count = _useState4[0],
      setCount = _useState4[1];

  var classes = useStyles({
    color: color
  });
  var showRipple = useCallback(function (e) {
    var rippleContainer = e.currentTarget;
    var size = rippleContainer.offsetWidth;
    var pos = rippleContainer.getBoundingClientRect();
    var x = Math.round(e.clientX - pos.left);
    var y = Math.round(e.clientY - pos.top);
    setCount(count + 1);
    setSpanStyles(_extends({}, spanStyles, _defineProperty({}, count, {
      top: -(size / 2) + y,
      left: -(size / 2) + x,
      height: size,
      width: size
    })));
  }, [count, spanStyles]);
  var cleanUp = debounce(function () {
    setCount(0);
    setSpanStyles({});
  }, 2500);
  React.useImperativeHandle(ref, function () {
    return {
      ripple: showRipple,
      stop: cleanUp
    };
  });
  useEffect(function () {
    return function () {
      return cleanUp.cancel();
    };
  }, []);
  var spanArray = useMemo(function () {
    return Object.keys(spanStyles);
  }, [spanStyles]);
  return /*#__PURE__*/React.createElement("div", {
    role: "presentation",
    className: cn(classes.root, className)
  }, !isEmpty(spanArray) ? spanArray.map(function (key) {
    return /*#__PURE__*/React.createElement("span", {
      key: "rippleWave".concat(key),
      style: _extends({}, spanStyles[key])
    });
  }) : null);
});
TouchRipple.propTypes = {
  color: PropTypes.string,
  className: PropTypes.string
};
export default TouchRipple;