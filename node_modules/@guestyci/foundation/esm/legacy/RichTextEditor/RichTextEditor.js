import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import cn from 'classnames';
import noop from 'lodash/noop';
import PropTypes from 'prop-types';
import React, { Component } from 'react';
import { Editor, EditorState, RichUtils } from 'draft-js';
import { convertToHTML, convertFromHTML } from 'draft-convert';
import 'draft-js/dist/Draft.css';
import InputLabel from "../InputLabel/InputLabel";
import RichTextEditorToolbar from "./RichTextEditorToolbar";
import withFocus from "../../withFocus";
import { customStyleMap, customStyleConvertMap } from "./richTextEditorConf";
import { Theme } from "../../enums/enums";

var RichTextEditor = /*#__PURE__*/function (_Component) {
  _inherits(RichTextEditor, _Component);

  var _super = _createSuper(RichTextEditor);

  function RichTextEditor(props) {
    var _this;

    _classCallCheck(this, RichTextEditor);

    _this = _super.call(this, props);

    _this.onChange = function (editorState) {
      var onChange = _this.props.onChange;

      var editorHtmlState = _this.editorStateToHtml(editorState);

      _this.setState({
        editorState: editorState,
        editorHtmlState: editorHtmlState
      });

      onChange(editorHtmlState);
    };

    _this.setEditorState = function (editorState) {
      _this.setState({
        editorState: editorState
      });
    };

    _this.setDraftRef = function (ref) {
      _this.draftjsRef = ref;
    };

    _this.handleKeyCommand = function (command, editorState) {
      var newState = RichUtils.handleKeyCommand(editorState, command);

      if (newState) {
        _this.onChange(newState);

        return true;
      }

      return false;
    };

    _this.htmlToEditorState = function (html) {
      var contentState = convertFromHTML({
        htmlToStyle: function htmlToStyle(nodeName, node, currentStyle) {
          if (nodeName === 'span') {
            var color = customStyleConvertMap[node.style.color];
            var font = customStyleConvertMap[node.style.fontSize];

            if (color) {
              return currentStyle.add(color);
            }

            if (font) {
              return currentStyle.add(font);
            }
          }

          return currentStyle;
        }
      })(html);
      return EditorState.createWithContent(contentState);
    };

    _this.toggleInlineType = function (inlineType) {
      var editorState = _this.state.editorState;

      _this.onChange(RichUtils.toggleInlineStyle(editorState, inlineType));
    };

    _this.toggleBlockType = function (blockType) {
      var editorState = _this.state.editorState;

      _this.onChange(RichUtils.toggleBlockType(editorState, blockType));
    };

    _this.editorStateToHtml = function (state) {
      var contentState = state.getCurrentContent();

      if (!contentState.hasText()) {
        return '';
      }

      var html = convertToHTML({
        styleToHTML: function styleToHTML(style) {
          if (customStyleMap[style]) {
            return /*#__PURE__*/React.createElement("span", {
              style: customStyleMap[style]
            });
          }
        },
        blockToHTML: function blockToHTML(block) {
          if (block.type === 'unstyled') {
            if (block.text === ' ' || block.text === '') return /*#__PURE__*/React.createElement("br", null);
            return /*#__PURE__*/React.createElement("div", null);
          }
        }
      })(contentState);
      return html;
    };

    _this.state = {
      editorState: props.value ? _this.htmlToEditorState(props.value) : EditorState.createEmpty(),
      editorHtmlState: props.value
    };
    _this.draftRef = null;
    return _this;
  }

  _createClass(RichTextEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var autoFocus = this.props.autoFocus;

      if (autoFocus) {
        this.draftjsRef.focus();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var newValue = this.props.value;
      var editorHtmlState = this.state.editorHtmlState;
      var oldValue = prevProps.value;

      if (oldValue !== newValue && newValue !== editorHtmlState) {
        this.setEditorState(this.htmlToEditorState(newValue));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          label = _this$props.label,
          disabled = _this$props.disabled,
          containerStyle = _this$props.containerStyle,
          placeholder = _this$props.placeholder,
          tooltip = _this$props.tooltip,
          showToolbar = _this$props.showToolbar,
          maxHeight = _this$props.maxHeight,
          onBlur = _this$props.onBlur,
          onFocus = _this$props.onFocus,
          theme = _this$props.theme,
          className = _this$props.className;
      var editorState = this.state.editorState;
      return /*#__PURE__*/React.createElement("div", {
        className: "d-flex-fill flex-column input-wrapper",
        "data-qa": "rich-text-editor"
      }, label && /*#__PURE__*/React.createElement(InputLabel, {
        label: label,
        tooltip: tooltip
      }), /*#__PURE__*/React.createElement("div", {
        className: cn('d-flex-fill flex-column b-1', theme === Theme.Light ? 'border-gray-lightest bg-white' : 'border-gray-light bg-gray-lightest', 'flex-start-center pos-relative', {
          'bg-gray-lighter': disabled
        }, className),
        style: containerStyle
      }, showToolbar && /*#__PURE__*/React.createElement(RichTextEditorToolbar, {
        key: 0,
        theme: theme,
        toggleInlineType: this.toggleInlineType,
        toggleBlockType: this.toggleBlockType,
        editorState: editorState
      }), /*#__PURE__*/React.createElement("div", {
        className: cn('d-flex-fill', 'px-6', 'py-3', _defineProperty({}, "max-height-".concat(maxHeight), maxHeight), theme === Theme.Light ? 'bg-white' : 'bg-gray-lightest', 'overflow-y-auto')
      }, /*#__PURE__*/React.createElement(Editor, {
        ref: this.setDraftRef,
        placeholder: placeholder,
        editorState: editorState,
        onChange: this.onChange,
        readOnly: disabled,
        handleKeyCommand: this.handleKeyCommand,
        customStyleMap: customStyleMap,
        onFocus: onFocus,
        onBlur: onBlur
      }))));
    }
  }]);

  return RichTextEditor;
}(Component);

RichTextEditor.defaultProps = {
  value: undefined,
  onChange: noop,
  placeholder: '',
  label: null,
  tooltip: null,
  disabled: false,
  showToolbar: true,
  className: '',
  maxHeight: 250,
  theme: Theme.Dark,
  autoFocus: false
};
RichTextEditor.propTypes = {
  /** Initial text value */
  value: PropTypes.string,

  /** On change trigger function to update on text change */
  onChange: PropTypes.func,

  /** TextArea Placeholder */
  placeholder: PropTypes.string,

  /** A label to show on top of the input */
  label: PropTypes.string,

  /** Add tooltip help icon and message - tooltip - String help message */
  tooltip: PropTypes.string,

  /** Indicator for disabled status */
  disabled: PropTypes.bool,

  /** Indicator whether or not to show the toolbar */
  showToolbar: PropTypes.bool,

  /** Classes to add */
  className: PropTypes.string,

  /** Max height for component */
  maxHeight: PropTypes.number,

  /** Set theme for component */
  theme: PropTypes.oneOf([Theme.Light, Theme.Dark]),

  /** Boolean to define if should be auto focused */
  autoFocus: PropTypes.bool
};
export var RichTextEditorComponent = RichTextEditor;
export default withFocus(RichTextEditor);