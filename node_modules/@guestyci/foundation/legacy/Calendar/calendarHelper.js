"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitials = exports.makeTitleCase = exports.formatCalendarMonth = exports.formatCalendarDay = exports.getStayDateTime = exports.isInvalidPlannedDate = exports.colorFromStatus = exports.stringToDate = exports.checkReservationDetails = exports.isFirstDay = exports.isLastDay = exports.hasOnlyPTBlock = exports.isBlockReserved = exports.isSameBlock = exports.getBlockType = exports.getMonthName = exports.getCurrencySymbol = exports.getReservationTitle = exports.getGuestDetails = exports.nextDayStatus = exports.previousDayStatus = exports.addDay = exports.subtractDay = exports.toISODateString = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _moment = _interopRequireDefault(require("moment"));

var _isEmpty = _interopRequireDefault(require("lodash/isEmpty"));

var _FormattedCurrency = _interopRequireDefault(require("@guestyci/localize/FormattedCurrency"));

var _enums = require("../../enums/enums");

var reservedBlocks = new Set(['b', 'r', 'o', 'sr']);

var hasActiveDates = function hasActiveDates(activeDates) {
  return !(0, _isEmpty["default"])(activeDates) && activeDates.start && activeDates.end;
};
/**
 * Turn date to yyyy-mm-dd format
 * @param d {Date}  Date object
 * @returns {string}
 */


var toISODateString = function toISODateString(d) {
  var month = d.getMonth() + 1;
  if (month < 10) month = "0".concat(month);
  var date = d.getDate();
  if (date < 10) date = "0".concat(date);
  return "".concat(d.getFullYear(), "-").concat(month, "-").concat(date);
};

exports.toISODateString = toISODateString;

var subtractDay = function subtractDay(day) {
  return new Date(day.getTime() - 86400000);
};

exports.subtractDay = subtractDay;

var addDay = function addDay(day) {
  return new Date(day.getTime() + 86400000);
};
/**
 *  Returns reservation status and reservation id of the day before
 * @param calendar  {Object}  Calendar object
 * @param day {Date}  Day to check
 * @returns {status, id, block}
 * @private
 */


exports.addDay = addDay;

var previousDayStatus = function previousDayStatus(calendar, day) {
  var prevStatus = {};
  var prev = calendar[toISODateString(subtractDay(day))];

  if (prev) {
    prevStatus.status = prev.status;
    prevStatus.block = prev.blocks;

    if (prevStatus.status !== 'available' && prev.reservation) {
      prevStatus.id = prev.reservation._id;
    }
  }

  return (0, _extends2["default"])({}, prevStatus);
};
/**
 *  Returns reservation status and reservation id of the next day
 * @param calendar  {Object}  Calendar object
 * @param day {Date}  Day to check
 * @returns {status, id, block}
 * @private
 */


exports.previousDayStatus = previousDayStatus;

var nextDayStatus = function nextDayStatus(calendar, day) {
  var nextStatus = {};
  var next = calendar[toISODateString(addDay(day))];

  if (next) {
    nextStatus.status = next.status;
    nextStatus.block = next.blocks;

    if (nextStatus.status !== 'available' && next.reservation) {
      nextStatus.id = next.reservation._id;
    }
  }

  return (0, _extends2["default"])({}, nextStatus);
};

exports.nextDayStatus = nextDayStatus;

var getGuestDetails = function getGuestDetails(reservation) {
  return {
    name: reservation.guest.name || reservation.guest.fullName || '',
    avatar: reservation.guest.avatar
  };
};
/**
 * Get the reservation title from the reservation details
 * @param code  {String}  The reservation confirmation code
 * @param source  {String}  The order source
 * @param isOwner {Boolean} Indicator whether or not we are in owner blocked
 * @param isSR  {Boolean} Indicator whether or not we are in blocked by sr
 * @returns {string} - the title
 */


exports.getGuestDetails = getGuestDetails;

var getReservationTitle = function getReservationTitle(code, source, isOwner, isSR) {
  if (isOwner) {
    return 'Owner stay';
  }

  if (isSR) {
    return "Blocked by Res. ".concat(code, " (").concat(source, ")");
  }

  return "Res. ".concat(code, " (").concat(source, ")");
}; // Get currency symbol + add coma to big numbers


exports.getReservationTitle = getReservationTitle;

var getCurrencySymbol = function getCurrencySymbol(currency, amount) {
  return (0, _FormattedCurrency["default"])({
    currency: currency,
    value: amount
  });
};
/**
 * Convert month to string
 * @param month {Number}  Month number
 * @returns {String} the month as string
 * @private
 */


exports.getCurrencySymbol = getCurrencySymbol;

var getMonthName = function getMonthName(month) {
  var months = {
    0: 'January',
    1: 'February',
    2: 'March',
    3: 'April',
    4: 'May',
    5: 'June',
    6: 'July',
    7: 'August',
    8: 'September',
    9: 'October',
    10: 'November',
    11: 'December'
  };
  return months[month];
};
/**
 * Get block type from the block object
 * @param blocks  {Object}  The blocks object
 * @returns {String} - the block type string
 * @private
 */


exports.getMonthName = getMonthName;

var getBlockType = function getBlockType(blocks) {
  var bd = blocks.bd,
      abl = blocks.abl,
      sr = blocks.sr,
      bw = blocks.bw,
      o = blocks.o,
      m = blocks.m,
      a = blocks.a,
      b = blocks.b,
      r = blocks.r,
      pt = blocks.pt;

  if (b) {
    return 'booked';
  }

  if (r) {
    return 'reserved';
  }

  if (bd || abl || sr || bw || pt) {
    return 'autoblock';
  }

  if (o) {
    return 'ownerblock';
  }

  if (m || a) {
    return 'unavailable';
  }

  return null;
};
/**
 * Check if two day blocks are similar
 * @param block1
 * @param block2
 * @returns {boolean}
 */


exports.getBlockType = getBlockType;

var isSameBlock = function isSameBlock(block1, block2) {
  if (block1.r && block2.r || block1.b && block2.b) {
    return true;
  }

  return getBlockType(block1) === getBlockType(block2);
};
/**
 * Check whether or not the block is reserved or not
 * @param blocks  {Object}  The blocks object
 * @returns {boolean}
 * @private
 */


exports.isSameBlock = isSameBlock;

var isBlockReserved = function isBlockReserved(blocks) {
  return blocks && Object.keys(blocks).some(function (key) {
    return blocks[key] && reservedBlocks.has(key);
  });
};

exports.isBlockReserved = isBlockReserved;

var hasOnlyPTBlock = function hasOnlyPTBlock(blocks) {
  var activeBlocks = new Set();
  Object.keys(blocks).forEach(function (blockType) {
    if (blocks[blockType] === true) activeBlocks.add(blockType);
  });
  return activeBlocks.size === 1 && activeBlocks.has('pt');
};

exports.hasOnlyPTBlock = hasOnlyPTBlock;

var isLastDay = function isLastDay(prevId, nowId) {
  return prevId && nowId !== prevId;
};

exports.isLastDay = isLastDay;

var isFirstDay = function isFirstDay(prevId, nowId, nextId) {
  return nowId && nextId && nextId === nowId && nowId !== prevId;
};

exports.isFirstDay = isFirstDay;

var checkReservationDetails = function checkReservationDetails(calendar, day, activeDates) {
  var cost;
  var type;
  var guest;
  var block;
  var startStyles;
  var endStyles;
  var lastDay;
  var dayStatus;
  var isOwner = false;
  var isSR = false;
  var isAvailable = false;
  var startBlockStyle;
  var endBlockStyle;
  var isReserved = false;
  var unavailableBlocks = [];
  var color = 'muted';
  var availableNotes;
  var link;
  var startOfBlock = false;
  var showPrice = false;
  var showAvatar = true;
  var startOpacity = hasActiveDates(activeDates) ? 0.3 : 1;
  var endOpacity = hasActiveDates(activeDates) ? 0.3 : 1;
  var previousDay = previousDayStatus(calendar, day);
  var nextDay = nextDayStatus(calendar, day);
  var calObj = calendar && calendar[toISODateString(day)] || {};
  var reservation = calObj.reservation;
  var id = reservation ? reservation._id : null;

  if (!(0, _isEmpty["default"])(calObj)) {
    var status = calObj.status;
    dayStatus = status;
    isAvailable = dayStatus === _enums.CalendarDayStatus.Available;
    block = calObj.blocks;
    isReserved = isBlockReserved(block);

    if (!isReserved) {
      showPrice = true;
      cost = getCurrencySymbol(calObj.currency, calObj.price);

      if (calObj.note) {
        availableNotes = calObj.note;
      }

      unavailableBlocks = Object.keys(block).filter(function (key) {
        return !reservedBlocks.has(key) && block[key];
      });
    }

    lastDay = isLastDay(previousDay.id, id, nextDay.id);

    if (!(0, _isEmpty["default"])(reservation)) {
      guest = reservation.guest && getGuestDetails(reservation);
      link = id ? "https://app.guesty.com/reservations/".concat(id, "/guests") : null;
    }

    if (status === 'unavailable' && block) {
      startBlockStyle = getBlockType(block);
    }

    if (block && block.o) {
      isOwner = true;
    }

    if (block && block.sr) {
      isSR = true;
    }

    if ((status === 'unavailable' || status === 'available') && previousDay.block) {
      endBlockStyle = getBlockType(previousDay.block);
    }

    if (status !== 'available') {
      if (status !== previousDay.status || !isSameBlock(previousDay.block, block)) {
        startOfBlock = true;
        type = 'start';
      } else if (lastDay) {
        startOfBlock = true;
        type = 'start';
      } else {
        startOfBlock = false;
        type = 'middle';
      }

      startStyles = startBlockStyle ? "".concat(type, " ").concat(startBlockStyle) : "".concat(type, " ").concat(status);
    }

    if (lastDay || previousDay.status !== 'available' && (status !== previousDay.status || !isSameBlock(previousDay.block, block))) {
      type = 'end';
      endStyles = !endBlockStyle ? "".concat(type, " ").concat(previousDay.status) : "".concat(type, " ").concat(endBlockStyle);
    }

    if (hasActiveDates(activeDates) && (0, _moment["default"])(day).startOf('day').diff(activeDates.start, 'days') >= 0 && (0, _moment["default"])(activeDates.end).diff(day, 'days') >= 0) {
      var activeFirstDay = (0, _moment["default"])(day).startOf('day').diff(activeDates.start, 'days') === 0;
      var activeLastDay = (0, _moment["default"])(activeDates.end).endOf('day').diff(day, 'days') === 0;

      if (activeLastDay) {
        startOpacity = 0.3;
        endOpacity = 1;
      } else if (activeFirstDay) {
        startOpacity = 1;
        endOpacity = 0.3;
      } else {
        startOpacity = 1;
        endOpacity = 1;
      }

      if ((!activeLastDay || activeFirstDay) && status !== _enums.CalendarDayStatus.Available) {
        color = 'black';
      }
    }

    if (status === 'ownerblock') {
      color = 'white';
    }

    if (block && hasOnlyPTBlock(block)) {
      showAvatar = false;
    }
  }

  return {
    id: id,
    showPrice: showPrice,
    cost: cost,
    block: block,
    isReserved: isReserved,
    unavailableBlocks: unavailableBlocks,
    link: link,
    isAvailable: isAvailable,
    startOfBlock: startOfBlock,
    availableNotes: availableNotes,
    guest: guest,
    startOpacity: startOpacity,
    endOpacity: endOpacity,
    startStyles: startStyles,
    endStyles: endStyles,
    dayStatus: dayStatus,
    isOwner: isOwner,
    isSR: isSR,
    color: color,
    reservation: reservation,
    showAvatar: showAvatar
  };
};

exports.checkReservationDetails = checkReservationDetails;

var stringToDate = function stringToDate(stringDate) {
  return (0, _moment["default"])(stringDate).format('MM/D/YY, h:mm A');
};
/**
 * Get color from reservation status
 * @param status  {String}  Reservation Status
 * @returns {string}  - the color to display
 */


exports.stringToDate = stringToDate;

var colorFromStatus = function colorFromStatus(status) {
  switch (status) {
    case _enums.CalendarDayStatus.Reserved:
      return 'yellow';

    case _enums.CalendarDayStatus.Confirmed:
      return 'green';

    default:
      return 'white';
  }
};
/**
 * Check if the date is valid
 * @param d1  {Date}  Date to compare larger
 * @param d2  {Date}  Date to compare smaller
 * @returns {boolean}
 */


exports.colorFromStatus = colorFromStatus;

var isInvalidPlannedDate = function isInvalidPlannedDate(d1, d2) {
  return new Date(d1).getTime() > new Date(d2).getTime();
};
/**
 * Set the stay date for the calendar day
 * @param date  {String}  The checkin/out date
 * @param time  {String}  The planned arrival/departure time
 * @return {string} Formatted string
 */


exports.isInvalidPlannedDate = isInvalidPlannedDate;

var getStayDateTime = function getStayDateTime(date, time) {
  var dateString = date;

  if (time) {
    dateString = "".concat(date.split('T')[0], " ").concat(time);
  }

  return (0, _moment["default"])(dateString, 'YYYY-MM-DD hh:mm A').format('MM/D/YY, h:mm A');
};
/**
 * Format the day Date object to calendar needs
 * @param day {Date}  The date in question
 * @param isShort {Boolean} Should show shorten mode
 * @returns {number | *}
 */


exports.getStayDateTime = getStayDateTime;

var formatCalendarDay = function formatCalendarDay(day) {
  var isShort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var date = day.getDate();
  var month = day.getMonth();

  if (date < 10) {
    date = "0".concat(date);
  }

  if (!isShort && date === '01') {
    date = "".concat(getMonthName(month), " ").concat(date);
  }

  return date;
};

exports.formatCalendarDay = formatCalendarDay;

var formatCalendarMonth = function formatCalendarMonth(day) {
  var month = day.getMonth();

  if (month < 10) {
    month = "0".concat(month);
  }

  return month;
};

exports.formatCalendarMonth = formatCalendarMonth;

var makeTitleCase = function makeTitleCase() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var name = string.toLowerCase().split(' ');

  for (var i = 0; i < name.length; i += 1) {
    name[i] = name[i].charAt(0).toUpperCase() + name[i].slice(1);
  }

  return name.join(' ');
};

exports.makeTitleCase = makeTitleCase;

var getInitials = function getInitials(name) {
  return name.match(/\b(\w)/g).join('').toUpperCase();
};

exports.getInitials = getInitials;