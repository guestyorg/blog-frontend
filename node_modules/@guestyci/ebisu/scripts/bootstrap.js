const path = require('path');
const fs = require('fs');
const yaml = require('js-yaml');
const chalk = require('chalk');
const { execSync } = require('child_process');
const {
  getAppDir,
  loadPackageJson,
  copyIfNotExists,
} = require('../util/files');
const { pipe } = require('../util/fp');
const { yarnAddDev } = require('../util/yarn');

const assetsDir = `${__dirname}/assets`;

const copyCircleConfigurationFiles = (type, dest) => {
  const circleDest = `${dest}/.circleci`;
  const circleSource = `${assetsDir}/${type}`;

  if (!fs.existsSync(circleDest)) {
    fs.mkdirSync(circleDest);
  }

  copyIfNotExists(`${circleSource}/config.json`, `${circleDest}/config.json`);

  fs.readdirSync(`${circleSource}`)
    .filter(fileName => fileName.startsWith('inject-'))
    .forEach(injectorFileName =>
      copyIfNotExists(
        `${circleSource}/${injectorFileName}`,
        `${circleDest}/${injectorFileName}`
      )
    );

  return circleDest;
};

const copyGithubConfigurationFiles = (type, dest) => {
  const githubSource = `${assetsDir}/${type}/github`;
  const githubDest = `${dest}/.github`;
  const githubActionsFolder = `${githubDest}/workflows`;

  if (!fs.existsSync(githubSource)) {
    return;
  }

  !fs.existsSync(githubDest)
    ? pipe([fs.mkdirSync(githubDest), fs.mkdirSync(githubActionsFolder)])
    : !fs.existsSync(githubActionsFolder) && fs.mkdirSync(githubActionsFolder);

  fs.copyFileSync(
    `${githubSource}/workflows/TriggerCircleByTags.yml`,
    `${githubDest}/workflows/TriggerCircleByTags.yml`
  );

  return githubDest;
};

const injectYML = (origin, dest) => {
  let rawConfig = fs.readFileSync(`${assetsDir}/${origin}/config.yml`, 'utf8');

  const injectors = fs
    .readdirSync(dest)
    .filter(
      file =>
        path.basename(file).includes('inject-') && path.extname(file) === '.yml'
    );

  const { replaced: rawWithOneLiners, matched } = replaceOneLineInjects(
    dest,
    rawConfig,
    injectors
  );

  const configWithOneLiners = yaml.safeLoad(rawWithOneLiners);
  const configWithInjections = replaceComplexInjects(
    dest,
    configWithOneLiners,
    injectors.filter(injector => !matched.includes(injector))
  );

  fs.writeFileSync(`${dest}/config.yml`, yaml.safeDump(configWithInjections));
};

const replaceOneLineInjects = (dest, config, injectors) => {
  const matched = [];
  const replaced = injectors.reduce((acc, injector) => {
    const injectorYML = `${fs.readFileSync(`${dest}/${injector}`)}`;
    const match = new RegExp('^.*' + injector + '.*$', 'm').exec(acc);

    if (!match) {
      return acc;
    }

    const TAB = '  ';
    const DUBBLE_SPACE = '  ';

    matched.push(injector);
    const line = match[0];
    const spaces = line.substring(0, line.indexOf(`#::${injector}`));
    const indent = spaces.replace(DUBBLE_SPACE, TAB);
    const indentedYML = injectorYML.replace(/\n/g, match => match + indent);
    const currInjectorRegex = new RegExp(`\#::${injector}`, 'g');
    return acc.replace(currInjectorRegex, indentedYML);
  }, config);

  return { replaced, matched };
};

const replaceComplexInjects = (dest, config, injectors) => {
  return injectors.reduce((acc, injector) => {
    const injectorYML = `${fs.readFileSync(`${dest}/${injector}`)}`;
    const injectDoc = yaml.safeLoad(injectorYML);
    return mergeKeysFromYML(injectDoc, acc);
  }, config);
};

const mergeKeysFromYML = (source, dest) => {
  const newConfig = Object.assign({}, dest);
  const keys = Object.keys(source);

  keys.forEach(key => {
    const val = dest[key];
    if (!val) {
      newConfig[key] = source[key];
    } else {
      if (typeof val === 'string') {
        newConfig[key] = source[key];
      } else if (typeof val === 'object') {
        if (Array.isArray(val)) {
          const sourceArr = source[key];
          const mergedArr = [...val];

          const newValues = [];
          const oldValues = [];

          sourceArr.forEach(arrObject => {
            if (typeof arrObject === 'string') {
              mergedArr.push(arrObject);
              return;
            }

            let found = false;
            const arrObjectKey = Object.keys(arrObject)[0];
            for (let i = 0; i < val.length; i++) {
              const original = val[i];
              if (Object.keys(original)[0] === arrObjectKey) {
                found = true;
                const mergedObj = mergeKeysFromYML(arrObject, original);
                mergedArr[i] = mergedObj;
              }
            }

            if (!found) {
              newValues.push(arrObject);
            }
          });

          newConfig[key] = mergedArr.concat(newValues);
        } else {
          newConfig[key] = mergeKeysFromYML(source[key], dest[key]);
        }
      }
    }
  });

  return newConfig;
};

const bootstrap = type => {
  const appDir = getAppDir();
  const packageJson = loadPackageJson();

  console.log(
    `Bootstrapping circleci ${chalk.bold.blue(
      type
    )} configuration for ${chalk.bold.blue(
      packageJson.name
    )} @ ${chalk.bold.blue(packageJson.version)}`
  );

  let circleDest;
  try {
    circleDest = copyCircleConfigurationFiles(type, appDir);
  } catch (e) {
    throw new Error('Error copying CircleCI configuration files into project');
  }

  try {
    injectYML(type, circleDest);
  } catch (e) {
    throw new Error('Error during CircleCI YML injection process');
  }

  try {
    copyGithubConfigurationFiles(type, appDir);
  } catch (e) {
    throw new Error('Error copying Github configuration files into project');
  }
};

const jsonWithScripts = packageJson => {
  const newJson = { ...packageJson };
  const deployci = 'deployci';
  const cypressInstall = 'cypress:install';
  const cypressRun = 'cypress:run';

  newJson.scripts[deployci] = 'ebisu push-tags';

  if (!newJson.scripts[cypressInstall]) {
    newJson.scripts[cypressInstall] =
      'echo change this with "cypress install" when you want e2e tests';
  }
  if (!newJson.scripts[cypressRun]) {
    newJson.scripts[cypressRun] =
      'echo change this with "cypress run" when you want e2e tests';
  }

  return newJson;
};

const installDependencies = async packageJson => {
  const devDependencies = packageJson.devDependencies;

  if (!devDependencies['@guestyci/deploy-script']) {
    await yarnAddDev('@guestyci/deploy-script');
  }

  if (!devDependencies['wait-on']) {
    await yarnAddDev('wait-on');
  }
};

module.exports = {
  bootstrap,
  jsonWithScripts,
  installDependencies,
};
