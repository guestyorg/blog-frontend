const util = require('util');
const cp = require('child_process');
const exec = util.promisify(cp.exec),
  { execSync } = cp;

const chalk = require('chalk');

const getBranch = () => {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD')
      .toString()
      .trim();
  } catch (err) {
    throw new Error('Could not find git branch');
  }
};

const getDiffFromRemote = path => {
  try {
    const branchName = getBranch();
    return execSync(`git diff origin/${branchName} --name-only ${path}`)
      .toString()
      .trim();
  } catch (err) {
    throw new Error('Could not find diff files');
  }
};

const getDiffFromRemoteLastCommit = path => {
  try {
    const branchName = getBranch();
    return execSync(`git diff origin/${branchName} --name-only HEAD~1 ${path}`)
      .toString()
      .trim();
  } catch (err) {
    throw new Error('Could not find diff files');
  }
};

const getDiffFromRemoteMaster = path => {
  try {
    return execSync(`git diff origin/master --name-only --cached ${path}`)
      .toString()
      .trim();
  } catch (err) {
    throw new Error('Could not find diff files');
  }
};

const getCommit = () => {
  try {
    return execSync('git rev-parse --short HEAD')
      .toString()
      .trim();
  } catch (err) {
    throw new Error('Could not find git commit');
  }
};

const getCommitMessage = () => {
  try {
    return execSync('git log -1 --pretty=%B')
      .toString()
      .trim();
  } catch (err) {
    const { stack } = err || {};
    throw new Error('Could not get commit message', { stack });
  }
};

const getCommitAndBranch = async () => {
  const { stdout, stderr } = await exec(
    'git rev-parse --short HEAD && git rev-parse --abbrev-ref HEAD'
  );

  return stdout.split('\n');
};

const validateCommitOnRemote = ({ commit, branch }) => {
  try {
    execSync(`git branch -r --contains ${commit} | grep -i ${branch}`);
  } catch (e) {
    throw new Error(
      `Please make sure that the commit ${chalk.red(
        commit
      )} is on the remote branch ${chalk.red(branch)}`
    );
  }
};

const getDiffCurrentBranchOnRemote = () => {
  try {
    const branch = getBranch();
    return execSync(`git ls-remote --heads origin ${branch}`)
      .toString()
      .trim();
  } catch (e) {
    return false;
  }
};

const validateMergedWithMaster = async branch => {
  try {
    await exec('git fetch origin master');
    const { stdout } = await exec('git rev-parse origin/master');
    const masterCommit = stdout.trim();
    execSync(`git branch --contains ${masterCommit} | grep -i ${branch}`);
  } catch (e) {
    throw new Error(
      `Please make sure that you have pulled and merged/rebased ${chalk.cyan(
        'master'
      )} to your branch before deploying`
    );
  }
};

const validateGitIsClean = () => {
  const diff = execSync('git diff-index HEAD');
  if (diff.length) {
    throw new Error('Please commit all changes to git and try again.');
  }
};

const addAllAndCommitWithMessage = message =>
  exec(`git add . && git commit -m ${message}`);

const tag = tag => exec(`git tag ${tag}`);

const pushTagAndBranch = ({ tag, branch }) =>
  exec(`git push origin ${tag} && git push origin ${branch}`);

const makeAndPushTag = (tag, { pushArgs = '' } = {}) =>
  exec(`git tag "${tag}" && git push origin ${tag} ${pushArgs}`);

const listLatestTags = () => {
  execSync('git fetch origin');
  return execSync('git tag -l')
    .toString()
    .split('\n');
};

const isAlpha = version => version.includes('-alpha.');

const checkout = branch => execSync(`git checkout ${branch}`);

const checkoutOrCreate = branch =>
  execSync(`git checkout ${branch} || git checkout -b ${branch}`);

const resetHard = remoteBranch => execSync(`git reset --hard ${remoteBranch}`);

const pushForceUnsafe = branch =>
  execSync(`git push origin ${branch} --force --no-verify`, {
    stdio: 'inherit',
  });

const validateTagAndPush = tag =>
  getCommitAndBranch()
    .then(
      ([commit, branch]) => validateCommitOnRemote({ commit, branch }) && branch
    )
    .then(validateMergedWithMaster)
    .then(() => makeAndPushTag(tag));

module.exports = {
  getBranch,
  getCommit,
  getCommitMessage,
  getCommitAndBranch,
  getDiffFromRemote,
  validateCommitOnRemote,
  validateMergedWithMaster,
  validateGitIsClean,
  addAllAndCommitWithMessage,
  tag,
  pushTagAndBranch,
  makeAndPushTag,
  listLatestTags,
  isAlpha,
  checkout,
  checkoutOrCreate,
  resetHard,
  pushForceUnsafe,
  validateTagAndPush,
  getDiffCurrentBranchOnRemote,
  getDiffFromRemoteMaster,
  getDiffFromRemoteLastCommit,
};
