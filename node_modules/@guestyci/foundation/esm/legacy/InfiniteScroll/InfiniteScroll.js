import _extends from "@babel/runtime/helpers/esm/extends";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import memoize from '@guestyci/memoize';
import debounce from 'lodash/debounce';
import isNumber from 'lodash/isNumber';
import Spinner from "../Spinner/Spinner";
import CSSTransition from "../CSSTransiton";

var InfiniteScroll = /*#__PURE__*/function (_Component) {
  _inherits(InfiniteScroll, _Component);

  var _super = _createSuper(InfiniteScroll);

  function InfiniteScroll(props) {
    var _this;

    _classCallCheck(this, InfiniteScroll);

    _this = _super.call(this, props);
    _this.handleScrollEvent = debounce( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _this$props, pageCount, offset, scrollUp, _this$state, fetching, currentPage, element;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$props = _this.props, pageCount = _this$props.pageCount, offset = _this$props.offset, scrollUp = _this$props.scrollUp;
              _this$state = _this.state, fetching = _this$state.fetching, currentPage = _this$state.currentPage;

              if (pageCount && !fetching && pageCount > currentPage) {
                element = _this.scrollableEl;

                if (scrollUp) {
                  if (_this.isAtTop(element)) {
                    _this.fetchNextPage();
                  }
                } else if (_this.isAtBottom(element, offset)) {
                  _this.fetchNextPage();
                }
              }

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), 150);

    _this.isAtBottom = function (element) {
      var _this$props2 = _this.props,
          windowScroll = _this$props2.windowScroll,
          offset = _this$props2.offset;
      var el = !windowScroll ? element : document.documentElement;
      return el.scrollHeight - el.scrollTop - el.clientHeight <= offset;
    };

    _this.isAtTop = function (element) {
      var offset = _this.props.offset;
      return element ? element.scrollTop <= offset : window.scrollY <= offset;
    };

    _this.isInternalScroll = function () {
      var _this$props3 = _this.props,
          controlNode = _this$props3.controlNode,
          windowScroll = _this$props3.windowScroll;
      return !controlNode && !windowScroll;
    };

    _this.getWrapperStyle = memoize(function (style, height) {
      return _extends({}, style, {
        overflowY: _this.isInternalScroll() ? 'auto' : 'inherit',
        maxHeight: height
      });
    });
    var initialPage = _this.props.initialPage;
    _this.state = {
      currentPage: initialPage || 0,
      fetching: false
    };
    _this.scrollRef = React.createRef();
    return _this;
  }

  _createClass(InfiniteScroll, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.init();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props4 = this.props,
          pageCount = _this$props4.pageCount,
          page = _this$props4.page,
          isFetching = _this$props4.isFetching;
      var _this$state2 = this.state,
          currentPage = _this$state2.currentPage,
          fetching = _this$state2.fetching;

      if (!prevProps.pageCount && pageCount) {
        this.init();
      }

      if (isNumber(page) && prevProps.page !== page && currentPage !== page) {
        this.setCurrentPage(page);
      }

      if (prevProps.isFetching && !isFetching && fetching) {
        this.stopFetching();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.scrollableEl) {
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      }
    }
  }, {
    key: "setCurrentPage",
    value: function setCurrentPage(page) {
      this.setState({
        currentPage: page
      });
    }
  }, {
    key: "fetchNextPage",
    value: function fetchNextPage() {
      var _this2 = this;

      this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      this.setState(function (prevState) {
        return {
          currentPage: prevState.currentPage + 1,
          fetching: true
        };
      }, function () {
        var onLoadMore = _this2.props.onLoadMore;
        var currentPage = _this2.state.currentPage;
        onLoadMore(currentPage);
      });
    }
  }, {
    key: "stopFetching",
    value: function stopFetching() {
      this.setState({
        fetching: false
      });
      this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
    }
  }, {
    key: "init",
    value: function init() {
      var _this$props5 = this.props,
          pageCount = _this$props5.pageCount,
          windowScroll = _this$props5.windowScroll,
          controlNode = _this$props5.controlNode,
          initialPage = _this$props5.initialPage;

      if (pageCount) {
        this.scrollableEl = controlNode || windowScroll ? document.getElementById(controlNode) || window : this.scrollRef.current;
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
        this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
        this.setState({
          currentPage: initialPage || 0,
          fetching: false
        });
      } else if (this.scrollableEl) {
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          className = _this$props6.className,
          children = _this$props6.children,
          style = _this$props6.style,
          scrollUp = _this$props6.scrollUp,
          id = _this$props6.id,
          height = _this$props6.height,
          animation = _this$props6.animation;
      var _this$state3 = this.state,
          currentPage = _this$state3.currentPage,
          fetching = _this$state3.fetching;
      var wrapperStyle = this.getWrapperStyle(style, height);
      return /*#__PURE__*/React.createElement("div", {
        id: id,
        ref: this.scrollRef,
        className: cn('w-fill', 'infinite-scroll-container', 'flex-column', 'h-fill', className),
        style: wrapperStyle,
        "data-qa": "infinite-scroll"
      }, scrollUp && fetching && currentPage > 0 && /*#__PURE__*/React.createElement(Spinner, {
        className: "up w-fill height-30",
        small: true
      }), /*#__PURE__*/React.createElement(CSSTransition, {
        animation: animation,
        show: true
      }, children), !scrollUp && fetching && currentPage > 0 && /*#__PURE__*/React.createElement(Spinner, {
        className: "down w-fill height-30",
        small: true
      }));
    }
  }]);

  return InfiniteScroll;
}(Component);

InfiniteScroll.defaultProps = {
  initialPage: 0,
  id: '',
  scrollUp: false,
  offset: 200,
  className: '',
  style: {},
  height: undefined,
  controlNode: undefined,
  windowScroll: false,
  isFetching: false,
  page: undefined,
  animation: 'fade'
};
InfiniteScroll.propTypes = {
  /** Infinite scroll child components */
  children: PropTypes.node.isRequired,

  /** Additional class to infinite scroll root level */
  className: PropTypes.string,

  /** Height for infinite scroll (making it internal scroll) */
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Additional style for infinite scroll */
  style: PropTypes.shape(),

  /** Controller node id to handle the scroll (making scroll on the control element level) */
  controlNode: PropTypes.string,

  /** Initial page count */
  initialPage: PropTypes.number,

  /** Callback for load more elements - IMPORTANT  -->
   CB awaits api result, you must return after api call to clear fetching mode */
  onLoadMore: PropTypes.func.isRequired,

  /** Total page count (limit * skip) */
  pageCount: PropTypes.number.isRequired,

  /** Id for the root of the infinite scroll */
  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Indicator whether or not to fetch on scroll up or down */
  scrollUp: PropTypes.bool,

  /** Offset bottom before re-fetch */
  offset: PropTypes.number,

  /** Indicator whether or not we want scroll on the window level or the component level */
  windowScroll: PropTypes.bool,

  /** Indicator showing if fetching more */
  isFetching: PropTypes.bool,

  /** Prop to make infinite scroll controlled */
  page: PropTypes.number,

  /** control infinite scroll animation */
  animation: PropTypes.string
};
export default InfiniteScroll;