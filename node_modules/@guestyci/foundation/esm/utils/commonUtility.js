import _escapeRegExp from 'lodash/escapeRegExp';
import decode from 'jwt-decode';
import isNil from 'lodash/isNil';
import isFinite from 'lodash/isFinite';
import _isNumber from 'lodash/isNumber';
import _isEmpty from 'lodash/isEmpty';
import currencySymbolsMapper from "../constants/currencySymbols";
/**
 * Generate a GUID
 * @returns {string}
 */

export var uuid = function uuid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }

  return "".concat(s4() + s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4()).concat(s4()).concat(s4());
};
/**
 * Set a name to a pair on initials
 * @param input {String} The name to manipulate
 * @returns {String}
 */

export function nameToInitials(input) {
  var name = isNil(input) ? '' : input.toUpperCase();
  return name && name.replace(/[\W_][ ]+/g, '').split(' ').slice(0, 2).map(function (word) {
    return word.charAt(0);
  }).join('');
}
/**
 * Check if string value is a valid number
 * @param str {String | Number}  The string to test
 * @returns {Boolean}
 */

export function isNumber() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (_isNumber(str)) {
    return true;
  }

  if (_isEmpty(str)) {
    return false;
  }

  if (str.length === 1) {
    return RegExp(/^[0-9.]+$/).test(str);
  }

  return isFinite(+str);
}
/**
 * Convert a string into Number (float)
 * @param str {String|Number}  The value to parse
 * @param catchValue {String | Number} value to return if cast to number fails, defaults to NaN
 * @returns {number} Number if valid number string otherwise NaN
 */

export function parseNumber(str) {
  var catchValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;

  if (isNumber(str)) {
    return +str;
  }

  return Number(str) || catchValue;
}
/**
 * Convert and array to a Map
 * @param array {Array} an array to map
 * @param key {*} the value to key by
 * @returns {Map} a new map
 */

export function toMap() {
  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var key = arguments.length > 1 ? arguments[1] : undefined;
  return new Map(array.map(function (item) {
    return [item[key] || item, item];
  }));
}
/**
 * Create a delay mechanism
 * @param ms  {Number}  Milliseconds to delay
 * @return {Promise<any>}
 */

export var sleep = function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
};
/**
 * Escape string for RegExp
 * uses lodash escapeRegExp util
 * @param str  {String}  string to escape
 * @return {String}
 */

export var escapeRegExp = function escapeRegExp(str) {
  return _escapeRegExp(str);
};
/**
 * First letter to uppercase
 * @param text {String}  string to manipulate
 * @return {String}
 */

export var firstLetterUppercase = function firstLetterUppercase(text) {
  return text.slice(0, 1).toUpperCase() + text.slice(1, text.length);
};
/**
 * Capitalize first letter
 * @param text {String}  string to manipulate
 * @return {String}
 */

export var capitalize = function capitalize() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return text.slice(0, 1).toUpperCase() + text.slice(1, text.length);
};
/**
 * Currency symbols mapper
 */

export var currencySymbols = currencySymbolsMapper;
/**
 * Perform async debounce
 * @param f {Function}  Function to debounce
 * @param interval  {Number}  Milliseconds to interval
 * @return {function(...[*]=): Promise<any>}
 */

export function asyncDebounce(f, interval) {
  var timer = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timer);
    return new Promise(function (resolve) {
      timer = setTimeout(function () {
        return resolve(f.apply(void 0, args));
      }, interval);
    });
  };
}
/**
 * Get the user data from the JWT token
 * @returns {Object || null} The decoded token data
 */

export function getUserData() {
  var token = JSON.parse(window.localStorage.getItem('token'));

  if (token) {
    try {
      return decode(token);
    } catch (err) {
      console.error('getUserData Failed to fetch userData from token', err.stack);
      return null;
    }
  }
}
/**
 * Bullet proof is empty to also check numbers
 * @param value
 * @return {boolean}
 */

export function isEmpty(value) {
  return !_isNumber(value) && _isEmpty(value);
}
/**
 * Link to url
 * @param location  {String}  The full path for the link
 * @param isNewTab  {Boolean} Indicator whether or not to show in new tab ( auto - true)
 */

export function link(location) {
  var isNewTab = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (isNewTab) {
    window.open(location, '_blank');
  } else {
    window.location.replace(location);
  }
}
export var snakeToCamel = function snakeToCamel(str) {
  return str.replace(/([-][a-z])/g, function (group) {
    return group.toUpperCase().replace('-', '');
  });
};