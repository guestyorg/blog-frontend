"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _memoize = _interopRequireDefault(require("@guestyci/memoize"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

var _isNumber = _interopRequireDefault(require("lodash/isNumber"));

var _Spinner = _interopRequireDefault(require("../Spinner/Spinner"));

var _CSSTransiton = _interopRequireDefault(require("../CSSTransiton"));

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var InfiniteScroll = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(InfiniteScroll, _Component);

  var _super = _createSuper(InfiniteScroll);

  function InfiniteScroll(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, InfiniteScroll);
    _this = _super.call(this, props);
    _this.handleScrollEvent = (0, _debounce["default"])( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
      var _this$props, pageCount, offset, scrollUp, _this$state, fetching, currentPage, element;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$props = _this.props, pageCount = _this$props.pageCount, offset = _this$props.offset, scrollUp = _this$props.scrollUp;
              _this$state = _this.state, fetching = _this$state.fetching, currentPage = _this$state.currentPage;

              if (pageCount && !fetching && pageCount > currentPage) {
                element = _this.scrollableEl;

                if (scrollUp) {
                  if (_this.isAtTop(element)) {
                    _this.fetchNextPage();
                  }
                } else if (_this.isAtBottom(element, offset)) {
                  _this.fetchNextPage();
                }
              }

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), 150);

    _this.isAtBottom = function (element) {
      var _this$props2 = _this.props,
          windowScroll = _this$props2.windowScroll,
          offset = _this$props2.offset;
      var el = !windowScroll ? element : document.documentElement;
      return el.scrollHeight - el.scrollTop - el.clientHeight <= offset;
    };

    _this.isAtTop = function (element) {
      var offset = _this.props.offset;
      return element ? element.scrollTop <= offset : window.scrollY <= offset;
    };

    _this.isInternalScroll = function () {
      var _this$props3 = _this.props,
          controlNode = _this$props3.controlNode,
          windowScroll = _this$props3.windowScroll;
      return !controlNode && !windowScroll;
    };

    _this.getWrapperStyle = (0, _memoize["default"])(function (style, height) {
      return (0, _extends2["default"])({}, style, {
        overflowY: _this.isInternalScroll() ? 'auto' : 'inherit',
        maxHeight: height
      });
    });
    var initialPage = _this.props.initialPage;
    _this.state = {
      currentPage: initialPage || 0,
      fetching: false
    };
    _this.scrollRef = _react["default"].createRef();
    return _this;
  }

  (0, _createClass2["default"])(InfiniteScroll, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.init();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props4 = this.props,
          pageCount = _this$props4.pageCount,
          page = _this$props4.page,
          isFetching = _this$props4.isFetching;
      var _this$state2 = this.state,
          currentPage = _this$state2.currentPage,
          fetching = _this$state2.fetching;

      if (!prevProps.pageCount && pageCount) {
        this.init();
      }

      if ((0, _isNumber["default"])(page) && prevProps.page !== page && currentPage !== page) {
        this.setCurrentPage(page);
      }

      if (prevProps.isFetching && !isFetching && fetching) {
        this.stopFetching();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.scrollableEl) {
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      }
    }
  }, {
    key: "setCurrentPage",
    value: function setCurrentPage(page) {
      this.setState({
        currentPage: page
      });
    }
  }, {
    key: "fetchNextPage",
    value: function fetchNextPage() {
      var _this2 = this;

      this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      this.setState(function (prevState) {
        return {
          currentPage: prevState.currentPage + 1,
          fetching: true
        };
      }, function () {
        var onLoadMore = _this2.props.onLoadMore;
        var currentPage = _this2.state.currentPage;
        onLoadMore(currentPage);
      });
    }
  }, {
    key: "stopFetching",
    value: function stopFetching() {
      this.setState({
        fetching: false
      });
      this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
    }
  }, {
    key: "init",
    value: function init() {
      var _this$props5 = this.props,
          pageCount = _this$props5.pageCount,
          windowScroll = _this$props5.windowScroll,
          controlNode = _this$props5.controlNode,
          initialPage = _this$props5.initialPage;

      if (pageCount) {
        this.scrollableEl = controlNode || windowScroll ? document.getElementById(controlNode) || window : this.scrollRef.current;
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
        this.scrollableEl.addEventListener('scroll', this.handleScrollEvent);
        this.setState({
          currentPage: initialPage || 0,
          fetching: false
        });
      } else if (this.scrollableEl) {
        this.scrollableEl.removeEventListener('scroll', this.handleScrollEvent);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          className = _this$props6.className,
          children = _this$props6.children,
          style = _this$props6.style,
          scrollUp = _this$props6.scrollUp,
          id = _this$props6.id,
          height = _this$props6.height,
          animation = _this$props6.animation;
      var _this$state3 = this.state,
          currentPage = _this$state3.currentPage,
          fetching = _this$state3.fetching;
      var wrapperStyle = this.getWrapperStyle(style, height);
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: id,
        ref: this.scrollRef,
        className: (0, _classnames["default"])('w-fill', 'infinite-scroll-container', 'flex-column', 'h-fill', className),
        style: wrapperStyle,
        "data-qa": "infinite-scroll"
      }, scrollUp && fetching && currentPage > 0 && /*#__PURE__*/_react["default"].createElement(_Spinner["default"], {
        className: "up w-fill height-30",
        small: true
      }), /*#__PURE__*/_react["default"].createElement(_CSSTransiton["default"], {
        animation: animation,
        show: true
      }, children), !scrollUp && fetching && currentPage > 0 && /*#__PURE__*/_react["default"].createElement(_Spinner["default"], {
        className: "down w-fill height-30",
        small: true
      }));
    }
  }]);
  return InfiniteScroll;
}(_react.Component);

InfiniteScroll.defaultProps = {
  initialPage: 0,
  id: '',
  scrollUp: false,
  offset: 200,
  className: '',
  style: {},
  height: undefined,
  controlNode: undefined,
  windowScroll: false,
  isFetching: false,
  page: undefined,
  animation: 'fade'
};
InfiniteScroll.propTypes = {
  /** Infinite scroll child components */
  children: _propTypes["default"].node.isRequired,

  /** Additional class to infinite scroll root level */
  className: _propTypes["default"].string,

  /** Height for infinite scroll (making it internal scroll) */
  height: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),

  /** Additional style for infinite scroll */
  style: _propTypes["default"].shape(),

  /** Controller node id to handle the scroll (making scroll on the control element level) */
  controlNode: _propTypes["default"].string,

  /** Initial page count */
  initialPage: _propTypes["default"].number,

  /** Callback for load more elements - IMPORTANT  -->
   CB awaits api result, you must return after api call to clear fetching mode */
  onLoadMore: _propTypes["default"].func.isRequired,

  /** Total page count (limit * skip) */
  pageCount: _propTypes["default"].number.isRequired,

  /** Id for the root of the infinite scroll */
  id: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),

  /** Indicator whether or not to fetch on scroll up or down */
  scrollUp: _propTypes["default"].bool,

  /** Offset bottom before re-fetch */
  offset: _propTypes["default"].number,

  /** Indicator whether or not we want scroll on the window level or the component level */
  windowScroll: _propTypes["default"].bool,

  /** Indicator showing if fetching more */
  isFetching: _propTypes["default"].bool,

  /** Prop to make infinite scroll controlled */
  page: _propTypes["default"].number,

  /** control infinite scroll animation */
  animation: _propTypes["default"].string
};
var _default = InfiniteScroll;
exports["default"] = _default;