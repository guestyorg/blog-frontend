import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { useState, useMemo, useCallback } from 'react';
import { createUseStyles } from 'react-jss';
import cn from 'classnames';
import PropTypes from 'prop-types';
import { Transition, TransitionGroup } from 'react-transition-group';
import Portal from "../Portal/Portal";
import Col from "../Col";
import { VARIANTS_NAMES } from "./Toast";
import StackedToast from "./StackedToast";
import context from "./context";
import { uuid } from "../../utils/commonUtility";
import zIndex from "../../theme/zIndex";
var Provider = context.Provider;
var useStyles = createUseStyles({
  wrapper: {
    position: 'fixed',
    left: 'auto',
    right: 24,
    top: 24,
    zIndex: zIndex.toast
  }
});

var ToastProvider = function ToastProvider(_ref) {
  var children = _ref.children,
      className = _ref.className,
      duration = _ref.duration;

  var _useStyles = useStyles(),
      wrapper = _useStyles.wrapper;

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      toasts = _useState2[0],
      setToasts = _useState2[1];

  var dismissToast = useCallback(function (id) {
    setToasts(function (_toasts) {
      return _toasts.filter(function (_toast) {
        return _toast.id !== id;
      });
    });
  }, [setToasts]);
  var ctx = useMemo(function () {
    var addToast = VARIANTS_NAMES.reduce(function (acc, variant) {
      acc[variant] = function (message) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var id = uuid();
        var autoHide = options.autoHide,
            autoHideDelay = options.autoHideDelay,
            action = options.action;

        var onDismiss = function onDismiss() {
          return dismissToast(id);
        };

        setToasts(function (_toasts) {
          return [].concat(_toConsumableArray(_toasts), [{
            autoHide: autoHide,
            autoHideDelay: autoHideDelay,
            action: action,
            variant: variant,
            message: message,
            id: id,
            onDismiss: onDismiss
          }]);
        });
        return onDismiss;
      };

      return acc;
    }, {});
    return {
      addToast: addToast
    };
  }, [setToasts, dismissToast]);
  return /*#__PURE__*/React.createElement(Provider, {
    value: ctx,
    "data-qa": "toast-provider"
  }, children, /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(Col, {
    spacing: 1,
    className: cn(wrapper, className)
  }, /*#__PURE__*/React.createElement(TransitionGroup, {
    component: null
  }, toasts === null || toasts === void 0 ? void 0 : toasts.map(function (props) {
    return /*#__PURE__*/React.createElement(Transition, {
      key: props.id,
      unmountOnExit: true,
      timeout: duration,
      mountOnEnter: true,
      appear: true
    }, function (transitionState) {
      return /*#__PURE__*/React.createElement(StackedToast, _extends({}, props, {
        transition: transitionState,
        duration: duration
      }));
    });
  })))));
};

ToastProvider.defaultProps = {
  duration: 300,
  className: ''
};
ToastProvider.propTypes = {
  /** Wrapper className */
  className: PropTypes.string,

  /** App tree | Consumer target */
  children: PropTypes.node.isRequired,

  /** Animation duration */
  duration: PropTypes.number
};
export default ToastProvider;