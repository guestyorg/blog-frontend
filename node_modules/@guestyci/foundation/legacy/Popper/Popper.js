"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.getOriginDirection = exports.getAnchorDirection = exports.getTransformDirection = exports.getPortalWidth = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _debounce = _interopRequireDefault(require("lodash/debounce"));

var _enums = require("../../enums");

var _Portal = _interopRequireDefault(require("../Portal"));

var _createStyles = _interopRequireDefault(require("../../createStyles"));

var _CSSTransition = _interopRequireDefault(require("../../CSSTransition"));

var anchorTransformOriginMapper = {
  start: 'left',
  end: 'right',
  center: 'center'
};
var originTransformOriginMapper = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
var useStyles = (0, _createStyles["default"])(function (theme) {
  return {
    backdrop: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      zIndex: theme.zIndex.dropdown - 1,
      position: 'fixed',
      touchAction: 'none',
      backgroundColor: 'transparent'
    },
    innerContent: {
      position: 'absolute',
      zIndex: theme.zIndex.dropdown
    }
  };
}, {
  name: 'PortalAutoPosition'
});

var getPortalWidth = function getPortalWidth(isFit, contentOffsetWidth, parentWidth) {
  if (!isFit) {
    return;
  }

  return contentOffsetWidth >= parentWidth ? contentOffsetWidth : parentWidth;
};

exports.getPortalWidth = getPortalWidth;

var isInYViewPort = function isInYViewPort(offsetHeight) {
  return offsetHeight < window.scrollY + (window.innerHeight || document.documentElement.clientHeight);
};

var getWindowWidth = function getWindowWidth() {
  return window.innerWidth || document.documentElement.clientWidth;
};

var getTransformDirection = function getTransformDirection(direction, anchor) {
  var isVertical = direction === _enums.OriginDirectionType.Left || direction === _enums.OriginDirectionType.Right;
  var transformX = anchorTransformOriginMapper[anchor];
  var originDirection = originTransformOriginMapper[direction];
  var anchorDirection = transformX;

  if (isVertical) {
    switch (anchor) {
      case _enums.AnchorDirectionType.End:
        anchorDirection = _enums.OriginDirectionType.Bottom;
        break;

      case _enums.AnchorDirectionType.Start:
        anchorDirection = _enums.OriginDirectionType.Top;
        break;

      default:
        break;
    }
  }

  return "".concat(originDirection, " ").concat(anchorDirection);
};

exports.getTransformDirection = getTransformDirection;

var getAnchorDirection = function getAnchorDirection(anchorDirection, originDirection, anchorPosition, contentPosition) {
  var anchorLeft = anchorPosition.left,
      anchorTop = anchorPosition.top,
      anchorWidth = anchorPosition.width,
      anchorOffsetWidth = anchorPosition.offsetWidth,
      anchorOffsetHeight = anchorPosition.offsetHeight;
  var contentOffsetHeight = contentPosition.offsetHeight,
      contentOffsetWidth = contentPosition.offsetWidth;
  var direction = anchorDirection;
  var isVertical = originDirection === _enums.OriginDirectionType.Left || originDirection === _enums.OriginDirectionType.Right;
  var position = {};
  var inRightViewPort = anchorLeft + contentOffsetWidth <= getWindowWidth();
  var inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) >= 0;

  if (!inLeftViewPort && inRightViewPort) {
    direction = _enums.AnchorDirectionType.Start;
  }

  if (inLeftViewPort && !inRightViewPort) {
    direction = _enums.AnchorDirectionType.End;
  }

  if (!inLeftViewPort && !inRightViewPort) {
    direction = _enums.AnchorDirectionType.Center;
  }

  switch (direction) {
    case _enums.AnchorDirectionType.Center:
      position = {
        left: anchorLeft + anchorOffsetWidth / 2 - contentOffsetWidth / 2
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight / 2 + window.scrollY - contentOffsetHeight / 2
        };
      }

      break;

    case _enums.AnchorDirectionType.End:
      position = {
        left: anchorLeft - (contentOffsetWidth - anchorWidth)
      };

      if (isVertical) {
        position = {
          top: anchorTop + anchorOffsetHeight - contentOffsetHeight + window.scrollY
        };
      }

      break;

    case _enums.AnchorDirectionType.Start:
      position = {
        left: anchorLeft
      };

      if (isVertical) {
        position = {
          top: anchorTop + window.scrollY
        };
      }

      break;

    default:
      break;
  }

  return {
    anchorDirection: direction,
    position: position
  };
};

exports.getAnchorDirection = getAnchorDirection;

var getOriginDirection = function getOriginDirection(originDirection, anchorPosition, contentPosition) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var anchorTop = anchorPosition.top,
      anchorLeft = anchorPosition.left,
      anchorOffsetHeight = anchorPosition.offsetHeight,
      anchorOffsetWidth = anchorPosition.offsetWidth;
  var contentOffsetHeight = contentPosition.offsetHeight,
      contentOffsetWidth = contentPosition.offsetWidth;
  var direction = originDirection;
  var position = {};
  var inRightViewPort = offset + anchorLeft + anchorOffsetWidth + contentOffsetWidth < getWindowWidth();
  var inLeftViewPort = anchorLeft - (anchorOffsetWidth + contentOffsetWidth) > offset;
  var inTopViewPort = anchorTop - contentOffsetHeight > offset;
  var inBottomViewPort = isInYViewPort(offset + anchorTop + window.scrollY + contentOffsetHeight);

  if (direction === _enums.OriginDirectionType.Top && !inTopViewPort) {
    direction = _enums.OriginDirectionType.Bottom;
  } else if (direction === _enums.OriginDirectionType.Bottom && !inBottomViewPort) {
    direction = _enums.OriginDirectionType.Top;
  }

  if (direction === _enums.OriginDirectionType.Left && !inLeftViewPort) {
    direction = _enums.OriginDirectionType.Right;
  } else if (direction === _enums.OriginDirectionType.Right && !inRightViewPort) {
    direction = _enums.OriginDirectionType.Left;
  }

  switch (direction) {
    case _enums.OriginDirectionType.Left:
      position = {
        left: anchorLeft - contentOffsetWidth - offset
      };
      break;

    case _enums.OriginDirectionType.Right:
      position = {
        left: anchorLeft + anchorOffsetWidth + offset
      };
      break;

    case _enums.OriginDirectionType.Top:
      position = {
        top: anchorTop - contentOffsetHeight + window.scrollY - offset
      };
      break;

    case _enums.OriginDirectionType.Bottom:
      position = {
        top: anchorTop + anchorOffsetHeight + window.scrollY + offset
      };
      break;

    default:
      break;
  }

  return {
    position: position,
    originDirection: direction
  };
};

exports.getOriginDirection = getOriginDirection;

var Popper = _react["default"].forwardRef(function PortalAutoPosition(_ref, ref) {
  var anchor = _ref.anchor,
      _ref$anchorDirection = _ref.anchorDirection,
      anchorDirection = _ref$anchorDirection === void 0 ? _enums.AnchorDirectionType.Start : _ref$anchorDirection,
      backdrop = _ref.backdrop,
      children = _ref.children,
      _ref$transition = _ref.transition,
      transition = _ref$transition === void 0 ? 'no-transition' : _ref$transition,
      trigger = _ref.trigger,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$originDirection = _ref.originDirection,
      originDirection = _ref$originDirection === void 0 ? _enums.OriginDirectionType.Top : _ref$originDirection,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? undefined : _ref$width,
      _ref$fitAnchor = _ref.fitAnchor,
      fitAnchor = _ref$fitAnchor === void 0 ? false : _ref$fitAnchor,
      props = (0, _objectWithoutProperties2["default"])(_ref, ["anchor", "anchorDirection", "backdrop", "children", "transition", "trigger", "offset", "originDirection", "width", "fitAnchor"]);
  var classes = useStyles();
  var contentRef = (0, _react.useRef)(null);
  var controlRef = (0, _react.useRef)();

  var _useState = (0, _react.useState)({}),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      position = _useState2[0],
      setPosition = _useState2[1];

  var getContentPositionStyles = (0, _react.useCallback)(function () {
    var contentEl = contentRef.current;
    var anchorEl = anchor.current;

    var _ref2 = anchorEl || {},
        offsetHeight = _ref2.offsetHeight,
        offsetWidth = _ref2.offsetWidth;

    var _anchorEl$getBounding = anchorEl.getBoundingClientRect(),
        left = _anchorEl$getBounding.left,
        anchorWidth = _anchorEl$getBounding.width,
        top = _anchorEl$getBounding.top;

    var contentWidth = contentEl.width,
        contentOffsetWidth = contentEl.offsetWidth,
        contentOffsetHeight = contentEl.offsetHeight;

    var _getOriginDirection = getOriginDirection(originDirection, {
      top: top,
      left: left,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    }, offset),
        originPosition = _getOriginDirection.position,
        calculatedOriginDirection = _getOriginDirection.originDirection;

    var _getAnchorDirection = getAnchorDirection(anchorDirection, calculatedOriginDirection, {
      left: left,
      width: anchorWidth,
      offsetWidth: offsetWidth,
      top: top,
      offsetHeight: offsetHeight
    }, {
      width: contentWidth,
      offsetHeight: contentOffsetHeight,
      offsetWidth: contentOffsetWidth
    }),
        anchorLeftPosition = _getAnchorDirection.position,
        calculatedAnchorDirection = _getAnchorDirection.anchorDirection;

    var transformOrigin = getTransformDirection(calculatedOriginDirection, calculatedAnchorDirection);
    controlRef.current = {
      contentOffsetHeight: contentOffsetHeight,
      anchorOffsetHeight: offsetHeight
    };
    return (0, _extends2["default"])({}, anchorLeftPosition, {}, originPosition, {
      transformOrigin: transformOrigin,
      width: width || getPortalWidth(fitAnchor, contentOffsetWidth, anchorWidth)
    });
  }, [contentRef, anchor, anchorDirection, originDirection, offset, fitAnchor]);
  (0, _react.useEffect)(function () {
    if (!trigger) {
      return undefined;
    }

    if ((anchor === null || anchor === void 0 ? void 0 : anchor.current) && (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
      setPosition(getContentPositionStyles());
    }
  }, [trigger]);
  (0, _react.useEffect)(function () {
    if (!trigger || !(contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
      return undefined;
    }

    var currentContentOffsetHeight = contentRef.current.offsetHeight;
    var currentAnchorOffsetHeight = anchor.current.offsetHeight;
    var _controlRef$current = controlRef.current,
        contentOffsetHeight = _controlRef$current.contentOffsetHeight,
        anchorOffsetHeight = _controlRef$current.anchorOffsetHeight;

    if (currentContentOffsetHeight !== contentOffsetHeight || currentAnchorOffsetHeight !== anchorOffsetHeight) {
      setPosition(getContentPositionStyles());
    }
  }, [children, anchor]);

  _react["default"].useEffect(function () {
    var handleResize = (0, _debounce["default"])(function () {
      if ((anchor === null || anchor === void 0 ? void 0 : anchor.current) && (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current)) {
        setPosition(getContentPositionStyles());
      }
    }, 250);
    window.addEventListener('resize', handleResize);
    return function () {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return /*#__PURE__*/_react["default"].createElement(_Portal["default"], {
    ref: ref
  }, trigger && backdrop && /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.backdrop
  }), /*#__PURE__*/_react["default"].createElement(_CSSTransition["default"], (0, _extends2["default"])({}, props, {
    unmountOnExit: true,
    animation: transition,
    show: trigger,
    style: (0, _extends2["default"])({}, position)
  }), /*#__PURE__*/_react["default"].createElement("span", {
    className: classes.innerContent,
    ref: contentRef
  }, children)));
});

Popper.propTypes = {
  /** Anchor element to append to */
  anchor: _propTypes["default"].oneOfType([_propTypes["default"].node, _propTypes["default"].func, _propTypes["default"].shape()]),

  /** Animation for css transition  - defaults to none */
  transition: _propTypes["default"].oneOfType([_propTypes["default"].shape({
    appear: _propTypes["default"].string,
    appearActive: _propTypes["default"].string,
    enter: _propTypes["default"].string.isRequired,
    enterActive: _propTypes["default"].string.isRequired,
    enterDone: _propTypes["default"].string,
    exitActive: _propTypes["default"].string.isRequired,
    exit: _propTypes["default"].string.isRequired,
    exitDone: _propTypes["default"].string
  }), _propTypes["default"].string]),

  /** Child node for the auto position to reference and wrap */
  children: _propTypes["default"].oneOfType([_propTypes["default"].node, _propTypes["default"].arrayOf(_propTypes["default"].node)]).isRequired,

  /** Indicator when to re calculate the position */
  trigger: _propTypes["default"].bool,

  /** Additional class to root level */
  className: _propTypes["default"].string,

  /** Additional style to root level */
  style: _propTypes["default"].shape(),

  /** Direction to open the content relative to anchor (center, end ,start) */
  anchorDirection: _propTypes["default"].oneOf([_enums.AnchorDirectionType.Center, _enums.AnchorDirectionType.Start, _enums.AnchorDirectionType.End]),

  /** Direction to open the content relative to origin (Top bottom left right) */
  originDirection: _propTypes["default"].oneOf([_enums.OriginDirectionType.Top, _enums.OriginDirectionType.Bottom, _enums.OriginDirectionType.Left, _enums.OriginDirectionType.Right]),

  /** Allow backdrop when showing portal */
  backdrop: _propTypes["default"].bool,

  /** offset to locate the content from anchor */
  offset: _propTypes["default"].number,

  /** Boolean flag to fix content width with anchor width - by default fits content width */
  fitAnchor: _propTypes["default"].bool,

  /** Set content width manually - by default it will resolve to the larger of the input width or the content width */
  width: _propTypes["default"].number
};
Popper.displayName = 'Popper';
var _default = Popper;
exports["default"] = _default;