import { useCallback, useEffect, useRef, useState } from 'react';

function useDrag(payload, onDrop, isDraggable = false) {
  const dragRef = useRef();
  const [isDragging, setIsDragging] = useState(false);
  const [isDragOver, setIsDragOver] = useState(false);
  const handleDragStart = useCallback(e => {
    e.stopPropagation();
    e.dataTransfer.setData('text', JSON.stringify(payload));
    e.dataTransfer.dropEffect = 'move';
    setIsDragging(true);
    setIsDragOver(false);
  }, [payload, setIsDragging, setIsDragOver]);
  const handleDragOver = useCallback(e => {
    e.preventDefault();
    setIsDragOver(true);
  }, [setIsDragOver]);
  const handleDragDrop = useCallback(e => {
    e.preventDefault();
    const data = JSON.parse(e.dataTransfer.getData('text'));
    setIsDragging(false);
    setIsDragOver(false);

    if (onDrop) {
      onDrop({
        sourceData: data,
        targetData: payload
      });
    }
  }, [payload, onDrop, setIsDragOver, setIsDragging]);
  useEffect(() => {
    const node = dragRef.current;

    if (node && isDraggable) {
      node.draggable = true;
      node.addEventListener('dragstart', handleDragStart);
      node.addEventListener('drop', handleDragDrop);
      node.addEventListener('dragover', handleDragOver);
      return () => {
        node.draggable = false;
        node.removeEventListener('dragstart', handleDragStart);
        node.removeEventListener('drop', handleDragDrop);
        node.removeEventListener('dragover', handleDragOver);
      };
    }
  }, [payload, isDraggable, handleDragDrop, handleDragStart, handleDragOver]);
  return [{
    isDragging,
    isDragOver
  }, dragRef];
}

export default useDrag;