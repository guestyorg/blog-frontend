import { useCallback, useEffect, useRef } from 'react';
var allowedScrollKeys = new Set(['ArrowUp', 'ArrowDown', 'Home', 'End']);
var allowedKeys = new Set(['ArrowUp', 'ArrowDown', 'Home', 'End', 'Enter']);

var isVisible = function isVisible(menu, el) {
  var menuHeight = menu.offsetHeight;
  var menuScrollOffset = menu.scrollTop;
  var elemTop = el.offsetTop - menu.offsetTop;
  var elemBottom = elemTop + el.offsetHeight;
  return elemTop >= menuScrollOffset && elemBottom <= menuScrollOffset + menuHeight;
};
/**
 * React hook to support key navigation
 * @param menuRef -{ React Ref }- ref for the menu / list which holds the menu items
 * @param anchorRef -{ React Ref }-  the focusable trigger for the menu to be shown
 * @param options -{ Object }-  {
 * activeClassName = 'active',
 * onKeyDown = null,
 * preventDefault = false,
 * clearActive {boolean} - boolean indicator to clear active item when true. (toggle for change)
 * }
 * @return {Array}
 */


var useArrowNavigation = function useArrowNavigation(menuRef, anchorRef) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var activeRef = useRef(null);
  var _options$activeClassN = options.activeClassName,
      activeClassName = _options$activeClassN === void 0 ? 'active' : _options$activeClassN,
      onKeyDown = options.onKeyDown,
      preventDefault = options.preventDefault,
      _options$clearActive = options.clearActive,
      clearActive = _options$clearActive === void 0 ? false : _options$clearActive;

  var scrollTo = function scrollTo(activeEl) {
    var menuCurrent = menuRef.current;

    if (!isVisible(menuCurrent, activeEl)) {
      menuCurrent.scroll({
        top: activeEl.offsetTop
      });
    }
  };

  var clearActiveItem = function clearActiveItem() {
    activeRef.current = null;
  };

  var getActiveCurrent = function getActiveCurrent() {
    return activeRef.current;
  };

  useEffect(function () {
    if (clearActive) {
      clearActiveItem();
    }
  }, [clearActive]);
  var handleKeyDown = useCallback(function (e) {
    if (preventDefault) {
      e.preventDefault();
    }

    var key = e.key;
    var menuCurrent = menuRef.current;
    var activeCurrent = getActiveCurrent();
    var anchorCurrent = anchorRef.current;

    if (onKeyDown) {
      onKeyDown(e);
    }

    if (!menuCurrent || !anchorCurrent || !allowedKeys.has(key)) {
      return;
    }

    if (allowedScrollKeys.has(key) && (anchorCurrent === activeCurrent || !activeCurrent)) {
      activeRef.current = menuCurrent.firstChild;
      activeRef.current.classList.toggle(activeClassName);
      return;
    }

    if (activeCurrent) {
      activeCurrent.classList.toggle(activeClassName);
    }

    switch (key) {
      case 'Home':
        activeRef.current = menuCurrent.firstChild;
        break;

      case 'End':
        activeRef.current = menuCurrent.lastChild;
        break;

      case 'ArrowDown':
        if (activeCurrent.nextElementSibling) {
          activeRef.current = activeCurrent.nextElementSibling;
        } else {
          activeRef.current = menuCurrent.firstChild;
        }

        break;

      case 'ArrowUp':
        if (activeCurrent.previousElementSibling) {
          activeRef.current = activeCurrent.previousElementSibling;
        } else {
          activeRef.current = menuCurrent.lastChild;
        }

        break;

      case 'Enter':
        if (activeCurrent) {
          activeCurrent.click();
        }

        break;

      default:
        break;
    }

    if (allowedScrollKeys.has(key) && (activeRef === null || activeRef === void 0 ? void 0 : activeRef.current)) {
      activeRef.current.classList.toggle(activeClassName);
      scrollTo(activeRef.current);
    }
  }, [activeRef.current]);
  return [handleKeyDown, activeRef];
};

export default useArrowNavigation;