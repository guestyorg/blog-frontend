import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import React from 'react';
import { isEmpty } from "../../utils";
import cn from 'classnames';
var MULTI_SELECT_OFFSET = 36;
export var getColumnCells = function getColumnCells() {
  var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var dataKey = props.dataKey,
      resizable = props.resizable,
      commonProps = _objectWithoutProperties(props, ["dataKey", "resizable"]);

  if (!Array.isArray(cells) || cells.length < 2) {
    throw new Error("Components <HeaderCell> and <Cell> are required, column: ".concat(dataKey));
  }

  return {
    header: React.cloneElement(cells[0], _extends({
      id: dataKey,
      resizable: resizable
    }, commonProps)),
    cell: React.cloneElement(cells[1], _extends({
      dataKey: dataKey
    }, commonProps))
  };
};
export var getFixedColClassName = function getFixedColClassName(fixedDirection, index, length, isMultiSelect) {
  var className = "fixed-cell-group cell-group cell-group-".concat(fixedDirection);

  if (index === 0) {
    className = "".concat(className, " cell-group-item-first ").concat(isMultiSelect ? 'cell-group-item-no-padding' : '');
  }

  if (index === length) {
    className = "".concat(className, " cell-group-item-last");
  }

  return className;
};
export var buildCellGroups = function buildCellGroups(columns) {
  return columns.reduce(function (_ref, col) {
    var _ref2 = _slicedToArray(_ref, 3),
        left = _ref2[0],
        center = _ref2[1],
        right = _ref2[2];

    var _col$props = col === null || col === void 0 ? void 0 : col.props,
        fixed = _col$props.fixed;

    if (fixed === 'left') {
      left.push(col);
    } else if (fixed === 'right') {
      right.push(col);
    } else {
      center.push(col);
    }

    return [left, center, right];
  }, [[], [], []]);
};
export var serializeColumns = function serializeColumns(cols, isMultiSelect) {
  var _buildCellGroups = buildCellGroups(cols),
      _buildCellGroups2 = _slicedToArray(_buildCellGroups, 3),
      leftColumns = _buildCellGroups2[0],
      centerColumns = _buildCellGroups2[1],
      rightColumns = _buildCellGroups2[2];

  if (!isEmpty(leftColumns)) {
    var columns = _toConsumableArray(leftColumns);

    var offset = isMultiSelect ? MULTI_SELECT_OFFSET : 0;
    columns.forEach(function (col, index) {
      var _col$props2 = col.props,
          width = _col$props2.width,
          fixed = _col$props2.fixed,
          className = _col$props2.className;
      var column = React.cloneElement(col, {
        className: cn(className, getFixedColClassName(fixed, index, leftColumns.length - 1, isMultiSelect)),
        positionLeft: offset
      });
      offset += width;
      leftColumns[index] = column;
    });
  }

  if (!isEmpty(rightColumns)) {
    var _offset = 0;

    var _columns = _toConsumableArray(rightColumns).reverse();

    var length = rightColumns.length - 1;

    _columns.forEach(function (col, index) {
      var _col$props3 = col.props,
          width = _col$props3.width,
          fixed = _col$props3.fixed;
      var column = React.cloneElement(col, {
        className: getFixedColClassName(fixed, length - index, leftColumns.length),
        positionRight: _offset
      });
      _offset += width;
      rightColumns[length - index] = column;
    });
  }

  return [].concat(_toConsumableArray(leftColumns), _toConsumableArray(centerColumns), _toConsumableArray(rightColumns));
};
/**
 *  Get the teable cells to render to the table
 * @param columns { Array } Array of nodes
 * @param multiselect { Boolean }  boolean indicator for multi select
 * @return {Array}
 */

export var getTableCells = function getTableCells(columns, multiselect) {
  var serializedColumns = serializeColumns(columns, multiselect);
  return serializedColumns.reduce(function (_ref3, column) {
    var _ref4 = _slicedToArray(_ref3, 2),
        headerCells = _ref4[0],
        bodyCells = _ref4[1];

    var _column$props = column === null || column === void 0 ? void 0 : column.props,
        columnChildren = _column$props.children,
        rest = _objectWithoutProperties(_column$props, ["children"]);

    var _getColumnCells = getColumnCells(columnChildren, rest),
        header = _getColumnCells.header,
        cell = _getColumnCells.cell;

    headerCells.push(header);
    bodyCells.push(cell);
    return [headerCells, bodyCells];
  }, [[], []]);
};
/**
 * Build an ordered array of columns
 * @param columns {Array} Array of nodes
 * @param source {String} drag source id
 * @param target {String} drag target id
 * @return {Array} - string array of columns id
 */

export var getOrderedColumnsById = function getOrderedColumnsById(columns, source, target) {
  var sourceColumn = columns.find(function (child) {
    var _child$props;

    return (child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.dataKey) === source;
  });
  var sourceIndex = -1;
  var orderedColumns = columns.reduce(function (cols, column, index) {
    var dataKey = column.props.dataKey;

    if (dataKey === source) {
      sourceIndex = index;
      return cols;
    }

    if (dataKey === target) {
      if (sourceIndex === -1) {
        cols.push(sourceColumn);
        cols.push(column);
      } else {
        cols.push(column);
        cols.push(sourceColumn);
      }
    } else {
      cols.push(column);
    }

    return cols;
  }, []);
  return orderedColumns.map(function (col) {
    var _col$props4;

    return col === null || col === void 0 ? void 0 : (_col$props4 = col.props) === null || _col$props4 === void 0 ? void 0 : _col$props4.dataKey;
  });
};
export var getEmptySelection = function getEmptySelection() {
  return {
    allSelected: false,
    items: new Set(),
    exceptItems: new Set()
  };
};
/**
 * Produces rows selection state based on the current state and next user action
 * @param rowSelection {Object} - { allSelected, items, exceptItems }
 * @param action {Object} - { rowId, selectAll }
 * @param data {Array} - table data
 * @param rowIdDataKey {String} - key from row data to be used as identifier
 */

export function getSelectionOnAction(_ref5) {
  var rowSelection = _ref5.rowSelection,
      action = _ref5.action,
      data = _ref5.data,
      _ref5$rowIdDataKey = _ref5.rowIdDataKey,
      rowIdDataKey = _ref5$rowIdDataKey === void 0 ? '_id' : _ref5$rowIdDataKey,
      itemsTotalCount = _ref5.itemsTotalCount;
  var rowId = action.rowId,
      selectAll = action.selectAll;
  var prevAllSelected = rowSelection.allSelected,
      prevItems = rowSelection.items,
      prevExceptItems = rowSelection.exceptItems;
  var allSelected = prevAllSelected;
  var items = new Set(prevItems);
  var exceptItems = new Set(prevExceptItems);
  var totalCount = itemsTotalCount || (data === null || data === void 0 ? void 0 : data.length) || 0;
  var rowSelect = !items.has(rowId);
  var rowUnSelect = !rowSelect;

  if (selectAll) {
    var someSelected = items.size;
    var ids = someSelected ? [] : data.map(function (item) {
      return item[rowIdDataKey];
    });
    return {
      allSelected: !someSelected,
      items: new Set(ids),
      exceptItems: new Set()
    };
  }

  if (!allSelected && rowSelect) {
    items.add(rowId);
    exceptItems.clear();

    if (items.size === totalCount) {
      allSelected = true;
    }
  }

  if (!allSelected && rowUnSelect) {
    items["delete"](rowId);
    exceptItems.clear();
  }

  if (allSelected && rowSelect) {
    items.add(rowId);
    exceptItems["delete"](rowId);
  }

  if (allSelected && rowUnSelect) {
    items["delete"](rowId);
    exceptItems.add(rowId);

    if (exceptItems.size === totalCount) {
      allSelected = false;
    }
  }

  return {
    allSelected: allSelected,
    items: items,
    exceptItems: exceptItems
  };
}
/**
 * Produces rows selection state based on the current state and data
 * @param rowSelection {Object} - { allSelected, items, exceptItems }
 * @param data {Array} - table data
 * @param rowIdDataKey {String} - key from row data to be used as identifier
 * @returns {Object} - { allSelected, items, exceptItems }
 */

export function getSelectionOnData(_ref6) {
  var rowSelection = _ref6.rowSelection,
      data = _ref6.data,
      _ref6$rowIdDataKey = _ref6.rowIdDataKey,
      rowIdDataKey = _ref6$rowIdDataKey === void 0 ? '_id' : _ref6$rowIdDataKey;
  var allSelected = rowSelection.allSelected,
      items = rowSelection.items,
      exceptItems = rowSelection.exceptItems;
  var newItems = new Set();

  if (allSelected) {
    var ids = data.map(function (item) {
      return item[rowIdDataKey];
    });
    newItems = new Set(ids);
    exceptItems.forEach(function (id) {
      return newItems["delete"](id);
    });
    return {
      allSelected: allSelected,
      items: new Set([].concat(_toConsumableArray(items), _toConsumableArray(newItems))),
      exceptItems: exceptItems
    };
  }

  return {
    allSelected: allSelected,
    items: items,
    exceptItems: exceptItems
  };
}