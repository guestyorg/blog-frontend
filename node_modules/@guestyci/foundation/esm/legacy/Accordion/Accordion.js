import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import Collapse from "../Collapse/Collapse";
import AccordionTitle from "./AccordionTitle";

var Accordion = /*#__PURE__*/function (_PureComponent) {
  _inherits(Accordion, _PureComponent);

  var _super = _createSuper(Accordion);

  function Accordion(props) {
    var _this;

    _classCallCheck(this, Accordion);

    _this = _super.call(this, props);

    _this.handleTitleClick = function () {
      _this.setState(function (prevState) {
        return {
          isOpen: !prevState.isOpen
        };
      }, function () {
        var onChange = _this.props.onChange;
        var isOpen = _this.state.isOpen;

        if (onChange) {
          onChange(isOpen);
        }
      });
    };

    _this.state = {
      isOpen: props.isOpen
    };
    return _this;
  }

  _createClass(Accordion, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this.getIsOpen(prevProps, prevState);
    }
  }, {
    key: "getIsOpen",
    value: function getIsOpen(prevProps) {
      var isOpen = this.props.isOpen;
      var stateOpen = this.state.isOpen;

      if (isOpen !== prevProps.isOpen && isOpen !== stateOpen) {
        this.setState({
          isOpen: isOpen
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          title = _this$props.title,
          hasBorderBottom = _this$props.hasBorderBottom;
      var isOpen = this.state.isOpen;
      return /*#__PURE__*/React.createElement("div", {
        className: cn('flex-center d-flex-fill flex-column border-gray-light', {
          'pb-6': isOpen
        }, {
          'bb-1': hasBorderBottom
        }),
        "data-qa": "accordion"
      }, /*#__PURE__*/React.createElement(AccordionTitle, {
        isOpen: isOpen,
        onClick: this.handleTitleClick,
        title: title
      }), /*#__PURE__*/React.createElement(Collapse, {
        isOpen: isOpen
      }, children));
    }
  }]);

  return Accordion;
}(PureComponent);

Accordion.defaultProps = {
  onChange: null,
  isOpen: false,
  hasBorderBottom: true
};
Accordion.propTypes = {
  /** The accordion component children */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,

  /** The accordion title element */
  title: PropTypes.node.isRequired,

  /** CallBack for on click (for controlled mode ) */
  onChange: PropTypes.func,

  /** Indicator whether or not to open accordion (for controlled mode ) */
  isOpen: PropTypes.bool,

  /** Indicator whether or not to have bottom border accordion */
  hasBorderBottom: PropTypes.bool
};
export default Accordion;