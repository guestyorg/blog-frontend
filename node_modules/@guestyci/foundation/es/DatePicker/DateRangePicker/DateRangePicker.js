import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
import React, { useState, useMemo, forwardRef } from 'react';
import PropTypes from 'prop-types';
import momentPropTypes from 'react-moment-proptypes';
import { END_DATE, START_DATE, OPEN_DOWN } from 'react-dates/lib/constants';
import 'react-dates/initialize';
import { DateRangePicker as ReactDatesPicker } from 'react-dates';
import moment from 'moment';
import cn from 'classnames';
import createStyles from "../../createStyles";
import { uuid } from "../../utils/commonUtility";
import Row from "../../Layout/Row";
import PickerClearButton from "../../basePicker/PickerClearButton";
import DatePickerStyles from "../styles";
import NavButton from "../NavButton";
import PickerInputButton from "../../basePicker/PickerInputButton";

var BtnCalendar = function BtnCalendar(props) {
  return /*#__PURE__*/React.createElement("svg", props, /*#__PURE__*/React.createElement("path", {
    d: "M18.5 2h-4V0h-1v2h-6V0h-1v2h-4A2.503 2.503 0 0 0 0 4.5v12C0 17.879 1.122 19 2.5 19h16c1.379 0 2.5-1.121 2.5-2.5v-12C21 3.122 19.879 2 18.5 2zm-16 1h4v.667h1V3h6v.667h1V3h4c.827 0 1.5.673 1.5 1.5V7H1V4.5C1 3.673 1.673 3 2.5 3zm16 15h-16c-.827 0-1.5-.673-1.5-1.5V8h19v8.5c0 .827-.673 1.5-1.5 1.5z"
  }));
};

BtnCalendar.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 21 19"
};
import { DATE_FORMAT, DATE_DISPLAY_FORMAT, MONTH_DISPLAY_FORMAT } from "../constants";
import CustomArrowIcon from "../CustomArrowIcon";
export const useStyles = createStyles(theme => ({
  root: DatePickerStyles.root(theme),
  inputContainer: _extends({}, DatePickerStyles.inputContainer, {
    paddingRight: theme.spacer(3)
  }),
  focused: DatePickerStyles.focused(theme),
  error: DatePickerStyles.error(theme),
  disabled: DatePickerStyles.disabled(theme)
}), {
  name: 'DateRangePicker'
});
const DateRangePicker = forwardRef(function DateRangePicker(_ref, ref) {
  let {
    value,
    name,
    onChange,
    focused: focusedProp,
    onFocusChange,
    isFetching,
    error,
    blockedDates,
    isContinuous,
    showClearDate = true,
    enablePastDays,
    disabled,
    onMonthChange,
    initialVisibleMonth,
    anchorDirection = 'left',
    startDatePlaceholderText,
    endDatePlaceholderText,
    startDateId,
    endDateId,
    style,
    className,
    jss
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["value", "name", "onChange", "focused", "onFocusChange", "isFetching", "error", "blockedDates", "isContinuous", "showClearDate", "enablePastDays", "disabled", "onMonthChange", "initialVisibleMonth", "anchorDirection", "startDatePlaceholderText", "endDatePlaceholderText", "startDateId", "endDateId", "style", "className", "jss"]);

  const classes = useStyles({
    jss
  });
  const [focusedState, setFocusState] = useState(false);
  const inputFocus = focusedProp || focusedState;

  const renderMonthElement = ({
    month
  }) => month.format(MONTH_DISPLAY_FORMAT);

  const startDateInputId = useMemo(() => startDateId || uuid(), [startDateId]);
  const endDateInputId = useMemo(() => endDateId || uuid(), [endDateId]);

  const handleFocusChange = focusedInput => {
    if (onFocusChange) {
      onFocusChange(focusedInput);
    }

    setFocusState(focusedInput);
  };

  const isOutsideRange = enablePastDays ? () => false : undefined;

  const handleDatesChange = ({
    startDate,
    endDate
  }) => {
    if (onChange) {
      // If startDate changes - reset endDate
      if (value?.startDate && value.startDate !== startDate) {
        return onChange({
          startDate,
          endDate: undefined
        }, name);
      }

      onChange({
        startDate,
        endDate
      }, name);
    }
  };

  const handleClearDates = () => {
    handleDatesChange({
      startDate: undefined,
      endDate: undefined
    });
  };

  const upperBound = useMemo(() => {
    if (isContinuous) {
      if (value?.startDate && blockedDates) {
        const formattedStartDate = value.startDate.format(DATE_FORMAT);
        return Array.from(blockedDates).sort().find(blockedDay => blockedDay > formattedStartDate);
      }
    }
  }, [value?.startDate, blockedDates, isContinuous]);

  const renderDayContents = day => isFetching ? '...' : day.date();

  const blockedDatesSet = useMemo(() => new Set(blockedDates || []), [blockedDates]);

  const isDayBlocked = day => {
    const formattedDay = day.format(DATE_FORMAT);

    if (isContinuous) {
      if (inputFocus === END_DATE && upperBound) {
        return formattedDay > upperBound || formattedDay < upperBound && !!blockedDatesSet?.has(formattedDay);
      }
    }

    return isFetching || !!blockedDatesSet?.has(formattedDay);
  };

  const handleCalendarButtonClick = () => {
    if (!inputFocus) {
      if (onFocusChange) {
        onFocusChange(START_DATE);
      }

      setFocusState(START_DATE);
    }
  };

  const getInitialVisibleMonth = () => initialVisibleMonth ? moment(initialVisibleMonth) : moment();

  return /*#__PURE__*/React.createElement(Row, {
    ref: ref,
    justify: "between",
    className: cn(classes.root, 'date-picker', className, {
      [classes.focused]: inputFocus
    }, {
      [classes.error]: error
    }, {
      [classes.disabled]: disabled
    }),
    style: style
  }, /*#__PURE__*/React.createElement(PickerInputButton, {
    disabled: disabled,
    onClick: handleCalendarButtonClick,
    svg: BtnCalendar,
    active: !!inputFocus,
    leftAligned: true
  }), /*#__PURE__*/React.createElement(Row, {
    className: classes.inputContainer
  }, /*#__PURE__*/React.createElement(ReactDatesPicker, _extends({
    renderMonthElement: renderMonthElement,
    readOnly: true,
    appendToBody: false,
    onDatesChange: handleDatesChange,
    focusedInput: inputFocus || undefined,
    onFocusChange: handleFocusChange,
    endDateId: endDateInputId,
    startDateId: startDateInputId,
    disabled: disabled,
    startDatePlaceholderText: startDatePlaceholderText,
    endDatePlaceholderText: endDatePlaceholderText,
    startDate: value?.startDate,
    endDate: value?.endDate,
    isDayBlocked: isDayBlocked,
    daySize: 40,
    noBorder: true,
    openDirection: OPEN_DOWN,
    onNextMonthClick: onMonthChange,
    onPrevMonthClick: onMonthChange,
    numberOfMonths: 1,
    hideKeyboardShortcutsPanel: true,
    verticalSpacing: 10,
    renderDayContents: renderDayContents,
    navPrev: /*#__PURE__*/React.createElement(NavButton, {
      direction: "Left"
    }),
    navNext: /*#__PURE__*/React.createElement(NavButton, {
      direction: "Right"
    }),
    customArrowIcon: /*#__PURE__*/React.createElement(CustomArrowIcon, {
      isInputEmpty: !value?.startDate && !value?.endDate
    }),
    isOutsideRange: isOutsideRange,
    initialVisibleMonth: getInitialVisibleMonth,
    anchorDirection: anchorDirection,
    displayFormat: DATE_DISPLAY_FORMAT
  }, rest)), /*#__PURE__*/React.createElement(PickerClearButton, {
    show: showClearDate && (value?.startDate || value?.endDate),
    onClick: handleClearDates
  })));
});
DateRangePicker.displayName = 'DateRangePicker';
export default DateRangePicker;
DateRangePicker.propTypes = {
  /** the picked date range */
  value: PropTypes.shape({
    startDate: momentPropTypes.momentObj,
    endDate: momentPropTypes.momentObj
  }),

  /** date picker name to be set */
  name: PropTypes.string,

  /** Callback to be called on picker value change */
  onChange: PropTypes.func,

  /** Control focus state - focued => picker opens. Not required - focus state is uncontrolled by default */
  focused: PropTypes.bool,

  /** Callback to be called when focus state changes. Called with a boolean  */
  onFocusChange: PropTypes.func,

  /** Fetching state */
  isFetching: PropTypes.bool,

  /** Indicator for form error state  */
  error: PropTypes.bool,

  /** Array of blocked dates - formatted as YYYY-MM-DD */
  blockedDates: PropTypes.arrayOf(PropTypes.string),

  /** accept only a continuous range. Meaning, it cannot contain blocked days */
  isContinuous: PropTypes.bool,

  /** When dates is selected - show a clear button */
  showClearDate: PropTypes.bool,

  /** Enable past days */
  enablePastDays: PropTypes.bool,

  /** Disable state in which picker interaction is not available */
  disabled: PropTypes.bool,

  /** callback to be called when a switching months. Called with a momnet object of the new month */
  onMonthChange: PropTypes.func,

  /** month to be show when the dialog picker opens - formatted as YYYY-MM-DD */
  initialVisibleMonth: PropTypes.string,

  /** Anchor direction to open the picker - */
  anchorDirection: PropTypes.oneOf(['left', 'right']),

  /** Placeholder for the start date */
  startDatePlaceholderText: PropTypes.string,

  /** Placeholder for the end date */
  endDatePlaceholderText: PropTypes.string,

  /** id for the start date */
  startDateId: PropTypes.string,

  /** id for the end date */
  endDateId: PropTypes.string,

  /** class name to be added to the root */
  className: PropTypes.string,

  /** style to be added to the root */
  style: PropTypes.shape(),
  jss: PropTypes.oneOfType([PropTypes.shape(), PropTypes.func])
};